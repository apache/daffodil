<?xml version="1.0" encoding="UTF-8"?>
<tdml:testSuite xmlns:tdml="http://www.ibm.com/xmlns/dfdl/testData"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dfdl="http://www.ogf.org/dfdl/dfdl-1.0/"
  xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:ex="http://example.com">


  <tdml:defineSchema name="s1">

    <dfdl:format ref="ex:daffodilTest1" />

    <xs:element name="e" type="xs:string" dfdl:lengthKind="delimited"
      dfdl:leadingSkip="3" />
    <xs:element name="e2" type="xs:string" dfdl:lengthKind="delimited"
      dfdl:leadingSkip="3000000" />

  </tdml:defineSchema>
  
  <tdml:defineSchema name="alignmentSchema">
    
    <dfdl:format ref="ex:daffodilTest1" representation="binary" encoding="utf-8" alignmentUnits="bits" alignment="4" leadingSkip="0"/>
    
    <xs:element name="string32be" dfdl:representation="text" type="xs:string" dfdl:encoding="utf-32be" dfdl:lengthKind="explicit" dfdl:length="4" dfdl:lengthUnits="bytes"
      dfdl:alignment="2" dfdl:alignmentUnits="bits" dfdl:leadingSkip="0"/>


    <xs:simpleType name="uByte2Bits" dfdl:lengthKind="explicit" dfdl:lengthUnits="bits" dfdl:length="2" dfdl:leadingSkip="4">
      <xs:restriction base="xs:unsignedByte"/>
    </xs:simpleType>

    <xs:element name="e" type="xs:unsignedByte" dfdl:lengthKind="implicit" dfdl:alignment="2" dfdl:alignmentUnits="bits" dfdl:leadingSkip="4" />
    <xs:element name="e2" type="xs:unsignedInt" dfdl:lengthKind="implicit" dfdl:alignment="2" dfdl:alignmentUnits="bits" dfdl:leadingSkip="8" />
    <xs:element name="e3" dfdl:leadingSkip="0">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="one" type="ex:uByte2Bits"/>
          <xs:element name="two" type="ex:uByte2Bits"/>
          <xs:element name="three" type="ex:uByte2Bits"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e4">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="one" dfdl:alignment="8" type="ex:uByte2Bits"/>
          <xs:element name="two" dfdl:alignment="8" type="ex:uByte2Bits"/>
          <xs:element name="three" dfdl:alignment="8" type="ex:uByte2Bits"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    

    <xs:simpleType name="explUIntBit" dfdl:lengthKind="explicit" dfdl:lengthUnits="bits" dfdl:alignmentUnits="bits" dfdl:leadingSkip="0">
      <xs:restriction base="xs:unsignedInt"/>
    </xs:simpleType>
    <xs:simpleType name="explUIntByte" dfdl:lengthKind="explicit" dfdl:lengthUnits="bytes" dfdl:alignmentUnits="bytes" dfdl:leadingSkip="0">
      <xs:restriction base="xs:unsignedInt"/>
    </xs:simpleType>
    <xs:simpleType name="explUIntMix" dfdl:lengthKind="explicit" dfdl:lengthUnits="bits" dfdl:alignmentUnits="bytes" dfdl:leadingSkip="0">
      <xs:restriction base="xs:unsignedInt"/>
    </xs:simpleType>

    <xs:element name="e5">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="one" type="ex:explUIntBit" dfdl:length="2" dfdl:alignment="4"/>
          <xs:element name="two" type="ex:explUIntBit" dfdl:length="6" dfdl:alignment="4"/>
          <xs:element name="three" type="ex:explUIntBit" dfdl:length="1" dfdl:alignment="4"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e6">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="one" type="ex:explUIntBit" dfdl:length="3" dfdl:alignment="4"/>
          <xs:element name="two" type="ex:explUIntBit" dfdl:length="9" dfdl:alignment="8"/>
          <xs:element name="three" type="ex:explUIntBit" dfdl:length="1" dfdl:alignment="4"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e7">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="one" type="ex:explUIntMix" dfdl:length="6" dfdl:alignment="1"/>
          <xs:element name="two" type="ex:explUIntMix" dfdl:length="3" dfdl:alignment="2"/>
          <xs:element name="three" type="ex:explUIntMix" dfdl:length="12" dfdl:alignment="1"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e8">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="one" type="ex:explUIntByte" dfdl:length="1" dfdl:alignment="1"/>
          <xs:element name="two" type="ex:explUIntByte" dfdl:length="1" dfdl:alignment="2"/>
          <xs:element name="three" type="ex:explUIntByte" dfdl:length="3" dfdl:alignment="1"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e9">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="one" type="ex:explUIntByte" dfdl:length="1" dfdl:alignment="1"/>
          <xs:element name="two" type="ex:explUIntByte" dfdl:length="1" dfdl:alignment="1"/>
          <xs:element name="three" type="ex:explUIntByte" dfdl:length="3" dfdl:alignment="4"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e10">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="one" type="xs:unsignedInt" dfdl:lengthKind="explicit" dfdl:lengthUnits="bits"
            dfdl:length="1" dfdl:alignment="1"/>
          <xs:element name="two" type="xs:unsignedInt" dfdl:lengthKind="explicit" dfdl:lengthUnits="bits"
            minOccurs="0" maxOccurs="1" dfdl:length="1" dfdl:alignment="1"/>
          <xs:element name="three" type="xs:unsignedInt" dfdl:lengthKind="explicit" dfdl:lengthUnits="bits"
            dfdl:length="3" dfdl:alignment="4"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e10a">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="one" type="xs:unsignedInt" dfdl:lengthKind="explicit"
            minOccurs="0" maxOccurs="1" dfdl:lengthUnits="bits" dfdl:length="1" dfdl:alignment="1"/>
          <xs:element name="two" type="xs:unsignedInt" dfdl:lengthKind="explicit"
            dfdl:length="1" dfdl:lengthUnits="bits" dfdl:alignment="2"/>
          <xs:element name="three" type="xs:unsignedInt" dfdl:lengthKind="explicit"
            dfdl:length="3" dfdl:lengthUnits="bits" dfdl:alignment="4"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e10b">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="varArr">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="e" type="xs:unsignedInt" dfdl:lengthKind="explicit" 
                  minOccurs="0" maxOccurs="5" dfdl:lengthUnits="bits" dfdl:length="8" dfdl:alignment="2"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="one" type="xs:unsignedInt" dfdl:lengthKind="explicit"
            minOccurs="0" maxOccurs="1" dfdl:lengthUnits="bits" dfdl:length="8" dfdl:alignment="1"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e10c">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="one" type="xs:unsignedInt" dfdl:lengthKind="explicit"
            minOccurs="0" maxOccurs="1" dfdl:lengthUnits="bits" dfdl:length="8" dfdl:alignment="1"/>
          <xs:element name="two" type="xs:unsignedInt" dfdl:lengthKind="explicit"
            dfdl:length="8" dfdl:lengthUnits="bits" dfdl:alignment="2"/>
          <xs:element name="three" type="xs:unsignedInt" dfdl:lengthKind="explicit"
            dfdl:length="3" dfdl:lengthUnits="bits" dfdl:alignment="4"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e11" dfdl:representation="text" dfdl:lengthKind="explicit" dfdl:length="4" dfdl:encoding="utf-8" 
      dfdl:lengthUnits="bytes" dfdl:alignment="4" dfdl:leadingSkip="4">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:maxLength value="4" />
          <xs:minLength value="4" />
        </xs:restriction>
      </xs:simpleType>
    </xs:element>

    <xs:element name="e12">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="bits" type="xs:unsignedByte" dfdl:represenation="binary" dfdl:leadingSkip="0" dfdl:alignment="1" 
            dfdl:alignmentUnits="bits" dfdl:lengthKind="explicit" dfdl:lengthUnits="bits" dfdl:length="4"/>
          <xs:element name="string" type="xs:string" dfdl:representation="text" dfdl:lengthKind="explicit" dfdl:length="4" dfdl:encoding="utf-8" dfdl:leadingSkip="0"
            dfdl:lengthUnits="bytes" dfdl:alignment="8" dfdl:alignmentUnits="bits">
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e13" type="xs:string" dfdl:initiator=":" dfdl:representation="text" dfdl:lengthKind="explicit" dfdl:length="5" dfdl:encoding="utf-8" 
      dfdl:lengthUnits="bytes" dfdl:alignment="8" dfdl:alignmentUnits="bits" dfdl:leadingSkip="4"/>
    
    <xs:element name="e14" type="xs:string" dfdl:terminator=":" dfdl:representation="text" dfdl:lengthKind="explicit" dfdl:length="5" dfdl:encoding="utf-8" 
      dfdl:lengthUnits="bytes" dfdl:alignment="8" dfdl:alignmentUnits="bits" dfdl:leadingSkip="0" dfdl:trailingSkip="8"/>

    <xs:element name="e15">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="e13" type="xs:string" dfdl:initiator=":" dfdl:representation="text" dfdl:lengthKind="explicit" dfdl:length="5" dfdl:encoding="utf-8" 
            dfdl:lengthUnits="bytes" dfdl:alignment="8" dfdl:alignmentUnits="bits" dfdl:leadingSkip="4"/>
          <xs:element name="e14" type="xs:string" dfdl:terminator=":" dfdl:representation="text" dfdl:lengthKind="explicit" dfdl:length="5" dfdl:encoding="utf-8" 
            dfdl:lengthUnits="bytes" dfdl:alignment="8" dfdl:alignmentUnits="bits" dfdl:leadingSkip="0" dfdl:trailingSkip="8"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e16">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="e14" type="xs:string" dfdl:terminator=":" dfdl:representation="text" dfdl:lengthKind="explicit" dfdl:length="5" dfdl:encoding="utf-8" 
            dfdl:lengthUnits="bytes" dfdl:alignment="8" dfdl:alignmentUnits="bits" dfdl:leadingSkip="0" dfdl:trailingSkip="8"/>
          <xs:element name="e13" type="xs:string" dfdl:initiator=":" dfdl:representation="text" dfdl:lengthKind="explicit" dfdl:length="5" dfdl:encoding="utf-8" 
            dfdl:lengthUnits="bytes" dfdl:alignment="8" dfdl:alignmentUnits="bits" dfdl:leadingSkip="4"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e17" dfdl:alignment="4" dfdl:alignmentUnits="bytes" dfdl:leadingSkip="2" dfdl:trailingSkip="2">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="e14" type="xs:string" dfdl:terminator=":" dfdl:representation="text" dfdl:lengthKind="explicit" dfdl:length="5" dfdl:encoding="utf-8" 
            dfdl:lengthUnits="bytes" dfdl:alignment="8" dfdl:alignmentUnits="bits" dfdl:leadingSkip="0" dfdl:trailingSkip="8"/>
          <xs:element name="e13" type="xs:string" dfdl:initiator=":" dfdl:representation="text" dfdl:lengthKind="explicit" dfdl:length="5" dfdl:encoding="utf-8" 
            dfdl:lengthUnits="bytes" dfdl:alignment="8" dfdl:alignmentUnits="bits" dfdl:leadingSkip="4"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e18" dfdl:alignment="4" dfdl:alignmentUnits="bytes" dfdl:leadingSkip="1" dfdl:trailingSkip="2">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="a" dfdl:alignment="4" dfdl:alignmentUnits="bytes" dfdl:leadingSkip="2" dfdl:trailingSkip="2">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="a1" type="xs:string" dfdl:terminator=":" dfdl:representation="text" dfdl:lengthKind="explicit" dfdl:length="5" dfdl:encoding="utf-8" 
                  dfdl:lengthUnits="bytes" dfdl:alignment="8" dfdl:alignmentUnits="bits" dfdl:leadingSkip="0" dfdl:trailingSkip="8"/>
                <xs:element name="a2" type="xs:string" dfdl:initiator=":" dfdl:representation="text" dfdl:lengthKind="explicit" dfdl:length="5" dfdl:encoding="utf-8" 
                  dfdl:lengthUnits="bytes" dfdl:alignment="8" dfdl:alignmentUnits="bits" dfdl:leadingSkip="4"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="b" dfdl:alignment="4" dfdl:alignmentUnits="bytes" dfdl:leadingSkip="2" dfdl:trailingSkip="2">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="b1" type="xs:string" dfdl:terminator="" dfdl:representation="text" dfdl:lengthKind="explicit" dfdl:length="5" dfdl:encoding="utf-8" 
                  dfdl:lengthUnits="bytes" dfdl:alignment="1" dfdl:alignmentUnits="bytes" dfdl:leadingSkip="0" dfdl:trailingSkip="8"/>
                <xs:element name="b2" type="xs:string" dfdl:initiator="" dfdl:representation="text" dfdl:lengthKind="explicit" dfdl:length="5" dfdl:encoding="utf-8" 
                  dfdl:lengthUnits="bytes" dfdl:alignment="2" dfdl:alignmentUnits="bytes" dfdl:leadingSkip="1"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e19" dfdl:alignment="4" dfdl:alignmentUnits="bytes" dfdl:leadingSkip="2" dfdl:trailingSkip="2">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="e14" type="xs:string" dfdl:terminator=":" dfdl:representation="text" dfdl:lengthKind="explicit" dfdl:length="5" dfdl:encoding="utf-8" 
            dfdl:lengthUnits="bytes" dfdl:alignment="8" dfdl:alignmentUnits="bits" dfdl:leadingSkip="0" dfdl:trailingSkip="8"/>
          <xs:element name="e13" type="xs:string" dfdl:initiator=":" dfdl:representation="text" dfdl:lengthKind="explicit" dfdl:length="5" dfdl:encoding="utf-8" 
            dfdl:lengthUnits="bytes" dfdl:alignment="8" dfdl:alignmentUnits="bits" dfdl:leadingSkip="4"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e20" dfdl:alignment="4" dfdl:alignmentUnits="bytes" dfdl:leadingSkip="2" dfdl:trailingSkip="2">
      <xs:complexType>
        <xs:sequence dfdl:initiator="^">
          <xs:element name="a" dfdl:alignment="4" dfdl:alignmentUnits="bytes" dfdl:leadingSkip="2" dfdl:trailingSkip="2">
            <xs:complexType>
              <xs:sequence dfdl:separator=",">
                <xs:element name="a1" type="xs:string" dfdl:terminator=":" dfdl:representation="text" dfdl:lengthKind="explicit" dfdl:length="5" dfdl:encoding="utf-8" 
                  dfdl:lengthUnits="bytes" dfdl:alignment="8" dfdl:alignmentUnits="bits" dfdl:leadingSkip="0" dfdl:trailingSkip="8"/>
                <xs:element name="a2" type="xs:string" dfdl:initiator=":" dfdl:representation="text" dfdl:lengthKind="explicit" dfdl:length="5" dfdl:encoding="utf-8" 
                  dfdl:lengthUnits="bytes" dfdl:alignment="8" dfdl:alignmentUnits="bits" dfdl:leadingSkip="4"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e21" dfdl:alignment="4" dfdl:alignmentUnits="bytes" dfdl:leadingSkip="2" dfdl:trailingSkip="2">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="a" dfdl:alignment="4" dfdl:alignmentUnits="bytes" dfdl:leadingSkip="2" dfdl:trailingSkip="2">
            <xs:complexType>
              <xs:sequence dfdl:separator=",">
                <xs:element name="a1" type="xs:string" dfdl:terminator=":" dfdl:representation="text" dfdl:lengthKind="explicit" dfdl:length="5" dfdl:encoding="utf-8" 
                  dfdl:lengthUnits="bytes" dfdl:alignment="8" dfdl:alignmentUnits="bits" dfdl:leadingSkip="0" dfdl:trailingSkip="8"/>
                <xs:element name="a2" type="xs:string" dfdl:initiator=":" dfdl:representation="text" dfdl:lengthKind="explicit" dfdl:length="5" dfdl:encoding="utf-8" 
                  dfdl:lengthUnits="bytes" dfdl:alignment="8" dfdl:alignmentUnits="bits" dfdl:leadingSkip="4"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e22" dfdl:alignment="4" dfdl:alignmentUnits="bytes" dfdl:leadingSkip="2" dfdl:trailingSkip="2">
      <xs:complexType>
        <xs:choice>
          <xs:element name="a1" type="xs:string" dfdl:terminator=":" dfdl:representation="text" dfdl:lengthKind="explicit" dfdl:length="5" dfdl:encoding="utf-8" 
            dfdl:lengthUnits="bytes" dfdl:alignment="8" dfdl:alignmentUnits="bytes" dfdl:leadingSkip="4" dfdl:trailingSkip="2"/>
          <xs:element name="a2" type="xs:string" dfdl:initiator=":" dfdl:representation="text" dfdl:lengthKind="explicit" dfdl:length="5" dfdl:encoding="utf-8" 
            dfdl:lengthUnits="bytes" dfdl:alignment="8" dfdl:alignmentUnits="bytes" dfdl:leadingSkip="4"/>
        </xs:choice>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e23" dfdl:alignment="4" dfdl:alignmentUnits="bytes" dfdl:leadingSkip="2" dfdl:trailingSkip="2">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="e23a" minOccurs="2">
            <xs:complexType>
              <xs:choice>
                <xs:element name="a1" type="xs:string" dfdl:representation="text" dfdl:lengthKind="explicit" dfdl:length="5" dfdl:encoding="utf-8" 
                  dfdl:lengthUnits="bytes" dfdl:alignment="4" dfdl:initiator=":" dfdl:alignmentUnits="bytes" dfdl:leadingSkip="4" dfdl:trailingSkip="2"/>
                <xs:element name="a2" type="xs:string" dfdl:representation="text" dfdl:lengthKind="explicit" dfdl:length="5" dfdl:encoding="utf-8" 
                  dfdl:lengthUnits="bytes" dfdl:alignment="8" dfdl:terminator=":" dfdl:alignmentUnits="bytes" dfdl:leadingSkip="4"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e24" dfdl:alignment="4" dfdl:alignmentUnits="bytes" dfdl:leadingSkip="2" dfdl:trailingSkip="2">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="e24a" minOccurs="2">
            <xs:complexType>
              <xs:choice>
                <xs:element name="a1" type="xs:string" dfdl:representation="text" dfdl:lengthKind="explicit" dfdl:length="5" dfdl:encoding="utf-8" 
                  dfdl:lengthUnits="bytes" dfdl:alignment="4" dfdl:initiator=":" dfdl:alignmentUnits="bytes" dfdl:leadingSkip="4" dfdl:trailingSkip="2"/>
                <xs:element name="a2" type="xs:string" dfdl:representation="text" dfdl:lengthKind="delimited" dfdl:length="5" dfdl:encoding="utf-8" 
                  dfdl:lengthUnits="bytes" dfdl:alignment="8" dfdl:terminator=":" dfdl:alignmentUnits="bytes" dfdl:leadingSkip="4"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
          <xs:element name="e24b" minOccurs="2">
            <xs:complexType>
              <xs:choice>
                <xs:element name="b1" type="xs:nonNegativeInteger" dfdl:representation="text" dfdl:lengthKind="explicit" dfdl:length="2" dfdl:encoding="utf-8" 
                  dfdl:lengthUnits="bytes" dfdl:alignment="8" dfdl:alignmentUnits="bytes" dfdl:leadingSkip="4"/>
                <xs:element name="b2" type="xs:int" dfdl:representation="text" dfdl:lengthKind="explicit" dfdl:length="3" dfdl:encoding="utf-8" 
                  dfdl:lengthUnits="bytes" dfdl:alignment="4" dfdl:alignmentUnits="bytes" dfdl:leadingSkip="4" dfdl:trailingSkip="2"/>
              </xs:choice>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e25">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="repeat" type="xs:string" dfdl:alignmentUnits="bytes" dfdl:alignment="4" dfdl:lengthKind="delimited" 
            minOccurs="5" dfdl:representation="text" dfdl:leadingSkip="2" dfdl:trailingSkip="4"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e26">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="repeat" type="xs:string" dfdl:terminator="|" dfdl:alignmentUnits="bytes" dfdl:alignment="4" dfdl:lengthKind="delimited" 
            minOccurs="5" dfdl:representation="text" dfdl:leadingSkip="2" dfdl:trailingSkip="4"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e27">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="outer" minOccurs="3" dfdl:alignment="2" dfdl:leadingSkip="1" dfdl:alignmentUnits="bytes" dfdl:lengthKind="delimited">
            <xs:complexType>
              <xs:sequence dfdl:separator="|">
                <xs:element name="inner" type="xs:string" dfdl:initiator="(" dfdl:terminator=")" dfdl:alignmentUnits="bytes" dfdl:alignment="4" dfdl:lengthKind="delimited" 
                  minOccurs="2" dfdl:representation="text" dfdl:leadingSkip="2" dfdl:trailingSkip="4"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

  </tdml:defineSchema>
  
  <tdml:defineSchema name="implicitAlignmentSchema">

    <dfdl:format ref="ex:daffodilTest1" representation="binary" encoding="utf-8" 
      lengthUnits="bits" alignmentUnits="bits" binaryNumberRep="binary"/>

    <xs:element name="string" dfdl:lengthKind="implicit" dfdl:length="4" dfdl:encoding="utf-8" 
      dfdl:lengthUnits="bytes" dfdl:alignment="implicit" dfdl:leadingSkip="4">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:maxLength value="4" />
          <xs:minLength value="4" />
        </xs:restriction>
      </xs:simpleType>
    </xs:element>

    <xs:element name="hB" type="xs:hexBinary" dfdl:lengthKind="delimited" dfdl:alignment="implicit" dfdl:alignmentUnits="bits" dfdl:leadingSkip="4" />
    <xs:element name="hB2" type="xs:hexBinary" dfdl:lengthKind="delimited" dfdl:alignment="implicit" dfdl:alignmentUnits="bytes" dfdl:leadingSkip="4" />

    <xs:element name="uInt" type="xs:unsignedInt" dfdl:lengthKind="explicit" dfdl:length="32" dfdl:alignment="implicit" dfdl:leadingSkip="1"/>
    <xs:element name="uShort" type="xs:unsignedShort" dfdl:lengthKind="explicit" dfdl:length="5" dfdl:alignment="implicit" dfdl:leadingSkip="1"/>
    <xs:element name="uLong" type="xs:unsignedLong" dfdl:lengthKind="implicit" dfdl:alignment="implicit" dfdl:leadingSkip="5"/>
    <xs:element name="int" type="xs:int" dfdl:lengthKind="implicit" dfdl:alignment="implicit" dfdl:leadingSkip="16"/>
    <xs:element name="short" type="xs:short" dfdl:lengthKind="implicit" dfdl:alignment="implicit" dfdl:leadingSkip="6"/>
    <xs:element name="long" type="xs:long" dfdl:lengthKind="implicit" dfdl:alignment="implicit" dfdl:leadingSkip="20"/>
    <xs:element name="byte" type="xs:byte" dfdl:lengthKind="implicit" dfdl:alignment="implicit" dfdl:leadingSkip="2"/>
    <xs:element name="uByte" type="xs:unsignedByte" dfdl:lengthKind="implicit" dfdl:alignment="implicit" dfdl:leadingSkip="2"/>
    <xs:element name="float" type="xs:float" dfdl:lengthKind="implicit" dfdl:alignment="implicit" dfdl:leadingSkip="2" dfdl:lengthUnits="bytes" dfdl:alignmentUnits="bytes"/>

    <xs:element name="double" type="xs:double" dfdl:lengthKind="implicit" dfdl:alignment="implicit" dfdl:leadingSkip="2" dfdl:lengthUnits="bytes" dfdl:alignmentUnits="bytes"/>
    <xs:element name="double2" type="xs:double" dfdl:lengthKind="implicit" dfdl:alignment="implicit" dfdl:leadingSkip="2" dfdl:lengthUnits="bytes" dfdl:alignmentUnits="bits"/>
    
    <xs:element name="nonNeg" type="xs:nonNegativeInteger" dfdl:lengthKind="explicit" dfdl:length="5" dfdl:alignment="implicit" dfdl:leadingSkip="2" dfdl:lengthUnits="bytes" dfdl:alignmentUnits="bytes"/>
    <xs:element name="nonNeg2" type="xs:nonNegativeInteger" dfdl:lengthKind="explicit" dfdl:length="2" dfdl:alignment="implicit" dfdl:leadingSkip="1" dfdl:lengthUnits="bytes" dfdl:alignmentUnits="bits"/>
    
    <xs:element name="integer" type="xs:integer" dfdl:lengthKind="explicit" dfdl:length="5" dfdl:alignment="implicit" dfdl:leadingSkip="2" dfdl:lengthUnits="bytes" dfdl:alignmentUnits="bytes"/>
    <xs:element name="integer2" type="xs:integer" dfdl:lengthKind="explicit" dfdl:length="2" dfdl:alignment="implicit" dfdl:leadingSkip="1" dfdl:lengthUnits="bytes" dfdl:alignmentUnits="bits"/>

    <xs:element name="decimal" type="xs:decimal" dfdl:binaryDecimalVirtualPoint="1" dfdl:lengthKind="explicit" dfdl:length="5" dfdl:alignment="implicit" dfdl:leadingSkip="2" dfdl:lengthUnits="bytes" dfdl:alignmentUnits="bytes"/>
    <xs:element name="decimal2" type="xs:decimal" dfdl:binaryDecimalVirtualPoint="1" dfdl:lengthKind="explicit" dfdl:length="2" dfdl:alignment="implicit" dfdl:leadingSkip="1" dfdl:lengthUnits="bytes" dfdl:alignmentUnits="bits"/>
      
 <!-- TEXTUAL DATA -->
      
    <xs:element name="string2" type="xs:string" dfdl:lengthKind="explicit" dfdl:length="3" dfdl:lengthUnits="bytes" dfdl:alignment="implicit" dfdl:leadingSkip="16"
    dfdl:representation="text"/>
  
    <dfdl:defineFormat name="textImp">
      <dfdl:format ref="ex:daffodilTest1" lengthKind="delimited" representation="text" alignment="implicit" alignmentUnits="bytes" />
    </dfdl:defineFormat>
    <dfdl:defineFormat name="textImpBitAlign">
      <dfdl:format ref="ex:daffodilTest1" lengthKind="delimited" representation="text" alignment="implicit" alignmentUnits="bits" />
    </dfdl:defineFormat>
  
    <xs:element name="uIntT" type="xs:unsignedInt" dfdl:ref="ex:textImp" dfdl:leadingSkip="1"/>
    <xs:element name="uIntT2" type="xs:unsignedInt" dfdl:ref="ex:textImp" dfdl:encoding="utf-16be" dfdl:leadingSkip="1"/>
    <xs:element name="uShortT" type="xs:unsignedShort" dfdl:ref="ex:textImp" dfdl:leadingSkip="1"/>
    <xs:element name="uShortT2" type="xs:unsignedShort" dfdl:ref="ex:textImp" dfdl:encoding="utf-16be" dfdl:leadingSkip="1"/>
    <xs:element name="uLongT" type="xs:unsignedLong" dfdl:ref="ex:textImp" dfdl:leadingSkip="5"/>
    <xs:element name="longT" type="xs:long" dfdl:ref="ex:textImp" dfdl:leadingSkip="20"/>
    
    <xs:element name="dateT" type="xs:date" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="dd MM yyyy" dfdl:ref="ex:textImp" dfdl:leadingSkip="5"/>
    <xs:element name="dateT2" type="xs:date" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="EEEE 'in' MMMM - yyyy" dfdl:ref="ex:textImp" dfdl:leadingSkip="5"/>
    <xs:element name="timeT" type="xs:time" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="hh:mm:ss" dfdl:ref="ex:textImp" dfdl:leadingSkip="5"/>
    <xs:element name="dateTimeT" type="xs:dateTime" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="EEEE MM yyyy - hh:mm:ss" dfdl:ref="ex:textImp" dfdl:leadingSkip="5"/>
    <xs:element name="nonNegativeIntegerT" type="xs:nonNegativeInteger" dfdl:ref="ex:textImp" dfdl:leadingSkip="1"/>
    <xs:element name="nonNegativeIntegerTBits" type="xs:nonNegativeInteger" dfdl:ref="ex:textImpBitAlign" dfdl:leadingSkip="1"/>
    <xs:element name="integerT" type="xs:integer" dfdl:ref="ex:textImp" dfdl:leadingSkip="1"/>
    <xs:element name="integerTBits" type="xs:integer" dfdl:ref="ex:textImpBitAlign" dfdl:leadingSkip="1"/>
    <xs:element name="decimalT" type="xs:decimal" dfdl:ref="ex:textImp" dfdl:leadingSkip="1"/>
    <xs:element name="decimalTBits" type="xs:decimal" dfdl:ref="ex:textImpBitAlign" dfdl:leadingSkip="1"/>
    <xs:element name="intT" type="xs:int" dfdl:ref="ex:textImpBitAlign" dfdl:leadingSkip="2"/>
    <xs:element name="shortT" type="xs:short" dfdl:ref="ex:textImpBitAlign" dfdl:leadingSkip="6"/>
    <xs:element name="byteT" type="xs:byte" dfdl:ref="ex:textImpBitAlign" dfdl:leadingSkip="2"/>
    <xs:element name="byteT2" type="xs:byte" dfdl:ref="ex:textImpBitAlign" dfdl:encoding="utf-16le" dfdl:leadingSkip="2"/>
    <xs:element name="uByteT" type="xs:unsignedByte" dfdl:ref="ex:textImpBitAlign" dfdl:leadingSkip="2"/>
    <xs:element name="floatT" type="xs:float" dfdl:lengthUnits="bytes" dfdl:ref="ex:textImpBitAlign" dfdl:leadingSkip="2"/>
    <xs:element name="doubleT" type="xs:double" dfdl:ref="ex:textImpBitAlign" dfdl:leadingSkip="2"/>
    <xs:element name="doubleTBits" type="xs:double" dfdl:ref="ex:textImpBitAlign" dfdl:leadingSkip="1"/>

  </tdml:defineSchema>
  
  <!--
     Test Name: impAlignmentHexBinary
        Schema: implicitAlignmentSchema
          Root: hB
          Purpose: This test demonstrates that the implicit alignment for hexBinary data is 8 bits
  -->
  
  <tdml:parserTestCase name="impAlignmentHexBinary" root="hB"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - hexBinary - DFDL-12-029R">

    <tdml:document>
      <tdml:documentPart type="bits">0101</tdml:documentPart> <!-- leadingSkip -->
      <tdml:documentPart type="bits">1101</tdml:documentPart> <!-- padding to fulfill alignment -->
      <tdml:documentPart type="bits">11110100</tdml:documentPart> <!-- hB -->
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <hB>F4</hB>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: impAlignmentHexBinary2
        Schema: implicitAlignmentSchema
          Root: hB2
          Purpose: This test demonstrates that the implicit alignment for hexBinary data is 1 byte
  -->
  
  <tdml:parserTestCase name="impAlignmentHexBinary2" root="hB2"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - hexBinary - DFDL-12-029R">

    <tdml:document>
      <tdml:documentPart type="byte">ab 43 82 b3</tdml:documentPart> <!-- leadingSkip -->
      <tdml:documentPart type="byte">ba ba 00 00</tdml:documentPart> <!-- hB -->
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <hB2>BABA0000</hB2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: alignment01
        Schema: alignmentSchema
          Root: e
       Purpose: This test demonstrates that alignment (2 bits) is applied after leadingSkip (4 bits)
  -->
  
  <tdml:parserTestCase name="alignment01" root="e"
    model="alignmentSchema" description="Section 12.1 Aligned Data - DFDL-12-002R">

    <tdml:document>
      <tdml:documentPart type="bits">0010 00000100</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e>4</e>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: alignment02
        Schema: alignmentSchema
          Root: e3
       Purpose: This test demonstrates that leadingSkip (4 bits) is applied before alignment (4 bits) on each element
  -->
  
  <tdml:parserTestCase name="alignment02" root="e3"
    model="alignmentSchema" description="Section 12.1 Aligned Data - DFDL-12-002R">

    <tdml:document>
      <tdml:documentPart type="bits">00 00</tdml:documentPart> <!-- leadingSkip -->
      <tdml:documentPart type="bits">11 10</tdml:documentPart> <!-- "one" and padding to fulfill alignment-->
      <tdml:documentPart type="bits">10 01</tdml:documentPart> <!-- leadingSkip -->
      <tdml:documentPart type="bits">10 11</tdml:documentPart> <!-- "two" and padding to fulfill alignment -->
      <tdml:documentPart type="bits">01 10</tdml:documentPart> <!-- leadingSkip -->
      <tdml:documentPart type="bits">00</tdml:documentPart> <!-- "three" -->
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e3>
          <one>3</one>
          <two>2</two>
          <three>0</three>
        </e3>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: alignment03
        Schema: alignmentSchema
          Root: e4
       Purpose: This test demonstrates that the leadingSkip (4 bits) is applied before alignment (4 bits)
                for the first element.
  -->
  
  <tdml:parserTestCase name="alignment03" root="e4"
    model="alignmentSchema" description="Section 12.1 Aligned Data - DFDL-12-002R">

    <tdml:document>
      <tdml:documentPart type="bits">00 00</tdml:documentPart> <!-- leadingSkip -->
      <tdml:documentPart type="bits">11 10</tdml:documentPart> 
      <tdml:documentPart type="bits">01</tdml:documentPart> <!-- "one" starting at bit position 8 -->
      <tdml:documentPart type="bits">00 10 01</tdml:documentPart>
      <tdml:documentPart type="bits">10</tdml:documentPart> <!-- "two" starting at bit position 16 -->
      <tdml:documentPart type="bits">11 00 00</tdml:documentPart>
      <tdml:documentPart type="bits">11</tdml:documentPart> <!-- "three" starting at bit position 24 -->
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e4>
          <one>1</one>
          <two>2</two>
          <three>3</three>
        </e4>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: leadingSkip1
        Schema: s1
          Root: e
       Purpose: This test demonstrates a leadingSkip of 3 bytes. The actual data begins at the 4th byte.
  -->

  <tdml:parserTestCase name="leadingSkip1" root="e"
    model="s1" description="Section 12.1 Aligned Data - DFDL-12-005R">

    <tdml:document>
      <tdml:documentPart type="byte">aabbcc</tdml:documentPart>
      <tdml:documentPart type="text">Hello</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e>Hello</e>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: leadingSkip2
        Schema: s1
          Root: e2
       Purpose: This test demonstrates that there is a limit to the size of a leadingSkip (1024).
  -->

  <tdml:parserTestCase name="leadingSkip2" root="e2"
    model="s1" description="Section 12.1 Aligned Data - DFDL-12-005R">

    <tdml:document />

    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Property leadingSkip 3000000 is larger than limit 1024</tdml:error>
    </tdml:errors>

  </tdml:parserTestCase>

  <!--
     Test Name: implicitAlignmentString1
        Schema: implicitAlignmentSchema
          Root: string
       Purpose: This test demonstrates that even is representation is defined
                as binary for type xs:string, implicit alignment still works, and the
                representation is assumed to be text
   -->

  <tdml:parserTestCase name="implicitAlignmentString1" root="string"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - String - DFDL-12-014R - DFDL-13-006R">

    <tdml:document>
      <tdml:documentPart type="bits">0110 0111</tdml:documentPart> <!-- leadingSkip and buffer to fulfill alignment -->
      <tdml:documentPart type="bits">01101111 01100001 01110100 01110011</tdml:documentPart> <!-- string -->
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <string>oats</string>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>


  <!--
     Test Name: implicitAlignmentString2
        Schema: implicitAlignmentSchema
          Root: string2
       Purpose: This test demonstrates that the implicit alignment for the text representation of type 'string' is 8 bits
  -->

  <tdml:parserTestCase name="implicitAlignmentString2" root="string2"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - String - DFDL-12-014R">

    <tdml:document>
      <tdml:documentPart type="bits">01100111 01101111</tdml:documentPart> <!-- leadingSkip -->
      <tdml:documentPart type="bits">01100001 01110100 01110011</tdml:documentPart> <!-- string -->
    </tdml:document>
    
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <string2>ats</string2>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentUInt1
        Schema: implicitAlignmentSchema
          Root: uInt
       Purpose: This test demonstrates that the implicit alignment for the binary representation of type 'unsignedInt' is 32 bits
  -->

  <tdml:parserTestCase name="implicitAlignmentUInt" root="uInt"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - unsignedInt (binary) - DFDL-12-019R">

    <tdml:document>
      <tdml:documentPart type="bits">1 0000000 00000000 00000000 00000000</tdml:documentPart> <!-- leadingSkip and buffer to fulfill alignment -->
      <tdml:documentPart type="bits">00000000 00000000 00000000 00001101</tdml:documentPart> <!-- uInt -->
    </tdml:document>
    
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <uInt>13</uInt>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentUInt1b
        Schema: implicitAlignmentSchema
          Root: uIntb
       Purpose: This test demonstrates that the implicit alignment for the binary representation of type 'unsignedInt' is 32 bits
  -->

  <tdml:parserTestCase name="implicitAlignmentUIntb" root="uIntb"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - unsignedInt (binary) - DFDL-12-019R">

    <tdml:document>
      <tdml:documentPart type="bits">1 0000000 00000000 00000000 00000000</tdml:documentPart> <!-- leadingSkip and buffer to fulfill alignment -->
      <tdml:documentPart type="bits">00000000 00000000 00000000 00001101</tdml:documentPart> <!-- uInt -->
    </tdml:document>
    
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <uIntb>13</uIntb>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentUShort
        Schema: implicitAlignmentSchema
          Root: uShort
       Purpose: This test demonstrates that the implicit alignment for the binary representation of type 'unsignedShort' is 16 bits
  -->

  <tdml:parserTestCase name="implicitAlignmentUShort" root="uShort"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - unsignedShort (binary) - DFDL-12-020R">

    <tdml:document>
      <tdml:documentPart type="bits">1 0000000 00000000</tdml:documentPart> <!-- leadingSkip and buffer to fulfill alignment -->
      <tdml:documentPart type="bits">01101</tdml:documentPart> <!-- uShort -->
    </tdml:document>
    
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <uShort>13</uShort>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentUShortb
        Schema: implicitAlignmentSchema
          Root: uShortb
       Purpose: This test demonstrates that the implicit alignment for the binary representation of type 'unsignedShort' is 16 bits
  -->

  <tdml:parserTestCase name="implicitAlignmentUShortb" root="uShortb"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - unsignedShort (binary) - DFDL-12-020R">

    <tdml:document>
      <tdml:documentPart type="bits">1 0000000 00000000</tdml:documentPart> <!-- leadingSkip and buffer to fulfill alignment -->
      <tdml:documentPart type="bits">01101</tdml:documentPart> <!-- uShort -->
    </tdml:document>
    
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <uShortb>13</uShortb>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentInt
        Schema: implicitAlignmentSchema
          Root: int
       Purpose: This test demonstrates that the implicit alignment for the binary representation of type 'int' is 32 bits
  -->

  <tdml:parserTestCase name="implicitAlignmentInt" root="int"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - int (binary) - DFDL-12-019R">

    <tdml:document>
      <tdml:documentPart type="byte">a4 b4</tdml:documentPart> <!-- leadingSkip -->
      <tdml:documentPart type="byte">a9 cc</tdml:documentPart> <!-- buffer to fulfill alignment -->
      <tdml:documentPart type="byte">00 00 00 1d</tdml:documentPart> <!-- int -->
    </tdml:document>
    
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <int>29</int>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentInt2
        Schema: implicitAlignmentSchema
          Root: int
       Purpose: This test demonstrates that the implicit alignment for the binary representation of type 'int' is 32 bits
                This test uses the binary representation of a negative number. 
  -->

  <tdml:parserTestCase name="implicitAlignmentInt2" root="int"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - int (binary) - DFDL-12-019R">

    <tdml:document>
      <tdml:documentPart type="byte">a4 b4</tdml:documentPart> <!-- leadingSkip -->
      <tdml:documentPart type="byte">a9 cc</tdml:documentPart> <!-- buffer to fulfill alignment -->
      <tdml:documentPart type="byte">ff ff ff e3</tdml:documentPart> <!-- int -->
    </tdml:document>
    
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <int>-29</int>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentShort
        Schema: implicitAlignmentSchema
          Root: short
       Purpose: This test demonstrates that the implicit alignment for the binary representation of type 'short' is 16 bits
  -->

  <tdml:parserTestCase name="implicitAlignmentShort" root="short"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - short (binary) - DFDL-12-020R">

    <tdml:document>
      <tdml:documentPart type="bits">100100</tdml:documentPart> <!-- leadingSkip (6 bits) -->
      <tdml:documentPart type="bits">11011000 10</tdml:documentPart> <!-- buffer to fulfill alignment -->
      <tdml:documentPart type="bits">00000000 10010101</tdml:documentPart> <!-- short -->
    </tdml:document>
    
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <short>149</short>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentShort2
        Schema: implicitAlignmentSchema
          Root: short
       Purpose: This test demonstrates that the implicit alignment for the binary representation of type 'short' is 16 bits
                The data is the binary representation of a negative value.   
  -->

  <tdml:parserTestCase name="implicitAlignmentShort2" root="short"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - short (binary) - DFDL-12-020R">

    <tdml:document>
      <tdml:documentPart type="bits">100100</tdml:documentPart> <!-- leadingSkip (6 bits) -->
      <tdml:documentPart type="bits">11011000 10</tdml:documentPart> <!-- buffer to fulfill alignment -->
      <tdml:documentPart type="bits">11111111 01101011</tdml:documentPart> <!-- short -->
    </tdml:document>
    
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <short>-149</short>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentLong
        Schema: implicitAlignmentSchema
          Root: long
       Purpose: This test demonstrates that the implicit alignment for the binary representation of type 'long' is 64 bits
  -->

  <tdml:parserTestCase name="implicitAlignmentLong" root="long"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - long (binary) - DFDL-12-018R">

    <tdml:document>
      <tdml:documentPart type="bits">11010101 10101010 1101</tdml:documentPart> <!-- leadingSkip (20 bits) -->
      <tdml:documentPart type="bits">1101 01000101 11010010 11010010 11001000 00000010</tdml:documentPart> <!-- buffer to fulfill alignment -->
      <tdml:documentPart type="byte">00 b3 b3 b3 b3 b3 b3 b3</tdml:documentPart> <!-- long -->
    </tdml:document>
    
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <long>50581605226623923</long>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentByte
        Schema: implicitAlignmentSchema
          Root: byte
       Purpose: This test demonstrates that the implicit alignment for the binary representation of type 'byte' is 8 bits
  -->

  <tdml:parserTestCase name="implicitAlignmentByte" root="byte"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - byte (binary) - DFDL-12-021R">

    <tdml:document>
      <tdml:documentPart type="bits">11</tdml:documentPart> <!-- leadingSkip (2 bits) -->
      <tdml:documentPart type="bits">110101</tdml:documentPart> <!-- buffer to fulfill alignment -->
      <tdml:documentPart type="bits">01001010</tdml:documentPart> <!-- byte -->
    </tdml:document>
    
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <byte>74</byte>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentByte2
        Schema: implicitAlignmentSchema
          Root: byte
       Purpose: This test demonstrates that the implicit alignment for the binary representation of type 'byte' is 8 bits
                The data provided represents a negative value.   
  -->

  <tdml:parserTestCase name="implicitAlignmentByte2" root="byte"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - byte (binary) - DFDL-12-021R">

    <tdml:document>
      <tdml:documentPart type="bits">11</tdml:documentPart> <!-- leadingSkip (2 bits) -->
      <tdml:documentPart type="bits">110101</tdml:documentPart> <!-- buffer to fulfill alignment -->
      <tdml:documentPart type="bits">10110110</tdml:documentPart> <!-- byte -->
    </tdml:document>
    
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <byte>-74</byte>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentUByte
        Schema: implicitAlignmentSchema
          Root: uByte
       Purpose: This test demonstrates that the implicit alignment for the binary representation of type 'unsignedByte' is 8 bits
  -->

  <tdml:parserTestCase name="implicitAlignmentUByte" root="uByte"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - unsignedByte (binary) - DFDL-12-021R">

    <tdml:document>
      <tdml:documentPart type="bits">11</tdml:documentPart> <!-- leadingSkip (2 bits) -->
      <tdml:documentPart type="bits">110101</tdml:documentPart> <!-- buffer to fulfill alignment -->
      <tdml:documentPart type="bits">01001010</tdml:documentPart> <!-- uByte -->
    </tdml:document>
    
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <uByte>74</uByte>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentUByte2
        Schema: implicitAlignmentSchema
          Root: uByte
       Purpose: This test demonstrates that the implicit alignment for the binary representation of type 'unsignedByte' is 8 bits
  -->

  <tdml:parserTestCase name="implicitAlignmentUByte2" root="uByte"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - unsignedByte (binary) - DFDL-12-021R">

    <tdml:document>
      <tdml:documentPart type="bits">11</tdml:documentPart> <!-- leadingSkip (2 bits) -->
      <tdml:documentPart type="bits">110101</tdml:documentPart> <!-- buffer to fulfill alignment -->
      <tdml:documentPart type="bits">10110110</tdml:documentPart> <!-- uByte -->
    </tdml:document>
    
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <uByte>182</uByte>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentUIntT
        Schema: implicitAlignmentSchema
          Root: uIntT
       Purpose: This test demonstrates that the implicit alignment for the textual representation of type 'unsignedInt' is
                encoding-specific (generally 8 bits)
  -->

  <tdml:parserTestCase name="implicitAlignmentUIntT" root="uIntT"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - unsignedInt (text) - DFDL-12-019R">

    <tdml:document>
      <tdml:documentPart type="text">3</tdml:documentPart> <!-- leadingSkip -->
      <tdml:documentPart type="text">42</tdml:documentPart> <!-- uIntT -->
    </tdml:document>
    
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <uIntT>42</uIntT>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentUIntT2
        Schema: implicitAlignmentSchema
          Root: uIntT2
       Purpose: This test demonstrates that the implicit alignment for the textual representation of type 'unsignedInt' is
       encoding-specific (generally 8 bits, even though encoding is utf-16be). In this case the data isn't accounting for 
       the leadingSkip, so the test will fail with a useful error message.
  -->

  <tdml:parserTestCase name="implicitAlignmentUIntT2" root="uIntT2"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - unsignedInt (text) - DFDL-12-019R">

    <tdml:document>
      <tdml:documentPart type="byte">00 34 00 32</tdml:documentPart> <!-- uIntT - byte-representation of the number 42 -->
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>Convert to Unsigned Integer (for xs:unsignedInt)</tdml:error>
      <tdml:error>Unable to parse '„êÄ' (using up all characters).</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  
  <!--
     Test Name: implicitAlignmentUIntT2b
        Schema: implicitAlignmentSchema
          Root: uIntT2
       Purpose: This test demonstrates that the implicit alignment for the textual representation of type 'unsignedInt' is
                encoding-specific (generally 8 bits - in this case it should be 8 bits even though the encoding is utf-16be)
  -->

  <tdml:parserTestCase name="implicitAlignmentUIntT2b" root="uIntT2"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - unsignedInt (text) - DFDL-12-019R">

    <tdml:document>
      <tdml:documentPart type="byte">00</tdml:documentPart> <!-- leadingSkip -->
      <tdml:documentPart type="byte">00 34 00 32</tdml:documentPart> <!-- uIntT - byte-representation of the number 42 -->
    </tdml:document>
    
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <uIntT2>42</uIntT2>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentUShortT2b
        Schema: implicitAlignmentSchema
          Root: uShortT2
       Purpose: This test demonstrates that the implicit alignment for the textual representation of type 'unsignedShort' is
                encoding-specific (generally 8 bits - in this case it should be 8 bits even though the encoding is utf-16be)
  -->

  <tdml:parserTestCase name="implicitAlignmentUShortT2b" root="uShortT2"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - unsignedShort (text) - DFDL-12-020R">

    <tdml:document>
      <tdml:documentPart type="byte">00</tdml:documentPart> <!-- leadingSkip -->
      <tdml:documentPart type="byte">00 32</tdml:documentPart> <!-- uIntT - byte-representation of the number 2 -->
    </tdml:document>
    
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <uShortT2>2</uShortT2>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentULongT
        Schema: implicitAlignmentSchema
          Root: uLongT
       Purpose: This test demonstrates that the implicit alignment for the textual representation of type 'unsignedLong' is
                encoding-specific (generally 8 bits)
  -->

  <tdml:parserTestCase name="implicitAlignmentULongT" root="uLongT"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - unsignedLong (text) - DFDL-12-018R">

    <tdml:document>
      <tdml:documentPart type="byte">32 32 32 32 32</tdml:documentPart> <!-- leadingSkip plus 3 filler bits for alignment (8 bits) -->
      <tdml:documentPart type="byte">31 32 33 34 35 36 37 38</tdml:documentPart> <!-- uLongT - byte-representation of 12345678  -->
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <uLongT>12345678</uLongT>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentULongT2
        Schema: implicitAlignmentSchema
          Root: uLongT
       Purpose: This test demonstrates that the implicit alignment for the textual representation of type 'unsignedLong' is
                encoding-specific (generally 8 bits)
  -->

  <tdml:parserTestCase name="implicitAlignmentULongT2" root="uLongT"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - unsignedLong (text) - DFDL-12-018R">

    <tdml:document>
      <tdml:documentPart type="bits">10101111 10001010</tdml:documentPart> <!-- 2 bytes of leadingSkip (in bits) -->
      <tdml:documentPart type="byte">31 32 33</tdml:documentPart> <!-- remaining 3 bytes of leadingSkip (in bytes) -->
      <tdml:documentPart type="byte">31 32 33 34 35 36 37 38</tdml:documentPart> <!-- uLongT - byte-representation of 12345678  -->
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <uLongT>12345678</uLongT>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentIntT
        Schema: implicitAlignmentSchema
          Root: intT
       Purpose: This test demonstrates that the implicit alignment for the textual representation of type 'int' is
                encoding-specific (generally 8 bits)
  -->

  <tdml:parserTestCase name="implicitAlignmentIntT" root="intT"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - int (text) - DFDL-12-019R">

    <tdml:document>
      <tdml:documentPart type="bits">01 101001</tdml:documentPart> <!-- leadingSkip and padding for alignment -->
      <tdml:documentPart type="byte">31 32 33 34</tdml:documentPart> <!-- intT - byte-representation of 1234  -->
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <intT>1234</intT>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentShortT
        Schema: implicitAlignmentSchema
          Root: shortT
       Purpose: This test demonstrates that the implicit alignment for the textual representation of type 'short' is
                encoding-specific (generally 8 bits)
  -->

  <tdml:parserTestCase name="implicitAlignmentShortT" root="shortT"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - short (text) - DFDL-12-020R">

    <tdml:document>
      <tdml:documentPart type="bits">011010 01</tdml:documentPart> <!-- leadingSkip and padding for alignment -->
      <tdml:documentPart type="byte">31 32</tdml:documentPart> <!-- shortT - byte-representation of 12  -->
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <shortT>12</shortT>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentByteT
        Schema: implicitAlignmentSchema
          Root: byteT
       Purpose: This test demonstrates that the implicit alignment for the textual representation of type 'byte' is
                encoding-specific (generally 8 bits)
  -->

  <tdml:parserTestCase name="implicitAlignmentByteT" root="byteT"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - byte (text) - DFDL-12-021R">

    <tdml:document>
      <tdml:documentPart type="bits">01 111111</tdml:documentPart> <!-- leadingSkip and padding for alignment -->
      <tdml:documentPart type="byte">2D 31</tdml:documentPart> <!-- byteT -->
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <byteT>-1</byteT>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>

  <!--
     Test Name: implicitAlignmentByteT2
        Schema: implicitAlignmentSchema
          Root: byteT2
       Purpose: This test demonstrates that the implicit alignment for the textual representation of type 'byte' is
                encoding-specific (generally 8 bits)
  -->

  <tdml:parserTestCase name="implicitAlignmentByteT2" root="byteT2"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - byte (text) - DFDL-12-021R">

    <tdml:document>
      <tdml:documentPart type="bits">10 111111</tdml:documentPart> <!-- leadingSkip and padding for alignment -->
      <tdml:documentPart type="byte">2D 00 31 00</tdml:documentPart> <!-- byteT2 -->
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <byteT2>-1</byteT2>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentUByteT
        Schema: implicitAlignmentSchema
          Root: uByteT
       Purpose: This test demonstrates that the implicit alignment for the textual representation of type 'unsignedByte' is
                encoding-specific (generally 8 bits)
  -->

  <tdml:parserTestCase name="implicitAlignmentUByteT" root="uByteT"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - unsignedByte (text) - DFDL-12-021R">

    <tdml:document>
      <tdml:documentPart type="bits">10 111111</tdml:documentPart> <!-- leadingSkip and padding for alignment -->
      <tdml:documentPart type="byte">2D 31</tdml:documentPart> <!-- uByteT -->
    </tdml:document>

    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>Convert to Unsigned Byte</tdml:error>
      <tdml:error>Out of Range: '-1' converted to -1</tdml:error>
      <tdml:error>not in range for the type</tdml:error>
    </tdml:errors>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentUByteT2
        Schema: implicitAlignmentSchema
          Root: uByteT
       Purpose: This test demonstrates that the implicit alignment for the textual representation of type 'unsignedByte' is
                encoding-specific (generally 8 bits)
  -->

  <tdml:parserTestCase name="implicitAlignmentUByteT2" root="uByteT"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - unsignedByte (text) - DFDL-12-021R">

    <tdml:document>
      <tdml:documentPart type="bits">10 111111</tdml:documentPart> <!-- leadingSkip and padding for alignment -->
      <tdml:documentPart type="byte">31</tdml:documentPart> <!-- uByteT -->
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <uByteT>1</uByteT>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentDateT
        Schema: implicitAlignmentSchema
          Root: dateT
       Purpose: This test demonstrates that the implicit alignment for the textual representation of type 'date' is
                encoding-specific (generally 8 bits)
  -->

  <tdml:parserTestCase name="implicitAlignmentDateT" root="dateT"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - date (text) - DFDL-12-024R">

    <tdml:document>
      <tdml:documentPart type="text">junk!31 03 2013</tdml:documentPart> <!-- leadingSkip (junk!) and dateT -->
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <dateT>2013-03-31+00:00</dateT>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentDateT2
        Schema: implicitAlignmentSchema
          Root: dateT2
       Purpose: This test demonstrates that the implicit alignment for the textual representation of type 'date' is
                encoding-specific (generally 8 bits)
  -->

  <tdml:parserTestCase name="implicitAlignmentDateT2" root="dateT2"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - date (text) - DFDL-12-024R">

    <tdml:document>
      <tdml:documentPart type="text">Bleak Monday in May - 2013</tdml:documentPart> <!-- leadingSkip (Bleak) and dateT -->
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <dateT2>2013-05-06+00:00</dateT2>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentTimeT
        Schema: implicitAlignmentSchema
          Root: timeT
       Purpose: This test demonstrates that the implicit alignment for the textual representation of type 'time' is
                encoding-specific (generally 8 bits)
  -->

  <tdml:parserTestCase name="implicitAlignmentTimeT" root="timeT"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - time (text) - DFDL-12-026R">

    <tdml:document>
      <tdml:documentPart type="text">time: 04:09:23</tdml:documentPart> <!-- leadingSkip (time:) and timeT -->
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <timeT>04:09:23.000000+00:00</timeT>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentDateTimeT
        Schema: implicitAlignmentSchema
          Root: dateTimeT
       Purpose: This test demonstrates that the implicit alignment for the textual representation of type 'dateTime' is
                encoding-specific (generally 8 bits)
  -->

  <tdml:parserTestCase name="implicitAlignmentDateTimeT" root="dateTimeT"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - dateTime (text) - DFDL-12-022R">

    <tdml:document>
      <tdml:documentPart type="text">look: Friday 05 2013 - 03:30:30</tdml:documentPart> <!-- leadingSkip (look:) and dateTimeT -->
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <dateTimeT>2013-05-03T03:30:30.000000+00:00</dateTimeT>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentFloatT
        Schema: implicitAlignmentSchema
          Root: floatT
       Purpose: This test demonstrates that the implicit alignment for the textual representation of type 'float' is
                encoding-specific (generally 8 bits)
  -->

  <tdml:parserTestCase name="implicitAlignmentFloatT" root="floatT"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - float (text) - DFDL-12-015R">

    <tdml:document>
      <tdml:documentPart type="text">3</tdml:documentPart> <!-- leadingSkip and padding for alignment -->
      <tdml:documentPart type="text">42.2</tdml:documentPart> <!-- float -->
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <floatT>42.2</floatT>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentFloatT2
        Schema: implicitAlignmentSchema
          Root: floatT
       Purpose: This test demonstrates that the implicit alignment for the textual representation of type 'float' is encoding-specific (generally 8 bits)
  -->

  <tdml:parserTestCase name="implicitAlignmentFloatT2" root="floatT"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - float (text) - DFDL-12-015R">

    <tdml:document>
      <tdml:documentPart type="bits">10</tdml:documentPart> <!-- leadingSkip -->
      <tdml:documentPart type="bits">101010</tdml:documentPart> <!-- padding to fulfill alignment -->
      <tdml:documentPart type="text">42.3</tdml:documentPart> <!-- floatT -->
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <floatT>42.3</floatT>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>

  <!--
     Test Name: implicitAlignmentFloatT_Fail
        Schema: implicitAlignmentSchema
          Root: floatT
       Purpose: This test demonstrates that the implicit alignment for the textual representation of type 'float' is encoding-specific (generally 8 bits) and will fail with improper alignment.
  -->

  <tdml:parserTestCase name="implicitAlignmentFloatT_Fail" root="floatT"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - float (text) - DFDL-12-015R">

    <tdml:document>
      <tdml:documentPart type="bits">1</tdml:documentPart> <!-- leadingSkip -->
      <tdml:documentPart type="text">42</tdml:documentPart> <!-- floatT -->
    </tdml:document>

    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>Convert to Float (for xs:float)</tdml:error>
      <tdml:error>Unable to parse</tdml:error>
      <tdml:error>(using up all characters).</tdml:error>
    </tdml:errors>

  </tdml:parserTestCase>

  <!--
     Test Name: implicitAlignmentFloat
        Schema: implicitAlignmentSchema
          Root: float
       Purpose: This test demonstrates that the implicit alignment for the binary representation of type 'float' is 32 bits
  -->

  <tdml:parserTestCase name="implicitAlignmentFloat" root="float"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - float (binary) - DFDL-12-015R">

    <tdml:document>
      <tdml:documentPart type="byte">2A 00 90 0D</tdml:documentPart> <!-- leadingSkip and padding for alignment -->
      <tdml:documentPart type="byte">42 28 CC CD</tdml:documentPart> <!-- float -->
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <float>42.2</float>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentFloat2
        Schema: implicitAlignmentSchema
          Root: float
       Purpose: This test demonstrates that the implicit alignment for the binary representation of type 'float' is 32 bits
  -->

  <tdml:parserTestCase name="implicitAlignmentFloat2" root="float"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - float (binary) - DFDL-12-015R">

    <tdml:document>
      <tdml:documentPart type="bits">01010101 01010101</tdml:documentPart> <!-- leadingSkip -->
      <tdml:documentPart type="bits">10101010 10101010</tdml:documentPart> <!-- padding for alignment -->
      <tdml:documentPart type="bits">01000010 00101000 11001100 11001101</tdml:documentPart> <!-- float -->
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <float>42.2</float>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>

  <!--
     Test Name: implicitAlignmentDouble
        Schema: implicitAlignmentSchema
          Root: double
       Purpose: This test demonstrates that the implicit alignment for the binary representation of type 'double' is 64 bits
  -->

  <tdml:parserTestCase name="implicitAlignmentDouble" root="double"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - double (binary) - DFDL-12-016R">

    <tdml:document>
      <tdml:documentPart type="byte">2A 00 90 0D 2A 45 9F 9E</tdml:documentPart> <!-- leadingSkip and padding for alignment -->
      <tdml:documentPart type="byte">42 28 CC CD AB B7 78 09</tdml:documentPart> <!-- double -->
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <double>5.325762300373444E10</double>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>

  <!--
     Test Name: implicitAlignmentDouble2
        Schema: implicitAlignmentSchema
          Root: double2
       Purpose: This test demonstrates that the implicit alignment for the binary representation of type 'double' is 64 bits
  -->

  <tdml:parserTestCase name="implicitAlignmentDouble2" root="double2"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - double (binary) - DFDL-12-016R">

    <tdml:document>
      <tdml:documentPart type="bits">01010101 01010101 01010101 01010101 01010101 01010101 01010101 01010101</tdml:documentPart> <!-- leadingSkip and padding for alignment -->
      <tdml:documentPart type="bits">01000000 00111001 00000000 00000000 00000000 00000000 00000000 00000000</tdml:documentPart> <!-- double2 -->
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <double2>25.0</double2>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentDoubleT
        Schema: implicitAlignmentSchema
          Root: doubleT
       Purpose: This test demonstrates that the implicit alignment for the textual representation of type 'double' is 8 bits
  -->

  <tdml:parserTestCase name="implicitAlignmentDoubleT" root="doubleT"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - double (text) - DFDL-12-016R">

    <tdml:document>
      <tdml:documentPart type="byte">2A</tdml:documentPart> <!-- leadingSkip and padding for alignment -->
      <tdml:documentPart type="byte">35 2E 33 32 35 37 36 32 33 30 30 33 37 33 34 34 34 45 31 30</tdml:documentPart> <!-- double -->
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <doubleT>5.325762300373444E10</doubleT>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentDoubleT2
        Schema: implicitAlignmentSchema
          Root: doubleTBits
       Purpose: This test demonstrates that the implicit alignment for the textual representation of type 'double' is 8 bits
  -->

  <tdml:parserTestCase name="implicitAlignmentDoubleT2" root="doubleTBits"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - double (text) - DFDL-12-016R">

    <tdml:document>
      <tdml:documentPart type="bits">1</tdml:documentPart> <!-- leadingSkip -->
      <tdml:documentPart type="bits">0101010</tdml:documentPart> <!-- padding to fulfill alignment -->
      <tdml:documentPart type="text">42.3</tdml:documentPart> <!-- doubleTBits -->
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <doubleTBits>42.3</doubleTBits>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>

  <!--
     Test Name: implicitAlignmentDoubleT_Fail
        Schema: implicitAlignmentSchema
          Root: doubleTBits
       Purpose: This test demonstrates that the implicit alignment for the textual representation of type 'double' is 8 bits and will fail with improper alignment.
  -->

  <tdml:parserTestCase name="implicitAlignmentDoubleT_Fail" root="doubleTBits"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - double (text) - DFDL-12-016R">

    <tdml:document>
      <tdml:documentPart type="bits">1</tdml:documentPart> <!-- leadingSkip -->
      <tdml:documentPart type="text">42</tdml:documentPart> <!-- doubleTBits -->
    </tdml:document>

    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>Convert to Double (for xs:double)</tdml:error>
      <tdml:error>Unable to parse</tdml:error>
      <tdml:error>(using up all characters).</tdml:error>
    </tdml:errors>

  </tdml:parserTestCase>

  <!--
     Test Name: explicitAlignmentNoSkips01
        Schema: alignmentSchema
          Root: e5
       Purpose: This test demonstrates that the length of the alignment fill region is the smallest non-negative
                integer L such that (L+N) mod B(4) = 1. The position of the first bit of the aligned element is P = L + N   
  -->

  <tdml:parserTestCase name="explicitAlignmentNoSkips01" root="e5"
    model="alignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - alignmentUnits - DFDL-12-010R">

    <tdml:document>
      <tdml:documentPart type="bits">01 00 100101 00 1</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e5>
          <one>1</one>
          <two>37</two>
          <three>1</three>
        </e5>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: explicitAlignmentNoSkips02
        Schema: alignmentSchema
          Root: e6
       Purpose: This test demonstrates that the length of the alignment fill region is the smallest non-negative
                integer L such that (L+N) mod B(4) = 1. The position of the first bit of the aligned element is P = L + N   
  -->

  <tdml:parserTestCase name="explicitAlignmentNoSkips02" root="e6"
    model="alignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - alignmentUnits - DFDL-12-010R">

    <tdml:document>
      <tdml:documentPart type="bits">011 00000 010011000 001 0</tdml:documentPart>
      <!--                           |         |             |                 -->
      <!--                           one       two           three             -->
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e6>
          <one>3</one>
          <two>152</two>
          <three>0</three>
        </e6>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  
  </tdml:parserTestCase>
    
  <!--
     Test Name: explicitAlignmentNoSkips03
        Schema: alignmentSchema
          Root: e7
       Purpose: This test demonstrates that the length of the alignment fill region is the smallest non-negative
                integer L such that (L+N) mod B(4) = 1. The position of the first bit of the aligned element is P = L + N   
  -->

  <tdml:parserTestCase name="explicitAlignmentNoSkips03" root="e7"
    model="alignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - alignmentUnits - DFDL-12-010R">

    <tdml:document>
      <tdml:documentPart type="bits">011100 0001001100 000 10100 000100001111</tdml:documentPart>
      <!--                           |                 |         |                 -->
      <!--                           one               two       three             -->
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e7>
          <one>28</one>
          <two>0</two>
          <three>271</three>
        </e7>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: explicitAlignmentNoSkips04
        Schema: alignmentSchema
          Root: e8
       Purpose: This test demonstrates that the length of the alignment fill region is the smallest non-negative
                integer L such that (L+N) mod B(4) = 1. The position of the first bit of the aligned element is P = L + N   
  -->

  <tdml:parserTestCase name="explicitAlignmentNoSkips04" root="e8"
    model="alignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - alignmentUnits - DFDL-12-010R">

    <tdml:document>
      <tdml:documentPart type="bits">00000001 11111111 00001100 00010100 00000000 00000000</tdml:documentPart>
      <!--                           |                 |        |                                          -->
      <!--                           one               two      three                                      -->
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e8>
          <one>1</one>
          <two>12</two>
          <three>1310720</three>
        </e8>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: explicitAlignmentNoSkips05
        Schema: alignmentSchema
          Root: e9
       Purpose: This test demonstrates that the length of the alignment fill region is the smallest non-negative
                integer L such that (L+N) mod B(4) = 1. The position of the first bit of the aligned element is P = L + N   
  -->

  <tdml:parserTestCase name="explicitAlignmentNoSkips05" root="e9"
    model="alignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - alignmentUnits - DFDL-12-010R">

    <tdml:document>
      <tdml:documentPart type="bits">00000001 00001100 00010100 00000000 10000000 00000000 00000001</tdml:documentPart>
      <!--                           |        |                          |                             -->
      <!--                           one      two                        three                         -->
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e9>
          <one>1</one>
          <two>12</two>
          <three>8388609</three>
        </e9>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: alignmentOptionalElem
        Schema: alignmentSchema
          Root: e10
       Purpose: This test demonstrates that optional elements cannot have alignment properties different from the items
                that follow them, or a SDE will be thrown.
  -->

  <tdml:parserTestCase name="alignmentOptionalElem" root="e10"
    model="alignmentSchema" description="Section 12.1 Aligned Data - Avoid Ambiguity when parsing - DFDL-12-011R">

    <tdml:document>
      <tdml:documentPart type="bits">1 0 101</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
     Test Name: alignmentOptionalElem02
        Schema: alignmentSchema
          Root: e10a
       Purpose: This test demonstrates that optional elements cannot have alignment properties different from the items
                that follow them, or a SDE will be thrown.
  -->

  <tdml:parserTestCase name="alignmentOptionalElem02" root="e10a"
    model="alignmentSchema" description="Section 12.1 Aligned Data - Avoid Ambiguity when parsing - DFDL-12-011R">

    <tdml:document>
      <tdml:documentPart type="bits">0 1 101</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
     Test Name: alignmentOptionalElem03
        Schema: alignmentSchema
          Root: e10b
       Purpose: This test demonstrates that optional elements cannot have alignment properties different from the items
                that follow them, or a SDE will be thrown.
  -->

  <tdml:parserTestCase name="alignmentOptionalElem03" root="e10b"
    model="alignmentSchema" description="Section 12.1 Aligned Data - Avoid Ambiguity when parsing - DFDL-12-011R">

    <tdml:document>
      <tdml:documentPart type="bits">10101011 00100100 11111110 01001001</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
     Test Name: alignmentOptionalElem04
        Schema: alignmentSchema
          Root: e10c
       Purpose: This test demonstrates that optional elements cannot have alignment properties different from the items
                that follow them, or a SDE will be thrown.
  -->

  <tdml:parserTestCase name="alignmentOptionalElem04" root="e10c"
    model="alignmentSchema" description="Section 12.1 Aligned Data - Avoid Ambiguity when parsing - DFDL-12-011R">

    <tdml:document>
      <tdml:documentPart type="bits">01000001 00001000 101</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
     Test Name: alignmentStringErr
        Schema: alignmentSchema
          Root: e11
       Purpose: This test demonstrates that a textual representation of a string has a mandatory alignment (generally 8 bits)
  -->

  <tdml:parserTestCase name="alignmentStringErr" root="e11"
    model="alignmentSchema" description="Section 12.1 Aligned Data - Textual data - Mandatory Alignment - DFDL-12-025R">

    <tdml:document>
      <tdml:documentPart type="text">nope</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>The given alignment (4 bits) must be a multiple of the encoding specified alignment (8 bits) for String</tdml:error>
      <tdml:error>representation='text'</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
     Test Name: alignmentStringBitSkip
        Schema: alignmentSchema
          Root: e12
       Purpose: This test demonstrates that if the data is not aligned to the proper boundary for the encoding from textual 
                data is processed, bits are skipped.
  -->

  <tdml:parserTestCase name="alignmentStringBitSkip" root="e12"
    model="alignmentSchema" description="Section 12.1 Aligned Data - Textual data - Mandatory Alignment - DFDL-12-025R">

    <tdml:document>
      <tdml:documentPart type="bits">101 00000</tdml:documentPart>
      <tdml:documentPart type="text">nope</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e12>
          <bits>10</bits>
          <string>nope</string>
        </e12>
      </tdml:dfdlInfoset>
    </tdml:infoset>
      
  </tdml:parserTestCase>
  
  <!--
     Test Name: leftFraming01
        Schema: alignmentSchema
          Root: e13
       Purpose: This test demonstrates that LeftFraming consists of a LeadingSkip, AlignmentFill, and an Initiator 
  -->

  <tdml:parserTestCase name="leftFraming01" root="e13"
    model="alignmentSchema" description="Section 9 Framing - Aligned Data - DFDL-09-016R">

    <tdml:document>
      <tdml:documentPart type="text">a</tdml:documentPart>
      <tdml:documentPart type="text">:strng</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e13>strng</e13>
      </tdml:dfdlInfoset>
    </tdml:infoset>
      
  </tdml:parserTestCase>
  
  <!--
     Test Name: rightFraming01
        Schema: alignmentSchema
          Root: e14
       Purpose: This test demonstrates that RightFraming consists of a Terminator and TrailingSkip 
  -->

  <tdml:parserTestCase name="rightFraming01" root="e14"
    model="alignmentSchema" description="Section 9 Framing - Aligned Data - DFDL-09-016R">

    <tdml:document>
      <tdml:documentPart type="text">strng:a</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e14>strng</e14>
      </tdml:dfdlInfoset>
    </tdml:infoset>
      
  </tdml:parserTestCase>
  
  <!--
     Test Name: leftAndRightFraming01
        Schema: alignmentSchema
          Root: e15
       Purpose: This test demonstrates Right and Left Framing 
  -->

  <tdml:parserTestCase name="leftAndRightFraming01" root="e15"
    model="alignmentSchema" description="Section 9 Framing - Aligned Data - DFDL-09-016R">

    <tdml:document>
      <tdml:documentPart type="text">a:strnggnrts:a</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e15>
          <e13>strng</e13>
          <e14>gnrts</e14>
        </e15>
      </tdml:dfdlInfoset>
    </tdml:infoset>
      
  </tdml:parserTestCase>
  
  <!--
     Test Name: leftAndRightFraming02
        Schema: alignmentSchema
          Root: e16
       Purpose: This test demonstrates Right and Left Framing 
  -->

  <tdml:parserTestCase name="leftAndRightFraming02" root="e16"
    model="alignmentSchema" description="Section 9 Framing - Aligned Data - DFDL-09-016R">

    <tdml:document>
      <tdml:documentPart type="text">gnrts:aa:strng</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e16>
          <e14>gnrts</e14>
          <e13>strng</e13>
        </e16>
      </tdml:dfdlInfoset>
    </tdml:infoset>
      
  </tdml:parserTestCase>
  
  <!--
     Test Name: leftAndRightFramingNested01
        Schema: alignmentSchema
          Root: e17
       Purpose: This test demonstrates Right and Left Framing on a complex element 
  -->

  <tdml:parserTestCase name="leftAndRightFramingNested01" root="e17"
    model="alignmentSchema" description="Section 9 Framing - Aligned Data - DFDL-09-016R">

    <tdml:document>
      <tdml:documentPart type="text">skip</tdml:documentPart> <!-- 2 byte (2 char) leadingSkip and 2 byte (2 char) padding to fulfill alignment -->
      <tdml:documentPart type="text">gnrts:aa:strng</tdml:documentPart>
      <tdml:documentPart type="text">eh</tdml:documentPart> <!-- 2 byte (2 char) trailingSkip -->
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e17>
          <e14>gnrts</e14>
          <e13>strng</e13>
        </e17>
      </tdml:dfdlInfoset>
    </tdml:infoset>
      
  </tdml:parserTestCase>
  
  <!--
     Test Name: leftAndRightFramingNested02
        Schema: alignmentSchema
          Root: e18
       Purpose: This test demonstrates Right and Left Framing on a nested complex element 
  -->

  <tdml:parserTestCase name="leftAndRightFramingNested02" root="e18"
    model="alignmentSchema" description="Section 9 Framing - Aligned Data - DFDL-09-016R">

    <tdml:document>
      <tdml:documentPart type="text">skip</tdml:documentPart> <!-- e18 - 2 byte leadingSkip and 2 byte padding to fulfill alignment -->
      <!--                           1234               -->
      <tdml:documentPart type="text">skip</tdml:documentPart> <!-- a - 2 byte leadingSkip and 2 byte padding to fulfill alignment -->
      <!--                           5678               -->
      <tdml:documentPart type="text">gnrts:a</tdml:documentPart> <!-- a1 and trailingSkip of 8 bits -->
      <!--                           |     |            -->
      <!--                           9     15           -->
      <tdml:documentPart type="text">a:strng</tdml:documentPart> <!-- a2 - leadingSkip of 4 bits and 4 more bits to fulfill alignment -->
      <!--                           |     |            -->
      <!--                          16     22           -->
      <tdml:documentPart type="text">XX</tdml:documentPart> <!-- 2 byte trailingSkip for a -->
      <!--                            |                 -->
      <!--                            24                -->
      <tdml:documentPart type="text">,</tdml:documentPart> <!-- sequence separator -->
      <!--                           |                  -->
      <!--                          25                  -->
      <tdml:documentPart type="text">LLP</tdml:documentPart> <!-- b - 2 byte leadingSkip and 1 byte padding to fulfill alignment (elem starts on byte 29) -->
      <!--                           | |                -->
      <!--                          26 28               -->
      <tdml:documentPart type="text">gnrtsTTTTTTTT</tdml:documentPart> <!-- b1 - 'gnrts', trailingSkip of 8 bytes -->
      <!--                           |           |      -->
      <!--                          29           41     -->
      <tdml:documentPart type="text">Lstrng</tdml:documentPart> <!-- b2 - leadingSkip of 1 byte and 2 bytes to fulfill alignment, 'strng' starts on 43-->
      <!--                           |                  -->
      <!--                          42                  -->
      <tdml:documentPart type="text">TT</tdml:documentPart> <!-- 2 byte trailingSkip for b -->
      <tdml:documentPart type="text">TT</tdml:documentPart> <!-- 2 byte trailingSkip for e18 -->
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e18>
          <a>
            <a1>gnrts</a1>
            <a2>strng</a2>
          </a>
          <b>
            <b1>gnrts</b1>
            <b2>strng</b2>
          </b>
        </e18>
      </tdml:dfdlInfoset>
    </tdml:infoset>
      
  </tdml:parserTestCase>
  
  <!--
     Test Name: leftAndRightFramingNested03
        Schema: alignmentSchema
          Root: e19
       Purpose: This test demonstrates Right and Left Framing on a complex element 
  -->

  <tdml:parserTestCase name="leftAndRightFramingNested03" root="e19"
    model="alignmentSchema" description="Section 9 Framing - Aligned Data - DFDL-09-016R">

    <tdml:document>
      <tdml:documentPart type="text">skip</tdml:documentPart> <!-- 2 byte (2 char) leadingSkip and 2 byte (2 char) padding to fulfill alignment -->
      <tdml:documentPart type="text">gnrts:a,a:strng</tdml:documentPart>
      <tdml:documentPart type="text">eh</tdml:documentPart> <!-- 2 byte (2 char) trailingSkip -->
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e19>
          <e14>gnrts</e14>
          <e13>strng</e13>
        </e19>
      </tdml:dfdlInfoset>
    </tdml:infoset>
      
  </tdml:parserTestCase>
  
  <!--
     Test Name: leftAndRightFramingNested04
        Schema: alignmentSchema
          Root: e20
       Purpose: This test demonstrates Right and Left Framing on a complex element 
  -->

  <tdml:parserTestCase name="leftAndRightFramingNested04" root="e20"
    model="alignmentSchema" description="Section 9 Framing - Aligned Data - DFDL-09-016R">

    <tdml:document>
      <tdml:documentPart type="text">skip</tdml:documentPart> <!-- 2 byte (2 char) leadingSkip and 2 byte padding to fulfill alignment -->
      <!--                           1234                 -->
      <tdml:documentPart type="text">^</tdml:documentPart> <!-- initiator -->
      <!--                           5                    -->
      <tdml:documentPart type="text">ski</tdml:documentPart> <!-- 2 byte (2 char) leadingSkip and 1 byte padding to fulfill alignment (4 byte aligned) -->
      <!--                           678                 -->
      <!--                             ^                 -->
      <tdml:documentPart type="text">gnrts:a,a:strng</tdml:documentPart>
      <tdml:documentPart type="text">eh</tdml:documentPart> <!-- 2 byte (2 char) trailingSkip -->
      <tdml:documentPart type="text">eh</tdml:documentPart> <!-- 2 byte (2 char) trailingSkip -->
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e20>
          <a>
            <a1>gnrts</a1>
            <a2>strng</a2>
          </a>
        </e20>
      </tdml:dfdlInfoset>
    </tdml:infoset>
      
  </tdml:parserTestCase>
  
  <!--
     Test Name: leftAndRightFramingNested05
        Schema: alignmentSchema
          Root: e21
       Purpose: This test demonstrates Right and Left Framing on a complex element 
  -->

  <tdml:parserTestCase name="leftAndRightFramingNested05" root="e21"
    model="alignmentSchema" description="Section 9 Framing - Aligned Data - DFDL-09-016R">

    <tdml:document>
      <tdml:documentPart type="text">skip</tdml:documentPart> <!-- 2 byte (2 char) leadingSkip and 2 byte (2 char) padding to fulfill alignment -->
      <tdml:documentPart type="text">skip</tdml:documentPart> <!-- 2 byte (2 char) leadingSkip and 2 byte (2 char) padding to fulfill alignment -->
      <tdml:documentPart type="text">gnrts:a,a:strng</tdml:documentPart>
      <tdml:documentPart type="text">eh</tdml:documentPart> <!-- 2 byte (2 char) trailingSkip -->
      <tdml:documentPart type="text">eh</tdml:documentPart> <!-- 2 byte (2 char) trailingSkip -->
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e21>
          <a>
            <a1>gnrts</a1>
            <a2>strng</a2>
          </a>
        </e21>
      </tdml:dfdlInfoset>
    </tdml:infoset>
      
  </tdml:parserTestCase>
  
  <!--
     Test Name: encodingAlignmentUtf32be
        Schema: alignmentSchema
          Root: string32be
       Purpose: This test demonstrates that the alignment for Utf-32be encoded text must be 8-bit aligned
  -->

  <tdml:parserTestCase name="encodingAlignmentUtf32be" root="string32be"
    model="alignmentSchema" description="Section 12 - Aligned Data - DFDL-12-027R">

    <tdml:document>
      <tdml:documentPart type="byte">00 00 00 74 00 00 00 65 00 00 00 73 00 00 00 74</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>The given alignment (2 bits) must be a multiple of the encoding specified alignment (8 bits) for String when representation='text'</tdml:error>
      <tdml:error>Encoding: UTF-32BE</tdml:error>
    </tdml:errors> 
  </tdml:parserTestCase>
  
  <!--
     Test Name: alignmentUnitsInvalid
        Schema: InvalidAlignSchema.dfdl.xsd
          Root: e_invalid
       Purpose: This test demonstrates that DFDL properly handles a case where alignmentUnits is invalid
  -->

  <tdml:parserTestCase name="alignmentUnitsInvalid" root="e_invalid"
    model="InvalidAlignSchema.dfdl.xsd" description="Section 12 - Aligned Data - alignmentUnits - DFDL-12-003R">

    <tdml:document>
      <tdml:documentPart type="byte">12345</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Value 'characters' is not facet-valid with respect to enumeration '[bits, bytes]'</tdml:error>
      <tdml:error>It must be a value from the enumeration</tdml:error>
    </tdml:errors> 
  </tdml:parserTestCase>
  
  <!--
     Test Name: impAlignmentNonNegativeInteger
        Schema: implicitAlignmentSchema
          Root: nonNeg
          Purpose: This test demonstrates that the implicit alignment for nonNegativeIntegers is 8 bits
  -->
  
  <tdml:parserTestCase name="impAlignmentNonNegativeInteger" root="nonNeg"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - nonNegativeInteger - DFDL-12-017R">

    <tdml:document>
      <tdml:documentPart type="bits">01110101 11010010</tdml:documentPart> <!-- leadingSkip -->
      <tdml:documentPart type="bits">00000000 00000000 00000000 00000010 00000001</tdml:documentPart> <!-- nonNeg -->
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <nonNeg>513</nonNeg>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: impAlignmentNonNegativeInteger2
        Schema: implicitAlignmentSchema
          Root: nonNeg
          Purpose: This test demonstrates that the implicit alignment for nonNegativeIntegers is 1 byte
  -->
  
  <tdml:parserTestCase name="impAlignmentNonNegativeInteger2" root="nonNeg"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - nonNegativeInteger - DFDL-12-017R">

    <tdml:document>
      <tdml:documentPart type="byte">01 01</tdml:documentPart> <!-- leadingSkip -->
      <tdml:documentPart type="byte">00 00 00 02 01</tdml:documentPart> <!-- nonNeg -->
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <nonNeg>513</nonNeg>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: impAlignmentNonNegativeInteger3
        Schema: implicitAlignmentSchema
          Root: nonNeg2
          Purpose: This test demonstrates that the implicit alignment for nonNegativeIntegers is 8 bits
  -->
  
  <tdml:parserTestCase name="impAlignmentNonNegativeInteger3" root="nonNeg2"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - nonNegativeInteger - DFDL-12-017R">

    <tdml:document>
      <tdml:documentPart type="bits">1</tdml:documentPart> <!-- leadingSkip -->
      <tdml:documentPart type="bits">1001010</tdml:documentPart> <!-- padding to fulfill alignment -->
      <tdml:documentPart type="bits">00000000 10001001</tdml:documentPart> <!-- nonNeg -->
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <nonNeg2>137</nonNeg2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: impAlignmentInteger1
        Schema: implicitAlignmentSchema
          Root: integer2
          Purpose: This test demonstrates that the implicit alignment for integer is 8 bits
  -->
  
  <tdml:parserTestCase name="impAlignmentInteger1" root="integer2"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - integer - DFDL-12-017R">

    <tdml:document>
      <tdml:documentPart type="bits">1</tdml:documentPart> <!-- leadingSkip -->
      <tdml:documentPart type="bits">1001010</tdml:documentPart> <!-- padding to fulfill alignment -->
      <tdml:documentPart type="bits">00000000 10001001</tdml:documentPart> <!-- nonNeg -->
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <integer2>137</integer2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: impAlignmentInteger2
        Schema: implicitAlignmentSchema
          Root: integer
          Purpose: This test demonstrates that the implicit alignment for integer is 8 bits
  -->
  
  <tdml:parserTestCase name="impAlignmentInteger2" root="integer"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - integer - DFDL-12-017R">
    
    <tdml:document>
      <tdml:documentPart type="byte">01 01</tdml:documentPart> <!-- leadingSkip -->
      <tdml:documentPart type="byte">00 00 00 02 01</tdml:documentPart> <!-- nonNeg -->
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <integer>513</integer>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: impAlignmentInteger3
        Schema: implicitAlignmentSchema
          Root: integer
          Purpose: This test demonstrates that the implicit alignment for integer is 8 bits
  -->
  
  <tdml:parserTestCase name="impAlignmentInteger3" root="integer"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - integer - DFDL-12-017R">
    
    <tdml:document>
      <tdml:documentPart type="byte">01 01</tdml:documentPart> <!-- leadingSkip -->
      <tdml:documentPart type="byte">ff ff ff fd ff</tdml:documentPart> <!-- nonNeg -->
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <integer>-513</integer>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: implicitAlignmentNonNegativeIntegerT
        Schema: implicitAlignmentSchema
          Root: nonNegativeIntegerT
       Purpose: This test demonstrates that the implicit alignment for the textual representation of type 'nonNegativeInteger' is encoding-specific (generally 8 bits)
  -->

  <tdml:parserTestCase name="implicitAlignmentNonNegativeIntegerT" root="nonNegativeIntegerT"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - nonNegativeInteger (text) - DFDL-12-017R">

    <tdml:document>
      <tdml:documentPart type="text">3</tdml:documentPart> <!-- leadingSkip -->
      <tdml:documentPart type="text">42</tdml:documentPart> <!-- nonNegativeIntegerT -->
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <nonNegativeIntegerT>42</nonNegativeIntegerT>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>

  <!--
     Test Name: implicitAlignmentNonNegativeIntegerT2
        Schema: implicitAlignmentSchema
          Root: nonNegativeIntegerT
       Purpose: This test demonstrates that the implicit alignment for the textual representation of type 'nonNegativeInteger' is encoding-specific (generally 8 bits)
  -->

  <tdml:parserTestCase name="implicitAlignmentNonNegativeIntegerT2" root="nonNegativeIntegerT"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - nonNegativeInteger (text) - DFDL-12-017R">

    <tdml:document>
      <tdml:documentPart type="bits">10101010</tdml:documentPart> <!-- leadingSkip -->
      <tdml:documentPart type="text">42</tdml:documentPart> <!-- nonNegativeIntegerT -->
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <nonNegativeIntegerT>42</nonNegativeIntegerT>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>

  <!--
     Test Name: implicitAlignmentNonNegativeIntegerT3
        Schema: implicitAlignmentSchema
          Root: nonNegativeIntegerTBits
       Purpose: This test demonstrates that the implicit alignment for the textual representation of type 'nonNegativeInteger' is encoding-specific (generally 8 bits)
  -->

  <tdml:parserTestCase name="implicitAlignmentNonNegativeIntegerT3" root="nonNegativeIntegerTBits"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - nonNegativeInteger (text) - DFDL-12-017R">

    <tdml:document>
      <tdml:documentPart type="bits">1</tdml:documentPart> <!-- leadingSkip -->
      <tdml:documentPart type="bits">0101010</tdml:documentPart> <!-- padding to fulfill alignment -->
      <tdml:documentPart type="text">42</tdml:documentPart> <!-- nonNegativeIntegerTBits -->
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <nonNegativeIntegerTBits>42</nonNegativeIntegerTBits>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>

  <!--
     Test Name: implicitAlignmentNonNegativeIntegerT_Fail
        Schema: implicitAlignmentSchema
          Root: nonNegativeIntegerT
       Purpose: This test demonstrates that the implicit alignment for the textual representation of type 'nonNegativeInteger' is encoding-specific (generally 8 bits) and will fail with improper alignment.
  -->

  <tdml:parserTestCase name="implicitAlignmentNonNegativeIntegerT_Fail" root="nonNegativeIntegerT"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - nonNegativeInteger (text) - DFDL-12-017R">

    <tdml:document>
      <tdml:documentPart type="bits">1</tdml:documentPart> <!-- leadingSkip -->
      <tdml:documentPart type="text">42</tdml:documentPart> <!-- nonNegativeIntegerT -->
    </tdml:document>

    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>Convert to Unlimited Size Non Negative Integer (for xs:nonNegativeInteger)</tdml:error>
      <tdml:error>Unable to parse</tdml:error>
      <tdml:error>(using up all characters).</tdml:error>
    </tdml:errors>

  </tdml:parserTestCase>

  <!--
     Test Name: implicitAlignmentIntegerT
        Schema: implicitAlignmentSchema
          Root: integerT
       Purpose: This test demonstrates that the implicit alignment for the textual representation of type 'integer' is encoding-specific (generally 8 bits)
  -->

  <tdml:parserTestCase name="implicitAlignmentIntegerT" root="integerT"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - integer (text) - DFDL-12-017R">

    <tdml:document>
      <tdml:documentPart type="text">3</tdml:documentPart> <!-- leadingSkip -->
      <tdml:documentPart type="text">42</tdml:documentPart> <!-- integerT -->
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <integerT>42</integerT>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>

  <!--
     Test Name: implicitAlignmentIntegerT2
        Schema: implicitAlignmentSchema
          Root: integerTBits
       Purpose: This test demonstrates that the implicit alignment for the textual representation of type 'integer' is encoding-specific (generally 8 bits)
  -->

  <tdml:parserTestCase name="implicitAlignmentIntegerT2" root="integerTBits"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - integer (text) - DFDL-12-017R">

    <tdml:document>
      <tdml:documentPart type="bits">1</tdml:documentPart> <!-- leadingSkip -->
      <tdml:documentPart type="bits">0101010</tdml:documentPart> <!-- padding to fulfill alignment -->
      <tdml:documentPart type="text">42</tdml:documentPart> <!-- integerTBits -->
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <integerTBits>42</integerTBits>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>

  <!--
     Test Name: implicitAlignmentIntegerT_Fail
        Schema: implicitAlignmentSchema
          Root: integerT
       Purpose: This test demonstrates that the implicit alignment for the textual representation of type 'integer' is encoding-specific (generally 8 bits) and will fail with improper alignment.
  -->

  <tdml:parserTestCase name="implicitAlignmentIntegerT_Fail" root="integerT"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - integer (text) - DFDL-12-017R">

    <tdml:document>
      <tdml:documentPart type="bits">1</tdml:documentPart> <!-- leadingSkip -->
      <tdml:documentPart type="text">42</tdml:documentPart> <!-- integerT -->
    </tdml:document>

    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>Convert to Unlimited Size Integer (for xs:integer)</tdml:error>
      <tdml:error>Unable to parse</tdml:error>
      <tdml:error>(using up all characters).</tdml:error>
    </tdml:errors>

  </tdml:parserTestCase>

  <!--
     Test Name: implicitAlignmentDecimalT
        Schema: implicitAlignmentSchema
          Root: decimalT
       Purpose: This test demonstrates that the implicit alignment for the textual representation of type 'decimal' is encoding-specific (generally 8 bits)
  -->

  <tdml:parserTestCase name="implicitAlignmentDecimalT" root="decimalT"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - decimal (text) - DFDL-12-017R">

    <tdml:document>
      <tdml:documentPart type="text">3</tdml:documentPart> <!-- leadingSkip -->
      <tdml:documentPart type="text">42.3</tdml:documentPart> <!-- decimalT -->
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <decimalT>42.3</decimalT>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>

  <!--
     Test Name: implicitAlignmentDecimalT2
        Schema: implicitAlignmentSchema
          Root: decimalTBits
       Purpose: This test demonstrates that the implicit alignment for the textual representation of type 'decimal' is encoding-specific (generally 8 bits)
  -->

  <tdml:parserTestCase name="implicitAlignmentDecimalT2" root="decimalTBits"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - decimal (text) - DFDL-12-017R">

    <tdml:document>
      <tdml:documentPart type="bits">1</tdml:documentPart> <!-- leadingSkip -->
      <tdml:documentPart type="bits">0101010</tdml:documentPart> <!-- padding to fulfill alignment -->
      <tdml:documentPart type="text">42.3</tdml:documentPart> <!-- decimalTBits -->
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <decimalTBits>42.3</decimalTBits>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>

  <!--
     Test Name: implicitAlignmentDecimalT_Fail
        Schema: implicitAlignmentSchema
          Root: decimalT
       Purpose: This test demonstrates that the implicit alignment for the textual representation of type 'decimal' is encoding-specific (generally 8 bits) and will fail with improper alignment.
  -->

  <tdml:parserTestCase name="implicitAlignmentDecimalT_Fail" root="decimalT"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - decimal (text) - DFDL-12-017R">

    <tdml:document>
      <tdml:documentPart type="bits">1</tdml:documentPart> <!-- leadingSkip -->
      <tdml:documentPart type="text">42</tdml:documentPart> <!-- decimalT -->
    </tdml:document>

    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>Convert to Unlimited Size Decimal (for xs:decimal)</tdml:error>
      <tdml:error>Unable to parse</tdml:error>
      <tdml:error>(using up all characters).</tdml:error>
    </tdml:errors>

  </tdml:parserTestCase>

  <!--
     Test Name: implicitAlignmentDecimal
        Schema: implicitAlignmentSchema
          Root: decimal
       Purpose: This test demonstrates that the implicit alignment for the binary representation of type 'decimal' is 8 bits
  -->

  <tdml:parserTestCase name="implicitAlignmentDecimal" root="decimal"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - decimal  - DFDL-12-017R">

    <tdml:document>
      <tdml:documentPart type="byte">09 01</tdml:documentPart> <!-- leadingSkip -->
      <tdml:documentPart type="byte">02 DF DC 1C 35</tdml:documentPart> <!-- decimal -->
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <decimal>1234567890.1</decimal>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>

  <!--
     Test Name: implicitAlignmentDecimal2
        Schema: implicitAlignmentSchema
          Root: decimal2
       Purpose: This test demonstrates that the implicit alignment for the binary representation of type 'decimal' is 8 bits
  -->

  <tdml:parserTestCase name="implicitAlignmentDecimal2" root="decimal2"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - decimal  - DFDL-12-017R">

    <tdml:document>
      <tdml:documentPart type="bits">1</tdml:documentPart> <!-- leadingSkip -->
      <tdml:documentPart type="bits">1001010</tdml:documentPart> <!-- padding to fulfill alignment -->
      <tdml:documentPart type="bits">00000000 10001001</tdml:documentPart> <!-- decimal2 -->
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <decimal2>13.7</decimal2>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: leftAndRightFramingChoice01
        Schema: alignmentSchema
          Root: e22
       Purpose: This test demonstrates Right and Left Framing on a complex element (choice)
  -->

  <tdml:parserTestCase name="leftAndRightFramingChoice01" root="e22"
    model="alignmentSchema" description="Section 9 Framing - Aligned Data - DFDL-09-016R">

    <tdml:document>
      <tdml:documentPart type="byte">BA 19 00 00</tdml:documentPart> <!-- e22 leadingSkip and padding to fulfill alignment-->
      <tdml:documentPart type="byte">11 11 22 22</tdml:documentPart> <!-- a1 leadingSkip and padding to fulfill alignment-->
      <tdml:documentPart type="byte">73 74 72 6E 67 3A</tdml:documentPart> <!-- a1 "strng:" -->
      <tdml:documentPart type="byte">11 11</tdml:documentPart> <!-- a1 trailingSkip -->
      <tdml:documentPart type="byte">11 11</tdml:documentPart> <!-- e22 trailingSkip -->
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e22>
          <a1>strng</a1>
        </e22>
      </tdml:dfdlInfoset>
    </tdml:infoset>
      
  </tdml:parserTestCase>

  <!--
     Test Name: leftAndRightFramingChoice02
        Schema: alignmentSchema
          Root: e22
       Purpose: This test demonstrates Right and Left Framing on a complex element (choice)
  -->

  <tdml:parserTestCase name="leftAndRightFramingChoice02" root="e22"
    model="alignmentSchema" description="Section 9 Framing - Aligned Data - DFDL-09-016R">

    <tdml:document>
      <tdml:documentPart type="byte">BA 19 00 00</tdml:documentPart> <!-- e22 leadingSkip and padding to fulfill alignment-->
      <tdml:documentPart type="byte">11 11 22 22</tdml:documentPart> <!-- a2 leadingSkip and padding to fulfill alignment-->
      <tdml:documentPart type="byte">3A 73 74 72 6E 67</tdml:documentPart> <!-- a2 ":strng" -->
      <tdml:documentPart type="byte">11 11</tdml:documentPart> <!-- e22 trailingSkip -->
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e22>
          <a2>strng</a2>
        </e22>
      </tdml:dfdlInfoset>
    </tdml:infoset>
      
  </tdml:parserTestCase>
  
  <!--
     Test Name: leftAndRightFramingChoice03
        Schema: alignmentSchema
          Root: e23
       Purpose: This test demonstrates Right and Left Framing on a complex element (choice)
  -->

  <tdml:parserTestCase name="leftAndRightFramingChoice03" root="e23"
    model="alignmentSchema" description="Section 9 Framing - Aligned Data - DFDL-09-016R">

    <tdml:document>
      <tdml:documentPart type="byte">BA 19 00 00</tdml:documentPart> <!-- e23 leadingSkip and padding to fulfill alignment-->
      <tdml:documentPart type="byte">11 11 22 22</tdml:documentPart> <!-- a2 leadingSkip and padding to fulfill alignment-->
      <tdml:documentPart type="byte">73 74 72 6E 67 3A</tdml:documentPart> <!-- a2 "strng" -->
      <tdml:documentPart type="byte">11 11 22 22 19 20 21 22 23 24</tdml:documentPart> <!-- a2 leadingSkip and padding to fulfill alignment-->
      <!--                           15       18                24     -->
      <tdml:documentPart type="byte">73 74 72 6E 67 3A</tdml:documentPart> <!-- a2 "strng:" -->
      <tdml:documentPart type="byte">11 11 22 24 35 36 37 38 39 40</tdml:documentPart> <!-- a2 leadingSkip and padding to fulfill alignment-->
      <!--                           31 32    34                40     -->
      <tdml:documentPart type="byte">73 74 72 6E 67 3A</tdml:documentPart> <!-- a2 "strng:" -->
      <tdml:documentPart type="byte">11 11</tdml:documentPart> <!-- e23 trailingSkip -->
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e23>
          <e23a>
            <a2>strng</a2>
          </e23a>
          <e23a>
            <a2>strng</a2>
          </e23a>
          <e23a>
            <a2>strng</a2>
          </e23a>
        </e23>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: leftAndRightFramingChoice04
        Schema: alignmentSchema
          Root: e23
       Purpose: This test demonstrates Right and Left Framing on a complex element (choice)
  -->

  <tdml:parserTestCase name="leftAndRightFramingChoice04" root="e23"
    model="alignmentSchema" description="Section 9 Framing - Aligned Data - DFDL-09-016R">

    <tdml:document>
      <tdml:documentPart type="byte">BA 19 00 00</tdml:documentPart> <!-- e23 leadingSkip and padding to fulfill alignment-->
      <tdml:documentPart type="byte">11 11 22 22</tdml:documentPart> <!-- a2 leadingSkip and padding to fulfill alignment-->
      <tdml:documentPart type="byte">73 74 72 6E 67 3A</tdml:documentPart> <!-- a2 "strng:" -->
      <tdml:documentPart type="byte">11 11 22 22 19 20</tdml:documentPart> <!-- a2 leadingSkip and padding to fulfill alignment-->
      <!--                           15       18    20                              -->
      <tdml:documentPart type="byte">3A 73 74 72 6E 67</tdml:documentPart> <!-- a1 ":strng" -->
      <tdml:documentPart type="byte">11 11 22 24 35 36</tdml:documentPart> <!-- a2 leadingSkip and padding to fulfill alignment-->
      <!--                           27             32                             -->
      <tdml:documentPart type="byte">73 74 72 6E 67 3A</tdml:documentPart> <!-- a2 "strng:" -->
      <tdml:documentPart type="byte">11 11</tdml:documentPart> <!-- e23 trailingSkip -->
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e23>
          <e23a>
            <a2>strng</a2>
          </e23a>
          <e23a>
            <a1>strng</a1>
          </e23a>
          <e23a>
            <a2>strng</a2>
          </e23a>
        </e23>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: leftAndRightFramingChoice05
        Schema: alignmentSchema
          Root: e24
       Purpose: This test demonstrates Right and Left Framing on a complex element (choice)
  -->

  <tdml:parserTestCase name="leftAndRightFramingChoice05" root="e24"
    model="alignmentSchema" description="Section 9 Framing - Aligned Data - DFDL-09-016R">

    <tdml:document>
      <tdml:documentPart type="byte">BA 19 00 00</tdml:documentPart>                       <!-- e24 leadingSkip (2B) and padding to fulfill alignment -->
      <tdml:documentPart type="byte">BA 19 00 00</tdml:documentPart>                       <!-- a2 leadingSkip (4B) - no padding needed -->
      <tdml:documentPart type="byte">74 65 72 6D 69 6E 61 74 65 64 3A</tdml:documentPart>  <!-- a2 "terminated:" -->
      <tdml:documentPart type="byte">11 11 11 11 22</tdml:documentPart>                    <!-- a1 leadingSkip (4B) and padding to fulfill alignment of 4B-->
      <!--                                    23 24                 -->
      <tdml:documentPart type="byte">3A 69 6E 69 74 73</tdml:documentPart>                 <!-- a1 ":inits" -->
      <tdml:documentPart type="byte">73 73</tdml:documentPart>                             <!-- a1 trailingSkip (2B) -->
      <tdml:documentPart type="byte">11 11 11 11 00 00 00 00</tdml:documentPart>           <!-- b1 leadingSkip (4B) and padding to fulfill alignment of 8B -->
      <!--                                    36          40                 -->
      <tdml:documentPart type="byte">33 32</tdml:documentPart>                             <!-- b1 "32" -->
      <tdml:documentPart type="byte">11 11 11 11 00 00</tdml:documentPart>                 <!-- b2 leadingSkip (4B) and padding to fulfill alignment of 4B -->
      <!--                                    46    48                 -->
      <tdml:documentPart type="byte">2D 33 30</tdml:documentPart>                          <!-- b2 "-30" -->
      <tdml:documentPart type="byte">73 73</tdml:documentPart>                             <!-- b2 trailingSkip (2B) -->
      <tdml:documentPart type="byte">73 73</tdml:documentPart>                             <!-- e24 trailingSkip (2B) -->

    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e24>
          <e24a>
            <a2>terminated</a2>
          </e24a>
          <e24a>
            <a1>inits</a1>
          </e24a>
          <e24b>
            <b1>32</b1>
          </e24b>
          <e24b>
            <b2>-30</b2>
          </e24b>
        </e24>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: leftAndRightFramingChoice06
        Schema: alignmentSchema
          Root: e24
       Purpose: This test demonstrates Right and Left Framing on a complex element (choice)
  -->

  <tdml:parserTestCase name="leftAndRightFramingChoice06" root="e24"
    model="alignmentSchema" description="Section 9 Framing - Aligned Data - DFDL-09-016R">

    <tdml:document>
      <tdml:documentPart type="byte">BA 19 00 00</tdml:documentPart>                       <!-- e24 leadingSkip (2B) and padding to fulfill alignment -->
      <tdml:documentPart type="byte">11 11 11 11</tdml:documentPart>                       <!-- a1 leadingSkip (4B) - no padding needed -->
      <!--                                    08                 -->
      <tdml:documentPart type="byte">3A 69 6E 69 74 73</tdml:documentPart>                 <!-- a1 ":inits" -->
      <tdml:documentPart type="byte">73 73</tdml:documentPart>                             <!-- a1 trailingSkip (2B) -->
      <tdml:documentPart type="byte">BA 19 00 00 11 11 11 11</tdml:documentPart>           <!-- a2 leadingSkip (4B) and padding to fulfill alignment of 8B -->
      <!--                                    20          24                 -->
      <tdml:documentPart type="byte">74 65 72 6D 69 6E 61 74 65 64 3A</tdml:documentPart>  <!-- a2 "terminated:" -->
      <tdml:documentPart type="byte">BA 19 00 00 11</tdml:documentPart>                    <!-- a2 leadingSkip (4B) and padding to fulfill alignment of 8B -->
      <!--                                    39 40                 -->
      <tdml:documentPart type="byte">74 65 72 6D 69 6E 61 74 65 64 3A</tdml:documentPart>  <!-- a2 "terminated:" -->
      <tdml:documentPart type="byte">BA 19 00 00 11</tdml:documentPart>                    <!-- a2 leadingSkip (4B) and padding to fulfill alignment of 8B -->
      <!--                                    55 56                 -->
      <tdml:documentPart type="byte">74 65 72 6D 69 6E 61 74 65 64 3A</tdml:documentPart>  <!-- a2 "terminated:" -->
      <tdml:documentPart type="byte">11 11 11 11 00</tdml:documentPart>                    <!-- b1 leadingSkip (4B) and padding to fulfill alignment of 8B -->
      <!--                                    71 72                 -->
      <tdml:documentPart type="byte">33 32</tdml:documentPart>                             <!-- b1 "32" -->
      <tdml:documentPart type="byte">11 11 11 11 00 00</tdml:documentPart>                 <!-- b2 leadingSkip (4B) and padding to fulfill alignment of 4B -->
      <!--                                    78    80                 -->
      <tdml:documentPart type="byte">2D 33 30</tdml:documentPart>                          <!-- b2 "-30" -->
      <tdml:documentPart type="byte">73 73</tdml:documentPart>                             <!-- b2 trailingSkip (2B) -->
      <tdml:documentPart type="byte">73 73</tdml:documentPart>                             <!-- e24 trailingSkip (2B) -->

    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e24>
          <e24a>
            <a1>inits</a1>
          </e24a>
          <e24a>
            <a2>terminated</a2>
          </e24a>
          <e24a>
            <a2>terminated</a2>
          </e24a>
          <e24a>
            <a2>terminated</a2>
          </e24a>
          <e24b>
            <b1>32</b1>
          </e24b>
          <e24b>
            <b2>-30</b2>
          </e24b>
        </e24>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: leftAndRightFramingChoice07
        Schema: alignmentSchema
          Root: e24
       Purpose: This test demonstrates Right and Left Framing on a complex element (choice)
  -->

  <tdml:parserTestCase name="leftAndRightFramingChoice07" root="e24"
    model="alignmentSchema" description="Section 9 Framing - Aligned Data - DFDL-09-016R">

    <tdml:document>
      <tdml:documentPart type="byte">BA 19 00 00</tdml:documentPart>                       <!-- e24 leadingSkip (2B) and padding to fulfill alignment -->
      <tdml:documentPart type="byte">11 11 11 11</tdml:documentPart>                       <!-- a1 leadingSkip (4B) - no padding needed -->
      <!--                                    08                 -->
      <tdml:documentPart type="byte">3A 69 6E 69 74 73</tdml:documentPart>                 <!-- a1 ":inits" -->
      <tdml:documentPart type="byte">73 73</tdml:documentPart>                             <!-- a1 trailingSkip (2B) -->
      <tdml:documentPart type="byte">BA 19 00 00 11 11 11 11</tdml:documentPart>           <!-- a2 leadingSkip (4B) and padding to fulfill alignment of 8B -->
      <!--                                    20          24                 -->
      <tdml:documentPart type="byte">77 61 6C 74 65 72 3A</tdml:documentPart>              <!-- a2 "walter:" -->
      <tdml:documentPart type="byte">BA 19 00 00 11 11 11 11 11</tdml:documentPart>        <!-- a2 leadingSkip (4B) and padding to fulfill alignment of 8B -->
      <!--                                    35             40       -->
      <tdml:documentPart type="byte">6A 65 73 73 65 3A</tdml:documentPart>                 <!-- a2 "jesse:" -->
      <tdml:documentPart type="byte">BA 19 00 00 51 52 53 54 55 11</tdml:documentPart>     <!-- a2 leadingSkip (4B) and padding to fulfill alignment of 8B -->
      <!--                                    50                56                 -->
      <tdml:documentPart type="byte">67 75 73 74 61 76 6F 3A</tdml:documentPart>           <!-- a2 "gustavo:" -->
      <tdml:documentPart type="byte">11 11 11 11 69 70 71 00</tdml:documentPart>           <!-- b1 leadingSkip (4B) and padding to fulfill alignment of 8B -->
      <!--                                    68          72                 -->
      <tdml:documentPart type="byte">33 32</tdml:documentPart>                             <!-- b1 "32" -->
      <tdml:documentPart type="byte">11 11 11 11 00 00</tdml:documentPart>                 <!-- b2 leadingSkip (4B) and padding to fulfill alignment of 4B -->
      <!--                                    78    80                 -->
      <tdml:documentPart type="byte">2D 33 30</tdml:documentPart>                          <!-- b2 "-30" -->
      <tdml:documentPart type="byte">73 73</tdml:documentPart>                             <!-- b2 trailingSkip (2B) -->
      <tdml:documentPart type="byte">73 73</tdml:documentPart>                             <!-- e24 trailingSkip (2B) -->

    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e24>
          <e24a>
            <a1>inits</a1>
          </e24a>
          <e24a>
            <a2>walter</a2>
          </e24a>
          <e24a>
            <a2>jesse</a2>
          </e24a>
          <e24a>
            <a2>gustavo</a2>
          </e24a>
          <e24b>
            <b1>32</b1>
          </e24b>
          <e24b>
            <b2>-30</b2>
          </e24b>
        </e24>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: leftAndRightFramingArray01
        Schema: alignmentSchema
          Root: e25
       Purpose: This test demonstrates Right and Left Framing on a complex element (array)
  -->

  <tdml:parserTestCase name="leftAndRightFramingArray01" root="e25"
    model="alignmentSchema" description="Section 9 Framing - Aligned Data - DFDL-09-020R">

    <tdml:document>
      <tdml:documentPart type="text">aaaaaaaaaaaaa,aaaaaaaaaaaa,aaaaaaaaaaaaaaaa,aaaaaaaaaaaaaaaa,aaaaaaaaaaaaaaaa,aaaaaaaaaaaaaaaa</tdml:documentPart> 
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
     Test Name: leftAndRightFramingArray02
        Schema: alignmentSchema
          Root: e26
       Purpose: This test demonstrates Right and Left Framing on a complex element (array)
  -->

  <tdml:parserTestCase name="leftAndRightFramingArray02" root="e26"
    model="alignmentSchema" description="Section 9 Framing - Aligned Data - DFDL-09-020R">

    <tdml:document>
      <tdml:documentPart type="text">aabb</tdml:documentPart>               <!-- leadingSkip (2B) and padding to fulfill alignment -->
      <!--                              4                 -->
      <tdml:documentPart type="text">the first string|</tdml:documentPart>   <!-- repeat -->
      <!--                                          21                -->
      <tdml:documentPart type="text">cccc</tdml:documentPart>               <!-- trailingSkip (4B) -->
      <!--                              25                -->
      <tdml:documentPart type="text">,</tdml:documentPart>                  <!-- separator -->
      <!--                           26                -->
      <tdml:documentPart type="text">aa</tdml:documentPart>            <!-- leadingSkip (2B) and padding to fulfill alignment -->
      <!--                           28                -->
      <tdml:documentPart type="text">the second string|</tdml:documentPart>  <!-- repeat -->
      <!--                                            46                -->
      <tdml:documentPart type="text">cccc</tdml:documentPart>               <!-- trailingSkip (4B) -->
      <!--                             50                 -->
      <tdml:documentPart type="text">,</tdml:documentPart>                  <!-- separator -->
      <!--                           51                -->
      <tdml:documentPart type="text">aabbb</tdml:documentPart>                <!-- leadingSkip (2B) and padding to fulfill alignment -->
      <!--                           53  56                   -->
      <tdml:documentPart type="text">three|</tdml:documentPart>              <!-- repeat -->
      <!--                                62                -->
      <tdml:documentPart type="text">cccc</tdml:documentPart>               <!-- trailingSkip (4B) -->
      <!--                              66                           -->
      <tdml:documentPart type="text">,</tdml:documentPart>                  <!-- separator -->
      <!--                           67                -->
      <tdml:documentPart type="text">aabbb</tdml:documentPart>             <!-- leadingSkip (2B) and padding to fulfill alignment -->
      <!--                           69  72               -->
      <tdml:documentPart type="text">4|</tdml:documentPart>                  <!-- repeat -->
      <!--                            74                -->
      <tdml:documentPart type="text">cccc</tdml:documentPart>               <!-- trailingSkip (4B) -->
      <!--                              78                -->
      <tdml:documentPart type="text">,</tdml:documentPart>                  <!-- separator -->
      <!--                           79                -->
      <tdml:documentPart type="text">aabbb</tdml:documentPart>                 <!-- leadingSkip (2B) and padding -->
      <!--                           81  84               -->
      <tdml:documentPart type="text">the fifth one is the biggest one|</tdml:documentPart>              <!-- repeat -->
      <!--                                                           117-->
      <tdml:documentPart type="text">cccc</tdml:documentPart>               <!-- trailingSkip (4B) -->
      <!--                              121                 -->
      <tdml:documentPart type="text">,</tdml:documentPart>                  <!-- separator -->
      <!--                           122               -->
      <tdml:documentPart type="text">aa</tdml:documentPart>                <!-- leadingSkip (2B) - no padding needed -->
      <!--                          124                -->
      <tdml:documentPart type="text">6 4 fun|</tdml:documentPart>                  <!-- repeat -->
      <tdml:documentPart type="text">cccc</tdml:documentPart>               <!-- trailingSkip (4B) -->
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e26>
          <repeat>the first string</repeat>
          <repeat>the second string</repeat>
          <repeat>three</repeat>
          <repeat>4</repeat>
          <repeat>the fifth one is the biggest one</repeat>
          <repeat>6 4 fun</repeat>
        </e26>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: leftAndRightFramingArray03
        Schema: alignmentSchema
          Root: e27
       Purpose: This test demonstrates Right and Left Framing on a complex element (array)
  -->

  <tdml:parserTestCase name="leftAndRightFramingArray03" root="e27"
    model="alignmentSchema" description="Section 9 Framing - Aligned Data - DFDL-09-020R">

    <tdml:document>
      <tdml:documentPart type="text">-=</tdml:documentPart>                 <!-- outer[1] leadingSkip and alignment padding --> 
      <!--                            2                 -->
      <tdml:documentPart type="text">--(one)----</tdml:documentPart>        <!-- inner[1] leadingSkip, data, and trailingSkip --> 
      <!--                                     13       -->
      <tdml:documentPart type="text">|</tdml:documentPart>                  <!-- inner sep --> 
      <!--                           14                 -->
      <tdml:documentPart type="text">--(two)----</tdml:documentPart>        <!-- inner[2] leadingSkip, data, and trailingSkip --> 
      <!--                                     25       -->
      <tdml:documentPart type="text">,</tdml:documentPart>                  <!-- outer sep --> 
      <!--                           26                 -->
      <tdml:documentPart type="text">-=</tdml:documentPart>                 <!-- outer[2] leadingSkip and alignment padding --> 
      <!--                            28                -->
      <tdml:documentPart type="text">--==(potato)----</tdml:documentPart>   <!-- inner[1] leadingSkip, data, and trailingSkip --> 
      <!--                                          44  -->
      <tdml:documentPart type="text">|</tdml:documentPart>                  <!-- inner sep --> 
      <!--                           45                 -->
      <tdml:documentPart type="text">--=(potato)----</tdml:documentPart>    <!-- inner[2] leadingSkip, data, and trailingSkip --> 
      <!--                                         60   -->
      <tdml:documentPart type="text">,</tdml:documentPart>                  <!-- outer sep --> 
      <!--                           61                 -->
      <tdml:documentPart type="text">-</tdml:documentPart>                  <!-- outer[3] leadingSkip and alignment padding --> 
      <!--                           62                 -->
      <tdml:documentPart type="text">--(one)----</tdml:documentPart>        <!-- inner[1] leadingSkip, data, and trailingSkip --> 
      <!--                                     73       -->
      <tdml:documentPart type="text">|</tdml:documentPart>                  <!-- inner sep --> 
      <!--                           74                 -->
      <tdml:documentPart type="text">--(two)----</tdml:documentPart>        <!-- inner[2] leadingSkip, data, and trailingSkip --> 
      <!--                                     84       -->
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e27>
          <outer>
            <inner>one</inner>
            <inner>two</inner>
          </outer>
          <outer>
            <inner>potato</inner>
            <inner>potato</inner>
          </outer>
          <outer>
            <inner>one</inner>
            <inner>two</inner>
          </outer>
        </e27>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

</tdml:testSuite>
