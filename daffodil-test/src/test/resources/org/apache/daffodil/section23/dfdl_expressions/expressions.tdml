<?xml version="1.0" encoding="UTF-8"?>
<!--
  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->

<tdml:testSuite suiteName="expressions"
  description="lengthKind explicit and occursCountKind expression"
  xmlns:tdml="http://www.ibm.com/xmlns/dfdl/testData"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:dfdl="http://www.ogf.org/dfdl/dfdl-1.0/"
  xmlns:dfdlx="http://www.ogf.org/dfdl/dfdl-1.0/extensions"
  xmlns:ex="http://example.com" 
  xmlns:daf="urn:ogf:dfdl:2013:imp:daffodil.apache.org:2018:ext"  
  xmlns:fn="http://www.w3.org/2005/xpath-functions"
  defaultRoundTrip="true">
  
  <tdml:defineSchema name="diagnostics">
    <xs:include schemaLocation="org/apache/daffodil/xsd/DFDLGeneralFormat.dfdl.xsd"/>
    <dfdl:format ref="ex:GeneralFormat" lengthKind="delimited"/>

    <xs:element name="e1">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="seq">
            <xs:complexType>
              <xs:sequence dfdl:separator=",">
                <xs:element name="item" type="xs:int" minOccurs="1" maxOccurs="10"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="inval" type="xs:string" dfdl:inputValueCalc="{ /invalid! }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e2">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="seq">
            <xs:complexType>
              <xs:sequence dfdl:separator=",">
                <xs:element name="item" type="xs:int" minOccurs="1" maxOccurs="10"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="inval" type="xs:string" dfdl:inputValueCalc="{ ! }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e3">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="seq">
            <xs:complexType>
              <xs:sequence dfdl:separator=",">
                <xs:element name="item" type="xs:int" minOccurs="1" maxOccurs="10"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="inval" type="xs:string" dfdl:inputValueCalc="{ ././.\\/ }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

  </tdml:defineSchema>

  <tdml:defineSchema name="paths">
    <xs:include schemaLocation="org/apache/daffodil/xsd/DFDLGeneralFormat.dfdl.xsd"/>
    <dfdl:format ref="ex:GeneralFormat" lengthKind="delimited"/>

    <xs:element name="e1">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="seq">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="item" type="xs:int" minOccurs="1" maxOccurs="10"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="items" type="xs:int" dfdl:inputValueCalc="{ /ex:e1/ex:seq/ex:item }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e2">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="seq">
            <xs:complexType>
              <xs:sequence dfdl:separator=",">
                <xs:element name="item" type="xs:int" minOccurs="1" maxOccurs="10"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="items" type="xs:string" dfdl:inputValueCalc="{ xs:string(/ex:e2/ex:seq/../ex:seq/../ex:seq/ex:item[2]) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e3">
      <xs:complexType>
        <xs:sequence dfdl:separator=".">
          <xs:element name="seq">
            <xs:complexType>
              <xs:sequence dfdl:separator=",">
                <xs:element name="item" type="xs:int" minOccurs="1" maxOccurs="10"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="seq2">
            <xs:complexType>
              <xs:sequence dfdl:separator="|">
                <xs:element name="item" type="xs:int" minOccurs="1" maxOccurs="10"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="seq3">
            <xs:complexType>
              <xs:sequence dfdl:separator=":">
                <xs:element name="item" type="xs:int" minOccurs="1" maxOccurs="10"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="items" type="xs:string" dfdl:inputValueCalc="{ xs:string(/ex:e3/ex:seq/ex:item[2] + /ex:e3/ex:seq/../ex:seq2/ex:item[1] + /ex:e3/ex:seq3/../ex:seq2/../ex:seq/../ex:seq3/ex:item[4]) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e4">
      <xs:complexType>
        <xs:sequence dfdl:separator=".">
          <xs:element name="seq">
            <xs:complexType>
              <xs:sequence dfdl:separator=",">
                <xs:element name="item" type="xs:int" minOccurs="1" maxOccurs="10"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="seq2">
            <xs:complexType>
              <xs:sequence dfdl:separator="|">
                <xs:element name="item" type="xs:int" minOccurs="1" maxOccurs="10"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="seq3">
            <xs:complexType>
              <xs:sequence dfdl:separator=":">
                <xs:element name="item" type="xs:int" minOccurs="1" maxOccurs="10"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="items" type="xs:string" dfdl:inputValueCalc="{ /ex:e4/ex:seq3/../ex:seq2/../ex:seq/ex:item/../../ex:seq3/ex:item }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e5">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="seq">
            <xs:complexType>
              <xs:sequence dfdl:separator=",">
                <xs:element name="item" dfdl:terminator="!" minOccurs="1" maxOccurs="10">
                  <xs:complexType>
                    <xs:sequence dfdl:separator="+">
                      <xs:element name="sub" type="xs:int" minOccurs="1" maxOccurs="2"/>
                    </xs:sequence>
                  </xs:complexType>
                </xs:element>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="items" type="xs:string" dfdl:inputValueCalc="{ /ex:e5/ex:seq/ex:item/ex:sub[2] }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e6">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="seq">
            <xs:complexType>
              <xs:sequence dfdl:separator=",">
                <xs:element name="item" type="xs:int" minOccurs="1" maxOccurs="10"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="beyond" type="xs:string" dfdl:inputValueCalc="{ ../../../. }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e7">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="a" type="xs:int" />
          <xs:element name="a" type="xs:int" />
          <xs:element name="a" type="xs:int" />
          <xs:element name="ivc" type="xs:int" dfdl:inputValueCalc="{ fn:count(../ex:a) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e8">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="a" type="xs:int" />
          <xs:element name="a" type="xs:int" />
          <xs:element name="a" type="xs:int" />
          <xs:element name="ivc" type="xs:int" dfdl:inputValueCalc="{ ../ex:a[2] }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

  </tdml:defineSchema>


  <tdml:defineSchema name="hiddenElem">
    <xs:include schemaLocation="org/apache/daffodil/xsd/DFDLGeneralFormat.dfdl.xsd"/>
    <dfdl:format ref="ex:GeneralFormat" lengthKind="delimited"
      occursCountKind='parsed'/>
    
    <xs:group name="hiddenData">
      <xs:sequence dfdl:separator="|">
        <xs:element name="password" type="xs:string" dfdl:initiator="pw:" minOccurs="0" maxOccurs="1" dfdl:lengthKind="delimited"/>
      </xs:sequence>
    </xs:group>    

    <xs:element name="e1">
      <xs:complexType>
        <xs:sequence>
          <xs:sequence dfdl:hiddenGroupRef="ex:hiddenData"/>
          <xs:element name="hideme" type="xs:string" dfdl:inputValueCalc="{ fn:concat(fn:substring(/ex:e1/ex:password[1], 1, 1), '***') }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e1b">
      <xs:complexType>
        <xs:sequence>
          <xs:sequence dfdl:hiddenGroupRef="ex:hiddenData"/>
          <xs:element name="hideme" type="xs:string" dfdl:inputValueCalc="{ fn:concat(fn:substring(/ex:e1b/ex:password[-1], 1, 1), '***') }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e1c">
      <xs:complexType>
        <xs:sequence>
          <xs:sequence dfdl:hiddenGroupRef="ex:hiddenData"/>
          <xs:element name="hideme" type="xs:string" dfdl:inputValueCalc="{ fn:concat(fn:substring(/ex:e1c/ex:password[10], 1, 1), '***') }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e2">
      <xs:complexType>
        <xs:sequence>
          <xs:sequence dfdl:hiddenGroupRef="ex:hiddenData"/>
          <xs:element name="unhideme" type="xs:string" dfdl:inputValueCalc="{ /ex:e2/ex:password[1] }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
  
  </tdml:defineSchema>

  <tdml:defineSchema name="asterisk">
    <xs:include schemaLocation="org/apache/daffodil/xsd/DFDLGeneralFormat.dfdl.xsd"/>
    <dfdl:format ref="ex:GeneralFormat" lengthKind="delimited"/>

    <xs:element name="e1">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="nest">
            <xs:complexType>
              <xs:sequence dfdl:separator=",">
                <xs:element name="item" type="xs:string" minOccurs="0" maxOccurs="10"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="children" type="xs:string" dfdl:inputValueCalc="{ /ex:e1/ex:nest/* }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e2">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="nest">
            <xs:complexType>
              <xs:sequence dfdl:separator=",">
                <xs:element name="item" type="xs:string" minOccurs="0" maxOccurs="10"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="children" type="xs:string" dfdl:inputValueCalc="{ //* }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e3">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="nest">
            <xs:complexType>
              <xs:sequence dfdl:separator=",">
                <xs:element name="item" type="xs:string" minOccurs="0" maxOccurs="10"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="literal" type="xs:string" dfdl:inputValueCalc="{ '*' }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

  </tdml:defineSchema>
  
  <tdml:defineSchema name="attributeAxis">
    <xs:include schemaLocation="org/apache/daffodil/xsd/DFDLGeneralFormat.dfdl.xsd"/>
    <dfdl:format ref="ex:GeneralFormat" lengthKind="delimited"/>

    <xs:element name="e1">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string" type="xs:string" dfdl:nilKind="literalValue" nillable="true" dfdl:nilValue="NIL"/>
          <xs:element name="isNil" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:string@nil }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e2">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string" type="xs:string" dfdl:nilKind="literalValue" nillable="true" dfdl:nilValue="NIL"/>
          <xs:element name="isNil" type="xs:boolean" dfdl:inputValueCalc="{ //@nil }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e3">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string" type="xs:string" dfdl:nilKind="literalValue" nillable="true" dfdl:nilValue="NIL"/>
          <xs:element name="isNil" type="xs:boolean" dfdl:inputValueCalc="{ //ex:string[@*] }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

  </tdml:defineSchema>  

  <tdml:defineSchema name="comparisonOperators">
    <xs:include schemaLocation="org/apache/daffodil/xsd/DFDLGeneralFormat.dfdl.xsd"/>
    <dfdl:format ref="ex:GeneralFormat" lengthKind="delimited"/>

    <xs:element name="e1">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string1" type="xs:string"/> 
          <xs:element name="string2" type="xs:string"/> 
          <xs:element name="same" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:string1 eq ../ex:string2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e2">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string1" type="xs:string"/> 
          <xs:element name="string2" type="xs:string"/> 
          <xs:element name="same" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:string1 = ../ex:string2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e3">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="int1" type="xs:int"/> 
          <xs:element name="int2" type="xs:int"/> 
          <xs:element name="oneLTtwo" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:int1 lt ../ex:int2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e4">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="int1" type="xs:int"/> 
          <xs:element name="int2" type="xs:int"/> 
          <xs:element name="oneLTtwo" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:int1 &lt; ../ex:int2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e5">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="float1" type="xs:float"/> 
          <xs:element name="float2" type="xs:float"/> 
          <xs:element name="oneGTtwo" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:float1 gt ../ex:float2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e6">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="float1" type="xs:float"/> 
          <xs:element name="float2" type="xs:float"/> 
          <xs:element name="oneGTtwo" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:float1 &gt; ../ex:float2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e7">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string1" type="xs:string"/> 
          <xs:element name="string2" type="xs:string"/> 
          <xs:element name="notEqual" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:string1 ne ../ex:string2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e8">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string1" type="xs:string"/> 
          <xs:element name="string2" type="xs:string"/> 
          <xs:element name="notEqual" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:string1 != ../ex:string2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e9">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="int1" type="xs:int"/> 
          <xs:element name="int2" type="xs:int"/> 
          <xs:element name="notEqual" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:int1 ne ../ex:int2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e10">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="int1" type="xs:int"/> 
          <xs:element name="int2" type="xs:int"/> 
          <xs:element name="lessThanEqualTo" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:int1 le ../ex:int2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e11">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="int1" type="xs:int"/> 
          <xs:element name="int2" type="xs:int"/> 
          <xs:element name="lessThanEqualTo" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:int1 &lt;= ../ex:int2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e12">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="int1" type="xs:int"/> 
          <xs:element name="int2" type="xs:int"/> 
          <xs:element name="greaterThanEqualTo" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:int1 ge ../ex:int2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e13">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="int1" type="xs:int"/> 
          <xs:element name="int2" type="xs:int"/> 
          <xs:element name="greaterThanEqualTo" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:int1 &gt;= ../ex:int2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e14">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string1" type="xs:string"/> 
          <xs:element name="string2" type="xs:string"/> 
          <xs:element name="oneGTtwo" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:string1 gt ../ex:string2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e15">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string1" type="xs:string"/> 
          <xs:element name="string2" type="xs:string"/> 
          <xs:element name="oneLTtwo" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:string1 lt ../ex:string2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e16">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string1" type="xs:string" dfdl:lengthKind="explicit" dfdl:lengthUnits="bytes" dfdl:length="5"/> 
          <xs:element name="string2" type="xs:string" dfdl:lengthKind="explicit" dfdl:lengthUnits="bytes" dfdl:length="5"/> 
          <xs:element name="oneEQtwo" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:string1 eq ../ex:string2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e17">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string1" type="xs:string" dfdl:lengthKind="explicit" dfdl:lengthUnits="bytes" dfdl:length="5"/> 
          <xs:element name="string2" type="xs:string" dfdl:lengthKind="explicit" dfdl:lengthUnits="bytes" dfdl:length="5"/> 
          <xs:element name="oneLTtwo" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:string1 lt ../ex:string2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e18">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="dateTime1" type="xs:dateTime" dfdl:calendarCheckPolicy="lax" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="MM-dd-yyyy HH:mm:ss"/> 
          <xs:element name="dateTime2" type="xs:dateTime" dfdl:calendarCheckPolicy="lax" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="MM-dd-yyyy HH:mm:ss"/> 
          <xs:element name="oneGTtwo" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:dateTime1 gt ../ex:dateTime2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e19">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="dateTime1" type="xs:dateTime" dfdl:calendarCheckPolicy="lax" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="MM-dd-yyyy HH:mm:ss"/> 
          <xs:element name="dateTime2" type="xs:dateTime" dfdl:calendarCheckPolicy="lax" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="MM-dd-yyyy HH:mm:ss"/> 
          <xs:element name="oneLTtwo" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:dateTime1 lt ../ex:dateTime2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e20">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="dateTime1" type="xs:dateTime" dfdl:calendarCheckPolicy="lax" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="MM-dd-yyyy HH:mm:ss"/> 
          <xs:element name="dateTime2" type="xs:dateTime" dfdl:calendarCheckPolicy="lax" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="MM-dd-yyyy HH:mm:ss"/> 
          <xs:element name="notEqual" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:dateTime1 ne ../ex:dateTime2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e21">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="dateTime1" type="xs:dateTime" dfdl:calendarCheckPolicy="lax" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="MM-dd-yyyy HH:mm:ss"/> 
          <xs:element name="dateTime2" type="xs:dateTime" dfdl:calendarCheckPolicy="lax" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="MM-dd-yyyy HH:mm:ss"/> 
          <xs:element name="same" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:dateTime1 eq ../ex:dateTime2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e22">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="date1" type="xs:date" dfdl:calendarCheckPolicy="lax" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="MM-dd-yyyy"/> 
          <xs:element name="date2" type="xs:date" dfdl:calendarCheckPolicy="lax" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="MM-dd-yyyy"/> 
          <xs:element name="lessThanEqualTo" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:date1 le ../ex:date2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e23">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="date1" type="xs:date" dfdl:calendarCheckPolicy="lax" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="MM-dd-yyyy"/> 
          <xs:element name="date2" type="xs:date" dfdl:calendarCheckPolicy="lax" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="MM-dd-yyyy"/> 
          <xs:element name="greaterThanEqualTo" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:date1 ge ../ex:date2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e24">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="date1" type="xs:date" dfdl:calendarCheckPolicy="lax" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="MM-dd-yyyy"/> 
          <xs:element name="date2" type="xs:date" dfdl:calendarCheckPolicy="lax" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="MM-dd-yyyy"/> 
          <xs:element name="oneGTtwo" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:date1 gt ../ex:date2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e25">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="date1" type="xs:date" dfdl:calendarCheckPolicy="lax" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="MM-dd-yyyy"/> 
          <xs:element name="date2" type="xs:date" dfdl:calendarCheckPolicy="lax" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="MM-dd-yyyy"/> 
          <xs:element name="oneLTtwo" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:date1 lt ../ex:date2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e26">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="date1" type="xs:date" dfdl:calendarCheckPolicy="lax" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="MM-dd-yyyy"/> 
          <xs:element name="date2" type="xs:date" dfdl:calendarCheckPolicy="lax" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="MM-dd-yyyy"/> 
          <xs:element name="notEqual" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:date1 ne ../ex:date2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e27">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="date1" type="xs:date" dfdl:calendarCheckPolicy="lax" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="MM-dd-yyyy"/> 
          <xs:element name="date2" type="xs:date" dfdl:calendarCheckPolicy="lax" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="MM-dd-yyyy"/> 
          <xs:element name="same" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:date1 eq ../ex:date2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e28">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="time1" type="xs:time" dfdl:calendarCheckPolicy="lax" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="HH:mm:ss"/> 
          <xs:element name="time2" type="xs:time" dfdl:calendarCheckPolicy="lax" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="HH:mm:ss"/> 
          <xs:element name="lessThanEqualTo" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:time1 le ../ex:time2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e29">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="time1" type="xs:time" dfdl:calendarCheckPolicy="lax" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="HH:mm:ss"/> 
          <xs:element name="time2" type="xs:time" dfdl:calendarCheckPolicy="lax" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="HH:mm:ss"/> 
          <xs:element name="greaterThanEqualTo" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:time1 ge ../ex:time2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e30">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="time1" type="xs:time" dfdl:calendarCheckPolicy="lax" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="HH:mm:ss"/> 
          <xs:element name="time2" type="xs:time" dfdl:calendarCheckPolicy="lax" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="HH:mm:ss"/> 
          <xs:element name="oneGTtwo" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:time1 gt ../ex:time2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e31">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="time1" type="xs:time" dfdl:calendarCheckPolicy="lax" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="HH:mm:ss"/> 
          <xs:element name="time2" type="xs:time" dfdl:calendarCheckPolicy="lax" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="HH:mm:ss"/> 
          <xs:element name="oneLTtwo" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:time1 lt ../ex:time2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e32">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="time1" type="xs:time" dfdl:calendarCheckPolicy="lax" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="HH:mm:ss"/> 
          <xs:element name="time2" type="xs:time" dfdl:calendarCheckPolicy="lax" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="HH:mm:ss"/> 
          <xs:element name="notEqual" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:time1 ne ../ex:time2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e33">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="time1" type="xs:time" dfdl:calendarCheckPolicy="lax" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="HH:mm:ss"/> 
          <xs:element name="time2" type="xs:time" dfdl:calendarCheckPolicy="lax" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="HH:mm:ss"/> 
          <xs:element name="same" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:time1 eq ../ex:time2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e34">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="dateTime1" type="xs:dateTime" dfdl:calendarCheckPolicy="lax" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="uuuu-MM-dd'T'HH:mm:ss"/> 
          <xs:element name="dateTime2" type="xs:dateTime" dfdl:calendarCheckPolicy="lax" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="uuuu-MM-dd'T'HH:mm:ss"/> 
          <xs:element name="oneLTtwo" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:dateTime1 lt ../ex:dateTime2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e35">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="dateTime1" type="xs:dateTime" dfdl:calendarCheckPolicy="lax" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="uuuu-MM-dd'T'HH:mm:ss"
            dfdl:calendarTimeZone="UTC"/> 
          <xs:element name="dateTime2" type="xs:dateTime" dfdl:calendarCheckPolicy="lax" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="uuuu-MM-dd'T'HH:mm:ssXXXXX"
            dfdl:calendarTimeZone="UTC"/> 
          <xs:element name="oneLTtwo" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:dateTime1 lt ../ex:dateTime2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e35a">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="dateTime1" type="xs:dateTime" dfdl:calendarCheckPolicy="lax" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="uuuu-MM-dd'T'HH:mm:ss"/> 
          <xs:element name="dateTime2" type="xs:dateTime" dfdl:calendarCheckPolicy="lax" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="uuuu-MM-dd'T'HH:mm:ssXXXXX"/> 
          <xs:element name="oneLTtwo" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:dateTime1 lt ../ex:dateTime2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e36">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="dateTime1" type="xs:dateTime" dfdl:calendarCheckPolicy="lax" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="uuuu-MM-dd'T'HH:mm:ssXXXXX"/> 
          <xs:element name="dateTime2" type="xs:dateTime" dfdl:calendarCheckPolicy="lax" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="uuuu-MM-dd'T'HH:mm:ssXXXXX"/> 
          <xs:element name="same" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:dateTime1 eq ../ex:dateTime2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e37">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="dateTime1" type="xs:dateTime" dfdl:calendarCheckPolicy="lax" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="MM-dd-yyyy HH:mm:ss"/> 
          <xs:element name="dateTime2" type="xs:dateTime" dfdl:calendarCheckPolicy="lax" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="MM-dd-yyyy HH:mm:ss"/> 
          <xs:element name="lessThanEqualTo" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:dateTime1 le ../ex:dateTime2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e38">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="dateTime1" type="xs:dateTime" dfdl:calendarCheckPolicy="lax" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="MM-dd-yyyy HH:mm:ss"/> 
          <xs:element name="dateTime2" type="xs:dateTime" dfdl:calendarCheckPolicy="lax" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="MM-dd-yyyy HH:mm:ss"/> 
          <xs:element name="greaterThanEqualTo" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:dateTime1 ge ../ex:dateTime2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e39">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="bool1" type="xs:string"/> 
          <xs:element name="bool2" type="xs:string"/> 
          <xs:element name="same" type="xs:boolean" dfdl:inputValueCalc="{ xs:boolean(../ex:bool1) eq xs:boolean(../ex:bool2) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e40">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="bool1" type="xs:string"/> 
          <xs:element name="bool2" type="xs:string"/> 
          <xs:element name="oneLTtwo" type="xs:boolean" dfdl:inputValueCalc="{ xs:boolean(../ex:bool1) lt xs:boolean(../ex:bool2) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e41">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="bool1" type="xs:string"/> 
          <xs:element name="bool2" type="xs:string"/> 
          <xs:element name="oneGTtwo" type="xs:boolean" dfdl:inputValueCalc="{ xs:boolean(../ex:bool1) gt xs:boolean(../ex:bool2) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e42">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="bool1" type="xs:string"/> 
          <xs:element name="bool2" type="xs:string"/> 
          <xs:element name="oneLEtwo" type="xs:boolean" dfdl:inputValueCalc="{ xs:boolean(../ex:bool1) le xs:boolean(../ex:bool2) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e43">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="bool1" type="xs:string"/> 
          <xs:element name="bool2" type="xs:string"/> 
          <xs:element name="oneGEtwo" type="xs:boolean" dfdl:inputValueCalc="{ xs:boolean(../ex:bool1) ge xs:boolean(../ex:bool2) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e44">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="bool1" type="xs:string"/> 
          <xs:element name="bool2" type="xs:string"/> 
          <xs:element name="notEqual" type="xs:boolean" dfdl:inputValueCalc="{ xs:boolean(../ex:bool1) ne xs:boolean(../ex:bool2) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e45">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="int1" type="xs:int"/>
          <xs:element name="ulong1" type="xs:unsignedLong"/>
          <xs:element name="intEqULong" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:int1 eq ../ex:ulong1 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e46">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="hexBinary1" type="xs:hexBinary"
            dfdl:lengthKind="explicit" dfdl:lengthUnits="bytes"
            dfdl:length="3" dfdl:encoding="ISO-8859-1"/>
          <xs:element name="hexBinary2" type="xs:hexBinary"
            dfdl:lengthKind="explicit" dfdl:lengthUnits="bytes"
            dfdl:length="3" dfdl:encoding="ISO-8859-1"/>
          <xs:element name="equal" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:hexBinary1 eq ../ex:hexBinary2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e47">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="hexBinary1" type="xs:hexBinary"
            dfdl:lengthKind="explicit" dfdl:lengthUnits="bytes"
            dfdl:length="3" dfdl:encoding="ISO-8859-1"/>
          <xs:element name="hexBinary2" type="xs:hexBinary"
            dfdl:lengthKind="explicit" dfdl:lengthUnits="bytes"
            dfdl:length="3" dfdl:encoding="ISO-8859-1"/>
          <xs:element name="notEqual" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:hexBinary1 ne ../ex:hexBinary2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

  </tdml:defineSchema>

  <tdml:defineSchema name="newRegex">
    <xs:include schemaLocation="org/apache/daffodil/xsd/DFDLGeneralFormat.dfdl.xsd"/>
    <dfdl:format ref="ex:GeneralFormat" />
    
    <xs:simpleType name="st1">
      <xs:restriction base="xs:string">
        <xs:pattern value="\d\d(?=\D+)" />
      </xs:restriction>
    </xs:simpleType>
    
    <xs:element name="s3">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="e1" type="ex:st1" dfdl:lengthKind="delimited">
            <xs:annotation>
              <xs:appinfo source="http://www.ogf.org/dfdl/">
                <dfdl:assert test="{ dfdl:checkConstraints(.) }"
                  message="Assertion failed for dfdl:checkConstraints(.)" />
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element name="extra" type="xs:string" dfdl:lengthKind="delimited"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="s1">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="e1" type="xs:string" dfdl:lengthKind="pattern" dfdl:lengthPattern="\d\d(?=\D+)"/>
          <xs:element name="extra" type="xs:string" dfdl:lengthKind="delimited"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="s2">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="e1" type="xs:int" dfdl:lengthKind="pattern" dfdl:lengthPattern="\d\d(?=\D+)">
            <xs:annotation>
              <xs:appinfo source="http://www.ogf.org/dfdl/">
                <dfdl:assert testKind="pattern" testPattern="\d\d(?=\D+)"
                  message="Assertion failed for pattern '\d\d'" />
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element name="extra" type="xs:string" dfdl:lengthKind="delimited"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="s4">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="e1" type="xs:string" dfdl:lengthKind="pattern" dfdl:lengthPattern="\U0010ffff"/>
          <xs:element name="extra" type="xs:string" dfdl:lengthKind="delimited"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

  </tdml:defineSchema>

  <tdml:defineSchema name="lke1_rel">
    <xs:include schemaLocation="org/apache/daffodil/xsd/DFDLGeneralFormat.dfdl.xsd"/>
    <dfdl:format ref="ex:GeneralFormat" />

    <xs:element name="e1">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="len" type="xs:int"
            dfdl:representation="binary" dfdl:lengthKind="implicit" />
          <xs:element name="s1" type="xs:string"
            dfdl:lengthKind="explicit" dfdl:length="{ ../ex:len }" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

  </tdml:defineSchema>

  <tdml:parserTestCase name="lke1_rel" root="e1"
    model="lke1_rel" description="simplest computed length - DFDL-23-011R">

    <tdml:document>
      <tdml:documentPart type="byte">00000004
			</tdml:documentPart>
      <tdml:documentPart type="text">abcd</tdml:documentPart>
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e1>
          <ex:len>4</ex:len>
          <ex:s1>abcd</ex:s1>
        </ex:e1>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>

  <tdml:defineSchema name="lke1_abs">
    <xs:include schemaLocation="org/apache/daffodil/xsd/DFDLGeneralFormat.dfdl.xsd"/>
    <dfdl:format ref="ex:GeneralFormat" />

    <xs:element name="e1">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="len" type="xs:int"
            dfdl:representation="binary" dfdl:lengthKind="implicit" />
          <xs:element name="s1" type="xs:string"
            dfdl:lengthKind="explicit" dfdl:length="{ /ex:e1/ex:len }" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

  </tdml:defineSchema>


  <tdml:parserTestCase name="lke1_abs" root="e1"
    model="lke1_abs" description="simplest computed length - DFDL-23-011R">

    <tdml:document>
      <tdml:documentPart type="byte">00000004
			</tdml:documentPart>
      <tdml:documentPart type="text">abcd</tdml:documentPart>
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e1>
          <ex:len>4</ex:len>
          <ex:s1>abcd</ex:s1>
        </ex:e1>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>

  <tdml:defineSchema name="ocke1">
    <xs:include schemaLocation="org/apache/daffodil/xsd/DFDLGeneralFormat.dfdl.xsd"/>
    <dfdl:format ref="ex:GeneralFormat" />

    <xs:element name="e1">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="reps" type="xs:int"
            dfdl:representation="binary" dfdl:lengthKind="implicit" />
          <xs:element name="scale" type="xs:int"
            dfdl:representation="binary" dfdl:lengthKind="implicit" />
          <xs:element name="s1" type="xs:string"
            dfdl:lengthKind="explicit" dfdl:length="{1}"
            dfdl:occursCount="{ ../ex:reps * /ex:e1/ex:scale}"
            dfdl:occursCountKind="expression" minOccurs="0" maxOccurs="unbounded" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

  </tdml:defineSchema>

  <tdml:parserTestCase name="ocke1" root="e1" model="ocke1"
    description="very simple occursCountKind expression - DFDL-23-011R">

    <tdml:document>
      <!-- two binary integers get multiplied 2x2=4 -->
      <tdml:documentPart type="byte">00000002 00000002
			</tdml:documentPart>
      <!-- followed by that many characters, each is an element of the array -->
      <tdml:documentPart type="text">abcd</tdml:documentPart>
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e1>
          <ex:reps>2</ex:reps>
          <ex:scale>2</ex:scale>
          <ex:s1>a</ex:s1>
          <ex:s1>b</ex:s1>
          <ex:s1>c</ex:s1>
          <ex:s1>d</ex:s1>
        </ex:e1>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>

  <tdml:defineSchema name="ocke2">
    <xs:include schemaLocation="org/apache/daffodil/xsd/DFDLGeneralFormat.dfdl.xsd"/>
    <dfdl:format ref="ex:GeneralFormat" />

    <xs:element name="e1">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="scale" type="xs:int"
            dfdl:representation="binary" dfdl:lengthKind="implicit" />
          <xs:element name="hdr">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="reps" type="xs:int"
                  dfdl:representation="binary" dfdl:lengthKind="implicit" />
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="body">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="s1" type="xs:string"
                  dfdl:lengthKind="explicit" dfdl:length="{1}"
                  dfdl:occursCount="{ ../../ex:hdr/ex:reps * /ex:e1/ex:scale}"
                  dfdl:occursCountKind="expression" minOccurs="0"
                  maxOccurs="unbounded" />
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

  </tdml:defineSchema>

  <tdml:parserTestCase name="ocke2" root="e1" model="ocke2"
    description="very simple occursCountKind expression - DFDL-23-011R">

    <tdml:document>
      <!-- two binary integers get multiplied 2x2=4 -->
      <tdml:documentPart type="byte">00000003 00000002
			</tdml:documentPart>
      <!-- followed by that many characters, each is an element of the array -->
      <tdml:documentPart type="text">abcdef</tdml:documentPart>
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e1>
          <ex:scale>3</ex:scale>
          <ex:hdr>
            <ex:reps>2</ex:reps>
          </ex:hdr>
          <ex:body>
            <ex:s1>a</ex:s1>
            <ex:s1>b</ex:s1>
            <ex:s1>c</ex:s1>
            <ex:s1>d</ex:s1>
            <ex:s1>e</ex:s1>
            <ex:s1>f</ex:s1>
          </ex:body>
        </ex:e1>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>

  <tdml:defineSchema name="ArrayOptionalElem-Embedded.dfdl.xsd">

    <xs:include schemaLocation="org/apache/daffodil/xsd/DFDLGeneralFormat.dfdl.xsd"/>
    <dfdl:format ref="ex:GeneralFormat" lengthUnits="bytes"
      encoding="UTF-8" separator="" initiator="" terminator=""
      occursCountKind="parsed" ignoreCase="no" textNumberRep="standard"
      representation="text" byteOrder="bigEndian" binaryNumberRep="binary" />

    <xs:element name="aoe_01">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="reps" type="xs:int"
            dfdl:representation="binary" dfdl:lengthKind="implicit" />
          <xs:element name="rows" type="xs:byte"
            dfdl:representation="binary" maxOccurs="unbounded"
            dfdl:lengthKind="implicit" dfdl:occursCountKind="expression"
            dfdl:occursCount="{ ../ex:reps }" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="aoe_02">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="reps" type="xs:unsignedInt"
            dfdl:representation="binary" dfdl:lengthKind="implicit" />
          <xs:element name="rows" type="xs:byte"
            dfdl:representation="binary" maxOccurs="unbounded"
            dfdl:occursCountKind="expression" dfdl:occursCount="{ ../ex:reps }" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

  </tdml:defineSchema>

  <tdml:parserTestCase name="ArrayOptElem_01" root="aoe_01"
    model="ArrayOptionalElem-Embedded.dfdl.xsd" description="occursCountKind expression with relative path - DFDL-23-011R">

    <tdml:document>
      <tdml:documentPart type="byte">00000003000102
			</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <aoe_01>
          <reps>3</reps>
          <rows>0</rows>
          <rows>1</rows>
          <rows>2</rows>
        </aoe_01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="ArrayOptElem_02" root="aoe_02"
    model="ArrayOptionalElem-Embedded.dfdl.xsd"
    description="an unsignedInt value in an occursCount expression - DFDL-23-011R">

    <tdml:document>
      <tdml:documentPart type="byte">00000003000102
			</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <aoe_02>
          <reps>3</reps>
          <rows>0</rows>
          <rows>1</rows>
          <rows>2</rows>
        </aoe_02>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <tdml:defineSchema name="expressions-Embedded.dfdl.xsd">

    <xs:include schemaLocation="org/apache/daffodil/xsd/DFDLGeneralFormat.dfdl.xsd"/>
    <dfdl:format ref="ex:GeneralFormat" lengthKind="delimited"
      lengthUnits="bytes" encoding="US-ASCII" separator="" initiator=""
      terminator="" occursCountKind="parsed" ignoreCase="no"
      textNumberRep="standard" representation="text" />

    <xs:element name="lke_01" dfdl:lengthKind="implicit">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="e1" type="xs:int"
            dfdl:lengthKind="explicit" dfdl:length="1" />
          <xs:element name="e2" type="xs:int"
            dfdl:lengthKind="explicit" dfdl:length="{../ex:e1}" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="lke_02" dfdl:lengthKind="implicit">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="e1" type="xs:int" dfdl:encoding="utf-8"
            dfdl:lengthKind="explicit" dfdl:length="1" />
          <xs:element name="e2" type="xs:int" dfdl:encoding="utf-8"
            dfdl:lengthKind="explicit" dfdl:length="{../ex:e1}" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="ocke_from_string">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="count" type="xs:string" />
          <xs:element name="item" type="xs:string" maxOccurs="unbounded"
            dfdl:occursCountKind="expression" dfdl:occursCount="{ xs:unsignedInt(../ex:count) }" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="ocke" dfdl:lengthKind="implicit">
      <xs:complexType>
        <xs:sequence dfdl:initiator="">
          <xs:element name="nrows" type="xs:int"
            dfdl:lengthKind="delimited" dfdl:terminator="," />
          <xs:element name="ncols" type="xs:int"
            dfdl:lengthKind="delimited" dfdl:terminator="," />
          <xs:element name="rows" maxOccurs="unbounded"
            dfdl:occursCountKind="expression" dfdl:occursCount="{ ../ex:nrows }">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="cols" type="xs:int"
                  maxOccurs="unbounded" dfdl:lengthKind="delimited"
                  dfdl:terminator="," dfdl:occursCountKind="expression"
                  dfdl:occursCount="{ ../../ex:ncols }" />
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="ocke2" dfdl:lengthKind="implicit">
      <xs:complexType>
        <xs:sequence dfdl:initiator="">
          <xs:element name="nrows" type="xs:int"
            dfdl:lengthKind="delimited" dfdl:terminator="," />
          <xs:element name="ncols" type="xs:int"
            dfdl:lengthKind="delimited" dfdl:terminator="," />
          <xs:element name="rows" maxOccurs="unbounded"
            dfdl:occursCountKind="expression" dfdl:occursCount="{ ../ex:nrows }">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="cols" type="xs:int"
                  maxOccurs="unbounded" dfdl:lengthKind="delimited"
                  dfdl:terminator="," dfdl:occursCountKind="expression"
                  dfdl:occursCount="
                  { ../../ex:ncols } " />
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="ocke3" dfdl:lengthKind="implicit">
      <xs:complexType>
        <xs:sequence dfdl:initiator="">
          <xs:element name="nrows" type="xs:int"
            dfdl:lengthKind="delimited" dfdl:terminator="," />
          <xs:element name="ncols" type="xs:int"
            dfdl:lengthKind="delimited" dfdl:terminator="," />
          <xs:element name="rows" maxOccurs="unbounded"
            dfdl:occursCountKind="expression" dfdl:occursCount="{ ../ex:nrows }">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="cols" type="xs:int"
                  maxOccurs="unbounded" dfdl:lengthKind="delimited"
                  dfdl:terminator="," dfdl:occursCountKind="expression"
                  dfdl:occursCount=" { ../../ex:ncols } " />
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="ocke4" dfdl:lengthKind="implicit">
      <xs:complexType>
        <xs:sequence dfdl:initiator="">
          <xs:element name="nrows" type="xs:int"
            dfdl:lengthKind="delimited" dfdl:terminator="," />
          <xs:element name="ncols" type="xs:int"
            dfdl:lengthKind="delimited" dfdl:terminator="," />
          <xs:element name="rows" maxOccurs="unbounded"
            dfdl:occursCountKind="expression" dfdl:occursCount="{ ../ex:nrows }">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="cols" type="xs:int"
                  maxOccurs="unbounded" dfdl:lengthKind="delimited"
                  dfdl:terminator="," dfdl:occursCountKind="expression"
                  dfdl:occursCount=" { ../../ex:ncols }
                  " />
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="ocke5">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="arr1" maxOccurs="unbounded">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="field1" type="xs:string" />
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="arr2" type="xs:string" maxOccurs="unbounded"
            dfdl:occursCountKind="expression"
            dfdl:occursCount="{ xs:unsignedLong(does/not/exist) }" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="ocke6">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="arr1" maxOccurs="unbounded">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="field1" type="xs:string" />
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="arr2" type="xs:string" maxOccurs="unbounded"
            dfdl:occursCountKind="expression"
            dfdl:occursCount="{ xs:unsignedLong(../ex:arr1[does/not/exist]/field1) }" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="ocke7">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="arr2" maxOccurs="unbounded"
            dfdl:occursCountKind="expression"
            dfdl:occursCount="{ xs:unsignedLong(ex:count) }">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="count" type="xs:int" />
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="ocke8">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="arr" type="xs:string" maxOccurs="unbounded"
            dfdl:occursCountKind="expression"
            dfdl:occursCount="{ xs:unsignedLong(..) }" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="expr_space" dfdl:lengthKind="implicit">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="dummy" type="xs:int"
            dfdl:lengthKind="delimited" />
          <xs:element name="value" type="xs:string"
            dfdl:lengthKind="delimited" dfdl:inputValueCalc=" { '    a    b    ' } "  />
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="expr_space2" dfdl:lengthKind="implicit">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="dummy" type="xs:int"
            dfdl:lengthKind="delimited" />
          <xs:element name="value" type="xs:string"
            dfdl:lengthKind="delimited">
            <xs:annotation>
              <xs:appinfo source="http://www.ogf.org/dfdl/">
                <dfdl:element>
                  <dfdl:property name="inputValueCalc"><![CDATA[ { dfdl:decodeDFDLEntities('a%LF;b%LF;c') } ]]></dfdl:property>
                </dfdl:element>
              </xs:appinfo>
           </xs:annotation>
           </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="expr_space3" dfdl:lengthKind="implicit">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="dummy" type="xs:int"
            dfdl:lengthKind="delimited" />
          <xs:element name="value" type="xs:string"
            dfdl:lengthKind="delimited">
            <xs:annotation>
              <xs:appinfo source="http://www.ogf.org/dfdl/">
                <dfdl:element>
                  <dfdl:property name = "inputValueCalc"><![CDATA[{ 'a            b                                    c' }]]></dfdl:property>
                </dfdl:element>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="expr_space3b" dfdl:lengthKind="implicit">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="dummy" type="xs:int"
            dfdl:lengthKind="delimited" />
          <xs:element name="value" type="xs:string">
            <xs:annotation>
		    <xs:appinfo source="http://www.ogf.org/dfdl/">
                <dfdl:element>
                  <dfdl:property name="inputValueCalc"><![CDATA[{ dfdl:decodeDFDLEntities('a%LF;b%LF;c') }]]></dfdl:property>
                </dfdl:element>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="expr_space4" dfdl:lengthKind="implicit">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="dummy" type="xs:int"
            dfdl:lengthKind="delimited" />
          <xs:element name="value" type="xs:string" dfdl:inputValueCalc="{ 'a&#x0A;b&#x0A;c' }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="expr_space5" dfdl:lengthKind="implicit">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="value" type="xs:string" dfdl:lengthKind="delimited" dfdl:initiator="{'
3
2
1
' }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="expr_space5b" dfdl:lengthKind="implicit">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="value" type="xs:string" dfdl:lengthKind="delimited">
            <xs:annotation>
		    <xs:appinfo source="http://www.ogf.org/dfdl/">
                <dfdl:element>
                  <dfdl:property name="initiator"><![CDATA[{'               1 '}]]></dfdl:property>
                </dfdl:element>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="ws_expr" dfdl:lengthKind="implicit">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="e1" type="xs:int" maxOccurs="unbounded"
            dfdl:lengthKind="delimited" dfdl:terminator="]%NL;=" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="ws_expr2" dfdl:lengthKind="implicit">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="e1" type="xs:int" maxOccurs="unbounded"
            dfdl:lengthKind="delimited" dfdl:terminator="]&#xA;=" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

  </tdml:defineSchema>

  <tdml:parserTestCase name="lke2_rel" root="lke_01"
    model="expressions-Embedded.dfdl.xsd" description="length expression, relative path - DFDL-23-011R">

    <tdml:document>3538</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <lke_01>
          <e1>3</e1>
          <e2>538</e2>
        </lke_01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="lke3_rel" root="lke_02"
    model="expressions-Embedded.dfdl.xsd" description="length expression, relative path - DFDL-23-011R">

    <tdml:document>3538</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <lke_02>
          <e1>3</e1>
          <e2>538</e2>
        </lke_02>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
       Test Name: ocke_from_string_01
          Schema: expressions-Embedded.dfdl.xsd
         Purpose: This test demonstrates the use of strings in occursCount expression
  -->
  <tdml:parserTestCase name="ocke_from_string_01" root="ocke_from_string"
    model="expressions-Embedded.dfdl.xsd" description="occursCountKind expression - DFDL-23-011R">

    <tdml:document><![CDATA[2,3,1]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ocke_from_string>
          <count>2</count>
          <item>3</item>
          <item>1</item>
        </ocke_from_string>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
       Test Name: ocke_from_string_01
          Schema: expressions-Embedded.dfdl.xsd
          Purpose: This test demonstrates the use of non-numeric strings in
                   occursCount expression results in a parse error
  -->
  <tdml:parserTestCase name="ocke_from_string_02" root="ocke_from_string"
    model="expressions-Embedded.dfdl.xsd" description="occursCountKind expression - DFDL-23-011R">

    <tdml:document><![CDATA[X,3,1]]></tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>Cannot convert 'X'</tdml:error>
      <tdml:error>not a valid xs:long</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
<!--
     Test Name: ocke_rel
        Schema: expressions-Embedded.dfdl.xsd
       Purpose: This test demonstrates the use of relative paths in an occursCount expression
-->

  <tdml:parserTestCase name="ocke_rel" root="ocke"
    model="expressions-Embedded.dfdl.xsd" description="occursCountKind expression - DFDL-23-011R">

    <tdml:document><![CDATA[2,3,1,2,3,4,5,6,]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ocke>
          <nrows>2</nrows>
          <ncols>3</ncols>
          <rows>
            <cols>1</cols>
            <cols>2</cols>
            <cols>3</cols>
          </rows>
          <rows>
            <cols>4</cols>
            <cols>5</cols>
            <cols>6</cols>
          </rows>
        </ocke>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
<!--
     Test Name: ocke_rel2
        Schema: expressions-Embedded.dfdl.xsd
       Purpose: This test demonstrates that whitespace surrounding an expression is collapsed. In this case,
                there is a newline in front of the expression and a space afterwards. 
-->
  
  <tdml:parserTestCase name="ocke_rel2" root="ocke2"
    model="expressions-Embedded.dfdl.xsd" description="occursCountKind expression - DFDL-23-011R">

    <tdml:document><![CDATA[2,3,1,2,3,4,5,6,]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ocke2>
          <nrows>2</nrows>
          <ncols>3</ncols>
          <rows>
            <cols>1</cols>
            <cols>2</cols>
            <cols>3</cols>
          </rows>
          <rows>
            <cols>4</cols>
            <cols>5</cols>
            <cols>6</cols>
          </rows>
        </ocke2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
<!--
     Test Name: ocke_rel3
        Schema: expressions-Embedded.dfdl.xsd
       Purpose: This test demonstrates that whitespace surrounding an expression is collapsed. In this case,
                there is a space in front of the expression and a space afterwards. 
-->
  
  <tdml:parserTestCase name="ocke_rel3" root="ocke3"
    model="expressions-Embedded.dfdl.xsd" description="occursCountKind expression - DFDL-23-011R">

    <tdml:document><![CDATA[2,3,1,2,3,4,5,6,]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ocke3>
          <nrows>2</nrows>
          <ncols>3</ncols>
          <rows>
            <cols>1</cols>
            <cols>2</cols>
            <cols>3</cols>
          </rows>
          <rows>
            <cols>4</cols>
            <cols>5</cols>
            <cols>6</cols>
          </rows>
        </ocke3>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
<!--
     Test Name: ocke_rel4
        Schema: expressions-Embedded.dfdl.xsd
       Purpose: This test demonstrates that whitespace surrounding an expression is collapsed. In this case,
                there is a space in front of the expression and a newline afterwards. 
-->
  
  <tdml:parserTestCase name="ocke_rel4" root="ocke4"
    model="expressions-Embedded.dfdl.xsd" description="occursCountKind expression - DFDL-23-011R">

    <tdml:document><![CDATA[2,3,1,2,3,4,5,6,]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ocke4>
          <nrows>2</nrows>
          <ncols>3</ncols>
          <rows>
            <cols>1</cols>
            <cols>2</cols>
            <cols>3</cols>
          </rows>
          <rows>
            <cols>4</cols>
            <cols>5</cols>
            <cols>6</cols>
          </rows>
        </ocke4>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
       Test Name: ocke_step_dne
          Schema: expressions-Embedded.dfdl.xsd
          Purpose: This test demonstrates that we get an appropriate error message when an
                   occursCountKind expression references a non existent path step
  -->
  <tdml:parserTestCase name="ocke_step_dne" root="ocke5"
    model="expressions-Embedded.dfdl.xsd" description="occursCountKind expression - DFDL-23-011R">

    <tdml:document><![CDATA[]]></tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Path expression</tdml:error>
      <tdml:error>absolute</tdml:error>
      <tdml:error>upward step</tdml:error>
      <tdml:error>does/not/exist</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <!--
       Test Name: ocke_array_index_step_dne
          Schema: expressions-Embedded.dfdl.xsd
          Purpose: This test demonstrates that we get an appropriate error message when an
                   occursCountKind expression references a non existent path step inside
                   an array index
  -->
  <tdml:parserTestCase name="ocke_array_index_step_dne" root="ocke6"
    model="expressions-Embedded.dfdl.xsd" description="occursCountKind expression - DFDL-23-011R">

    <tdml:document><![CDATA[]]></tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Path expression</tdml:error>
      <tdml:error>absolute</tdml:error>
      <tdml:error>upward step</tdml:error>
      <tdml:error>does/not/exist</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <!--
       Test Name: ocke_non_upward
          Schema: expressions-Embedded.dfdl.xsd
          Purpose: This test demonstrates that we get an appropriate error message when an
                   occursCountKind expression uses a path that does not go upward
  -->
  <tdml:parserTestCase name="ocke_non_upward" root="ocke7"
    model="expressions-Embedded.dfdl.xsd" description="occursCountKind expression - DFDL-23-011R">

    <tdml:document><![CDATA[]]></tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Path expression</tdml:error>
      <tdml:error>absolute</tdml:error>
      <tdml:error>upward step</tdml:error>
      <tdml:error>ex:count</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <!--
       Test Name: ocke_single_upward
          Schema: expressions-Embedded.dfdl.xsd
          Purpose: This test demonstrates that we get an appropriate error message when an
                   occursCountKind expression uses a path that is only a single upward step
  -->
  <tdml:parserTestCase name="ocke_single_upward" root="ocke8"
    model="expressions-Embedded.dfdl.xsd" description="occursCountKind expression - DFDL-23-011R">

    <tdml:document><![CDATA[]]></tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Complex</tdml:error>
      <tdml:error>cannot be converted</tdml:error>
      <tdml:error>xs:unsignedLong</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
     Test Name: internal_space_preserved
        Schema: expressions-Embedded.dfdl.xsd
       Purpose: This test demonstrates that whitespace surrounding an expression is collapsed, but whitespace
                within the expression is preserved.
-->
  
  <tdml:parserTestCase name="internal_space_preserved" root="expr_space"
    model="expressions-Embedded.dfdl.xsd" description="">

    <tdml:document><![CDATA[2]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <expr_space>
          <dummy>2</dummy>
          <value><![CDATA[    a    b    ]]></value>
        </expr_space>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
<!--
     Test Name: internal_space_preserved2
        Schema: expressions-Embedded.dfdl.xsd
       Purpose: This test demonstrates that whitespace surrounding an expression is collapsed, but whitespace
                within the expression is preserved.
-->
  
  <tdml:parserTestCase name="internal_space_preserved2" root="expr_space2"
    model="expressions-Embedded.dfdl.xsd" description="">

    <tdml:document>
	  <tdml:documentPart type="text" replaceDFDLEntities="true"><![CDATA[2]]></tdml:documentPart>
	</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <expr_space2>
          <dummy>2</dummy>
          <value>a&#x0A;b&#x0A;c</value>
        </expr_space2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
<!--
     Test Name: internal_space_preserved3a
        Schema: expressions-Embedded.dfdl.xsd
       Purpose: This test demonstrates that in order to use newlines in an expression and
                have them preserved, one must use dfdl:property.
-->
  
  <tdml:parserTestCase name="internal_space_preserved3a" root="expr_space3"
    model="expressions-Embedded.dfdl.xsd" description="">

    <tdml:document><![CDATA[2]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <expr_space3>
          <dummy>2</dummy>
          <value><![CDATA[a            b                                    c]]></value>
        </expr_space3>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
<!--
     Test Name: internal_space_preserved3b
        Schema: expressions-Embedded.dfdl.xsd
       Purpose: This test demonstrates that in order to use newlines in an expression and
                have them preserved, one must use dfdl:property.
-->
  
  <tdml:parserTestCase name="internal_space_preserved3b" root="expr_space3b"
    model="expressions-Embedded.dfdl.xsd" description="">

    <tdml:document><![CDATA[2]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <expr_space3b>
          <dummy>2</dummy>
          <value>a&#x0A;b&#x0A;c</value>
        </expr_space3b>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
     Test Name: internal_space_preserved4
        Schema: expressions-Embedded.dfdl.xsd
       Purpose: This test demonstrates that in order to use newlines in an expression and
                have them preserved, one must use dfdl:property.
-->
  
  <tdml:parserTestCase name="internal_space_preserved4" root="expr_space5b"
    model="expressions-Embedded.dfdl.xsd" description="">

    <tdml:document><![CDATA[1blastoff]]></tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>property 'initiator'</tdml:error>
      <tdml:error>cannot start or end with the string</tdml:error>
      <tdml:error>U+0020</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
     Test Name: internal_space_not_preserved1
        Schema: expressions-Embedded.dfdl.xsd
       Purpose: This test demonstrates that when expressions appear in attribute values
       as in short form dfdl:inputValueCalc, that newlines are not preserved.
       This is unavoidable in XML. One must use dfdl:property for expressions where
       whitespace is significant.
-->
  
  <tdml:parserTestCase name="internal_space_not_preserved1" root="expr_space4"
    model="expressions-Embedded.dfdl.xsd" description="">

    <tdml:document>
	  <tdml:documentPart type="text" replaceDFDLEntities="true"><![CDATA[2]]></tdml:documentPart>
	</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <expr_space4>
          <dummy>2</dummy>
          <value><![CDATA[a b c]]></value>
        </expr_space4>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
     Test Name: internal_space_not_preserved2
        Schema: expressions-Embedded.dfdl.xsd
       Purpose: This test demonstrates that when expressions appear in attribute values
       as in short form dfdl:inputValueCalc, that newlines are not preserved.
       This is unavoidable in XML. One must use dfdl:property for expressions where
       whitespace is significant.
-->
  
  <tdml:parserTestCase name="internal_space_not_preserved2" root="expr_space5"
    model="expressions-Embedded.dfdl.xsd" description="">

    <tdml:document><![CDATA[321blastoff]]></tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>property 'initiator'</tdml:error>
      <tdml:error>cannot start or end with the string</tdml:error>
      <tdml:error>U+0020</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <tdml:defineSchema name="expression-type-errors.dfdl.xsd">

    <xs:include schemaLocation="org/apache/daffodil/xsd/DFDLGeneralFormat.dfdl.xsd"/>
    <dfdl:format ref="ex:GeneralFormat" lengthKind="delimited"
      lengthUnits="bytes" encoding="UTF-8" separator="" initiator=""
      terminator="" occursCountKind="parsed" ignoreCase="no"
      textNumberRep="standard" representation="text" />

    <xs:element name="e" dfdl:lengthKind="implicit">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="e1" type="xs:string"
            dfdl:inputValueCalc="{ 'S' }" />
          <xs:element name="e2" type="xs:int"
            dfdl:inputValueCalc="{ 2 }" />
          <xs:element name="e3" type="xs:int"
            dfdl:inputValueCalc="{ ../ex:e2 + ../ex:e1 }" /> <!-- type error adding string to int is n.g. -->
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="f" dfdl:lengthKind="implicit">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="e3" type="xs:int"
            dfdl:inputValueCalc="{ 2.5 }" /> <!-- type error as result is not int. -->
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="g" dfdl:lengthKind="implicit">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="e1" type="xs:string"
            dfdl:inputValueCalc="{ 'notAnInt' }" />
          <xs:element name="e3" type="xs:int"
            dfdl:inputValueCalc="{ xs:int(../ex:e1) }" /> <!-- type error -->
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="h" dfdl:lengthKind="implicit">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="e1" type="xs:string"
            dfdl:inputValueCalc="{ 2.0 + 'cant add this' }" /><!-- compilation time type error -->
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="i" dfdl:lengthKind="implicit">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="e1" type="xs:boolean"
            dfdl:inputValueCalc="{ 'true' }" /><!-- no type coercion to the target type -->
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="j" dfdl:lengthKind="implicit">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="e1" type="xs:string"
            dfdl:inputValueCalc="{ 5 }" /><!-- no type coercion to the target type -->
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="k" dfdl:lengthKind="implicit">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="e1" type="xs:float"
            dfdl:inputValueCalc="{ xs:double(5) }" /><!-- no type coercion to the target type -->
        </xs:sequence>
      </xs:complexType>
    </xs:element>

  </tdml:defineSchema>

  <tdml:defineConfig name="cfg_errorOnResultCoercion">
    <daf:tunables>
      <daf:allowExpressionResultCoercion>false</daf:allowExpressionResultCoercion>
    </daf:tunables>
  </tdml:defineConfig>

  <tdml:parserTestCase name="expression_type_error1"
    root="e" model="expression-type-errors.dfdl.xsd"
    description="get a type error from an expression at runtime - DFDL-23-006R">

    <tdml:document />
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>+</tdml:error>
      <tdml:error>operator</tdml:error>
      <tdml:error>numeric</tdml:error>
      <tdml:error>string</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="expression_type_error2"
    root="f" model="expression-type-errors.dfdl.xsd"
    description="get a type error from an expression at compile time - DFDL-23-006R"
    config="cfg_errorOnResultCoercion">
    <tdml:document />
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>result type</tdml:error>
      <tdml:error>must be manually cast</tdml:error>
      <tdml:error>Double</tdml:error>
      <tdml:error>Int</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="expression_type_error3"
    root="g" model="expression-type-errors.dfdl.xsd"
    description="get a type error from an expression at runtime - DFDL-23-006R">
    <tdml:document />
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>notAnInt</tdml:error>
      <tdml:error>String</tdml:error>
      <tdml:error>Long</tdml:error>
    </tdml:errors>
    <!-- <tdml:infoset> <tdml:dfdlInfoset xmlns="http://example.com"> <g>
      <e1>notAnInt</e1>
      <e3>2</e3> </g> </tdml:dfdlInfoset> </tdml:infoset> -->
  </tdml:parserTestCase>
  
  <tdml:parserTestCase name="expression_type_error4"
    root="h" model="expression-type-errors.dfdl.xsd"
    description="get a type error from an expression at compilation time - specific requirement label TBD">
    <tdml:document />
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>operator</tdml:error>  
      <tdml:error>+</tdml:error>    
      <tdml:error>numeric</tdml:error>      
      <tdml:error>string</tdml:error>      
    </tdml:errors>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="expression_type_error5"
    root="i" model="expression-type-errors.dfdl.xsd"
    description="get a type error from an expression at compilation time - no coercion"
    config="cfg_errorOnResultCoercion">
    <tdml:document />
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>result type</tdml:error>
      <tdml:error>must be manually cast</tdml:error>
      <tdml:error>String</tdml:error>
      <tdml:error>Boolean</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="expression_type_error6"
    root="j" model="expression-type-errors.dfdl.xsd"
    description="get a type error from an expression at compilation time - no coercion"
    config="cfg_errorOnResultCoercion">
    <tdml:document />
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>result type</tdml:error>
      <tdml:error>must be manually cast</tdml:error>
      <tdml:error>Int</tdml:error>
      <tdml:error>String</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="expression_type_error7"
    root="k" model="expression-type-errors.dfdl.xsd"
    description="get a type error from an expression at compilation time - no coercion"
    config="cfg_errorOnResultCoercion">
    <tdml:document />
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>result type</tdml:error>
      <tdml:error>must be manually cast</tdml:error>
      <tdml:error>Double</tdml:error>
      <tdml:error>Float</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <tdml:defineSchema name="elementFormWithWhitespace">

    <xs:include schemaLocation="org/apache/daffodil/xsd/DFDLGeneralFormat.dfdl.xsd"/>
    <dfdl:format ref="ex:GeneralFormat" lengthKind="delimited"
      lengthUnits="bytes" encoding="US-ASCII" initiator=""
      terminator="" occursCountKind="parsed" ignoreCase="no"
      textNumberRep="standard" representation="text">

      <dfdl:property name="separator"> { fn:concat("1", "2") } </dfdl:property>

    </dfdl:format>

    <xs:element name="e1" dfdl:lengthKind="implicit">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="e2" type="xs:int" maxOccurs="unbounded"
            dfdl:lengthKind="delimited"  />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

  </tdml:defineSchema>

  <!--
     Test Name: element_long_form_whitespace
        Schema: elementFormWithWhitespace
          Root: e1
       Purpose: This test demonstrates that whitespace in an element form before or after braces is legal.
-->

  <tdml:parserTestCase name="element_long_form_whitespace" root="e1"
    model="elementFormWithWhitespace" description="Section 6 - DFDL Expressions - DFDL-06-078R">

    <tdml:document>3512446</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e1>
          <ex:e2>35</ex:e2>
          <ex:e2>446</ex:e2>
        </ex:e1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <tdml:defineSchema name="unknown-prefix">
    <xs:include schemaLocation="org/apache/daffodil/xsd/DFDLGeneralFormat.dfdl.xsd"/>
    <dfdl:format ref="ex:GeneralFormat" />
    <xs:element name="theElementName" type="xs:int"
      dfdl:inputValueCalc="{ theUnknownPrefix:x }" />
  </tdml:defineSchema>

  <tdml:parserTestCase name="expression_unknown_prefix"
    root="theElementName" model="unknown-prefix"
    description="get compilation time error due to unknown prefix - DFDL-2-001R requirement makes a reference to this test -Assigned to requirement DFDL-23-011R">
    <tdml:document />
    <tdml:errors>
      <tdml:error>Schema Definition</tdml:error>
      <tdml:error>theUnknownPrefix</tdml:error>
      <tdml:error>theElementName</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <!--- begin ssustrich's test -->

  <tdml:defineSchema name="expresion_path_error">
    <xs:include schemaLocation="org/apache/daffodil/xsd/DFDLGeneralFormat.dfdl.xsd"/>
    <dfdl:format ref="ex:GeneralFormat" />

    <xs:element name="e1">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="reps" type="xs:int"
            dfdl:representation="binary" dfdl:lengthKind="implicit" />
          <xs:element name="scale" type="xs:int"
            dfdl:representation="binary" dfdl:lengthKind="implicit" />
          <xs:element name="s1" type="xs:string"
            dfdl:lengthKind="explicit" dfdl:length="{1}"
            dfdl:occursCount="{ ../../ex:reps * /ex:e1/ex:scale}"
            dfdl:occursCountKind="expression" minOccurs="0" maxOccurs="unbounded" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

  </tdml:defineSchema>

  <tdml:parserTestCase name="expresion_bad_path_to_element"
    root="e1" model="expresion_path_error"
    description="very simple occursCountKind expression - DFDL-23-011R">

    <tdml:document>
      <!-- two binary integers get multiplied 2x2=4 -->
      <tdml:documentPart type="byte">00000002 00000002
			</tdml:documentPart>
      <!-- followed by that many characters, each is an element of the array -->
      <tdml:documentPart type="text">abcd</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Relative path</tdml:error>
      <tdml:error>past root</tdml:error>
      <tdml:error>../../ex:reps * /ex:e1/ex:scale</tdml:error>
    </tdml:errors>

    <!-- <tdml:infoset> <tdml:dfdlInfoset> <ex:e1> <ex:reps>2</ex:reps> <ex:scale>2</ex:scale>
      <ex:s1>a</ex:s1> <ex:s1>b</ex:s1> <ex:s1>c</ex:s1> <ex:s1>d</ex:s1>
      </ex:e1>
      </tdml:dfdlInfoset> </tdml:infoset> -->
  </tdml:parserTestCase>


  <!--- end ssustrich's test -->

  <tdml:defineSchema name="v">
    <xs:include schemaLocation="org/apache/daffodil/xsd/DFDLGeneralFormat.dfdl.xsd"/>
    <dfdl:format ref="ex:GeneralFormat" />
    <xs:element name="e">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="cnt" type="xs:int"
            dfdl:lengthKind="delimited" />
          <xs:element name="a" minOccurs="0" maxOccurs="unbounded"
            dfdl:occursCountKind="expression" dfdl:occursCount="{ xs:int(../ex:cnt) }">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="v" type="xs:int"
                  dfdl:inputValueCalc="{ dfdl:occursIndex() }" />
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="f">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="cnt1" type="xs:int"
            dfdl:lengthKind="delimited" dfdl:terminator=";" />
          <xs:element name="a" minOccurs="0" maxOccurs="unbounded"
            dfdl:occursCountKind="expression" dfdl:occursCount="{ xs:int(../ex:cnt1) }">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="v" type="xs:int"
                  dfdl:inputValueCalc="{ dfdl:occursIndex() }" />
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="cnt2" type="xs:int"
            dfdl:lengthKind="delimited" />
          <xs:element name="b" minOccurs="0" maxOccurs="unbounded"
            dfdl:occursCountKind="expression" dfdl:occursCount="{ xs:int(../ex:cnt2) }">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="v" type="xs:int"
                  dfdl:inputValueCalc="{ dfdl:occursIndex() }" />
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="g">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="cnt1" type="xs:int"
            dfdl:lengthKind="delimited" dfdl:terminator=";" />
          <xs:element name="a" minOccurs="0" maxOccurs="unbounded"
            dfdl:occursCountKind="expression" dfdl:occursCount="{ xs:int(../ex:cnt1) }">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="v" type="xs:int"
                  dfdl:inputValueCalc="{ dfdl:occursIndex() }" />
                <xs:element name="cnt2" type="xs:int"
                  dfdl:lengthKind="delimited" dfdl:terminator=";" />
                <xs:element name="b" minOccurs="0" maxOccurs="unbounded"
                  dfdl:occursCountKind="expression" dfdl:occursCount="{ xs:int(../ex:cnt2) }">
                  <xs:complexType>
                    <xs:sequence>
                      <xs:element name="w" type="xs:int"
                        dfdl:inputValueCalc="{ dfdl:occursIndex() }" />
                    </xs:sequence>
                  </xs:complexType>
                </xs:element>
              </xs:sequence>
            </xs:complexType>
          </xs:element>

        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="h">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="cnt" type="xs:int"
            dfdl:lengthKind="delimited" />
          <xs:element name="a" minOccurs="0" maxOccurs="unbounded"
            dfdl:occursCountKind="expression" dfdl:occursCount="{ xs:int(../ex:cnt) }">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="v" type="xs:int"
                  dfdl:inputValueCalc="{ if (dfdl:occursIndex() mod 2 eq 1) then 0 else dfdl:occursIndex() }" />
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="noFunc">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="err" type="xs:int"
            dfdl:inputValueCalc="{ dfdl:notAFunction(1, 2, 3) }" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="constantFunction">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="six" type="xs:int"
            dfdl:length="{ fn:string-length('123456') }"
            dfdl:lengthKind="explicit"
            dfdl:textNumberPattern="######" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

  </tdml:defineSchema>

  <tdml:parserTestCase name="nonFunctionIsDetected"
    root="noFunc" model="v"
    description="Schema definition error in general syntax of DFDL expression - DFDL-23-063R">

    <tdml:document />

    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>notAFunction</tdml:error>
      <tdml:error>unsupported</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="constantFunction1"
    root="constantFunction" model="v"
    description="Use of fn:string-length() - DFDL-23-101R">

    <tdml:document>999999</tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <constantFunction>
          <six>999999</six>
        </constantFunction>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>

  <tdml:parserTestCase name="dfdlPosition1" root="e"
    model="v" description="Use of dfdl:occursIndex() - DFDL-23-134R">

    <tdml:document>1</tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e>
          <cnt>1</cnt>
          <a>
            <v>1</v>
          </a>
        </e>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="dfdlPosition2" root="e"
    model="v" description="Use of dfdl:occursIndex() - DFDL-23-134R">

    <tdml:document>2</tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e>
          <cnt>2</cnt>
          <a>
            <v>1</v>
          </a>
          <a>
            <v>2</v>
          </a>
        </e>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="dfdlPosition3" root="f"
    model="v" description="Use of dfdl:occursIndex() - DFDL-23-134R">

    <tdml:document>2;2</tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <f>
          <cnt1>2</cnt1>
          <a>
            <v>1</v>
          </a>
          <a>
            <v>2</v>
          </a>
          <cnt2>2</cnt2>
          <b>
            <v>1</v>
          </b>
          <b>
            <v>2</v>
          </b>
        </f>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="dfdlPosition4" root="g"
    model="v" description="nested array case. Tests indexes are kept independently.">

    <tdml:document><![CDATA[2;2;2;]]></tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <g>
          <cnt1>2</cnt1>
          <a>
            <v>1</v>
            <cnt2>2</cnt2>
            <b>
              <w>1</w>
            </b>
            <b>
              <w>2</w>
            </b>
          </a>
          <a>
            <v>2</v>
            <cnt2>2</cnt2>
            <b>
              <w>1</w>
            </b>
            <b>
              <w>2</w>
            </b>
          </a>

        </g>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="dfdlPosition5" root="h"
    model="v">

    <tdml:document>6</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <h>
          <cnt>6</cnt>
          <a>
            <v>0</v>
          </a>
          <a>
            <v>2</v>
          </a>
          <a>
            <v>0</v>
          </a>
          <a>
            <v>4</v>
          </a>
          <a>
            <v>0</v>
          </a>
          <a>
            <v>6</v>
          </a>
        </h>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <tdml:defineSchema name="selfReferencingExpression">
  <xs:include schemaLocation="org/apache/daffodil/xsd/DFDLGeneralFormat.dfdl.xsd"/>
  <dfdl:format ref="ex:GeneralFormat" />

  <xs:simpleType name="cnt1">
    <xs:restriction base="xs:int">
      <xs:minInclusive value="0"/>
      <xs:maxInclusive value="2"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:element name="sr1">
    <xs:complexType>
      <xs:sequence>
        <xs:element name="cnt" type="xs:int" dfdl:lengthKind="delimited" />
        <xs:sequence>
          <xs:element name="v" type="ex:cnt1"
                  dfdl:inputValueCalc="{ if (dfdl:checkConstraints(.)) then xs:int(../ex:cnt) else -1 }" />
        </xs:sequence>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <xs:element name="sr2">
    <xs:complexType>
      <xs:sequence>
        <xs:element name="cnt" type="xs:int" dfdl:lengthKind="delimited" />
        <xs:sequence>
          <xs:element name="v" type="xs:int" dfdl:lengthKind="explicit" dfdl:length="{.}" />
        </xs:sequence>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <xs:element name="sr3">
    <xs:complexType>
      <xs:sequence>
        <xs:element name="cnt" type="xs:int" dfdl:lengthKind="delimited" />
        <xs:sequence>
          <xs:element name="v" type="ex:cnt1"
                dfdl:inputValueCalc="{ dfdl:checkConstraints(if(../ex:cnt eq 0) then ../ex:cnt else .) }" />
        </xs:sequence>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  </tdml:defineSchema>

  <tdml:defineSchema name="checkConstraints">
    <xs:include schemaLocation="org/apache/daffodil/xsd/DFDLGeneralFormat.dfdl.xsd"/>
    <dfdl:format ref="ex:GeneralFormat" />

    <xs:element name="e2" dfdl:lengthKind="delimited">
      <xs:annotation>
        <xs:appinfo source="http://www.ogf.org/dfdl/">
          <dfdl:assert test="{ dfdl:checkConstraints(.) }"
            message="Assertion failed for dfdl:checkConstraints(.)" />
        </xs:appinfo>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:int">
          <xs:pattern value="[0-9]+" />
        </xs:restriction>
      </xs:simpleType>
    </xs:element>

    <xs:element name="e3" dfdl:lengthKind="delimited">
      <xs:annotation>
        <xs:appinfo source="http://www.ogf.org/dfdl/">
          <dfdl:assert test="{ dfdl:checkConstraints(.) }"
            message="Assertion failed for dfdl:checkConstraints(.)" />
        </xs:appinfo>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="ex:st1">
        </xs:restriction>
      </xs:simpleType>
    </xs:element>
    <xs:element name="e4" dfdl:lengthKind="delimited">
      <xs:annotation>
        <xs:appinfo source="http://www.ogf.org/dfdl/">
          <dfdl:assert test="{ dfdl:checkConstraints(.) }"
            message="Assertion failed for dfdl:checkConstraints(.)" />
        </xs:appinfo>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="ex:st1">
          <xs:pattern value="1" />
        </xs:restriction>
      </xs:simpleType>
    </xs:element>
    <xs:element name="e5">
      <xs:complexType>
        <xs:sequence dfdl:initiatedContent="no"
          dfdl:separatorPosition="infix" dfdl:separator=",">
          <xs:element name="a" minOccurs="0" maxOccurs="3"
            type="xs:int" dfdl:occursCountKind="parsed" dfdl:lengthKind="delimited">
            <xs:annotation>
              <xs:appinfo source="http://www.ogf.org/dfdl/">
                <dfdl:assert test="{ dfdl:checkConstraints(.) }"
                  message="Assertion failed for dfdl:checkConstraints(.)" />
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    <xs:element name="e6">
      <xs:complexType>
        <xs:sequence dfdl:initiatedContent="no"
          dfdl:separatorPosition="infix" dfdl:separator=",">
          <xs:element name="a" minOccurs="0" maxOccurs="unbounded"
            type="xs:int" dfdl:occursCountKind="parsed" dfdl:lengthKind="delimited">
            <xs:annotation>
              <xs:appinfo source="http://www.ogf.org/dfdl/">
                <dfdl:assert test="{ dfdl:checkConstraints(.) }"
                  message="Assertion failed for dfdl:checkConstraints(.)" />
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    <xs:element name="e7" type="ex:ct1">
      <xs:annotation>
        <xs:appinfo source="http://www.ogf.org/dfdl/">
          <dfdl:assert test="{ dfdl:checkConstraints(.) }"
            message="Assertion failed for dfdl:checkConstraints(.)" />
        </xs:appinfo>
      </xs:annotation>
    </xs:element>

    <xs:simpleType name="st1">
      <xs:restriction base="ex:st2">
        <xs:pattern value="[0-9]+" />
      </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="st2">
      <xs:restriction base="ex:st3">
        <xs:pattern value="[0-9]{3}" />
      </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="st3">
      <xs:restriction base="xs:string">
        <xs:pattern value="[0-9]*" />
      </xs:restriction>
    </xs:simpleType>

    <xs:complexType name="ct1">
      <xs:sequence>
        <xs:element name="string1" type="xs:string" dfdl:lengthKind="explicit" dfdl:length="2" />
	<xs:element name="string2" type="xs:string" dfdl:lengthKind="explicit" dfdl:length="2" />
      </xs:sequence>
    </xs:complexType>
  </tdml:defineSchema>

<!-- 
     Test Name: dfdlCheckConstraintsSelfReference1
     Schema: selfReferencingExpression
     Purpose: This tests the error in the case of a self referencing checkConstraints without a value
-->

  <tdml:parserTestCase name="dfdlSelfReferencingExpression1"
                       root="sr1" model="selfReferencingExpression" description="DFDL-23-135R">
    <tdml:document>1</tdml:document>
    <tdml:errors>
      <tdml:error>Expression Evaluation Error</tdml:error>
      <tdml:error>Self referencing</tdml:error>
      <tdml:error>does not have a value</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
     Test Name: dfdlCheckConstraintsSelfReference2
     Schema: selfReferencingExpression
     Purpose: This tests the error in the case of a self referencing dfdl:length without a value
-->

  <tdml:parserTestCase name="dfdlSelfReferencingExpression2"
                       root="sr2" model="selfReferencingExpression" description="DFDL-23-135R">
    <tdml:document>1</tdml:document>
    <tdml:errors>
      <tdml:error>Expression Evaluation Error</tdml:error>
      <tdml:error>Self referencing</tdml:error>
      <tdml:error>does not have a value</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <!--
     Test Name: dfdlCheckConstraintsSelfReference3
     Schema: selfReferencingExpression
     Purpose: This tests the error in the case of a self reference without a value
  -->

  <tdml:parserTestCase name="dfdlSelfReferencingExpression3"
                       root="sr3" model="selfReferencingExpression" description="DFDL-23-135R">
    <tdml:document>1</tdml:document>
    <tdml:errors>
      <tdml:error>Expression Evaluation Error</tdml:error>
      <tdml:error>Self referencing</tdml:error>
      <tdml:error>does not have a value</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <tdml:defineSchema name="repeatFlags">
    <xs:include schemaLocation="org/apache/daffodil/xsd/DFDLGeneralFormat.dfdl.xsd"/>
    <dfdl:format ref="ex:GeneralFormat" />
    <xs:element name="e">
      <xs:complexType>
        <xs:sequence dfdl:separator="">
          <xs:element name="present" type="xs:int"
            dfdl:lengthKind="explicit" dfdl:length="1" />
          <xs:element name="s" minOccurs="0" maxOccurs="1"
            dfdl:occursCountKind="expression" dfdl:occursCount="{ ../ex:present }">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="r" minOccurs="1" maxOccurs="unbounded"
                  dfdl:occursCountKind="parsed">
                  <xs:complexType>
                    <xs:sequence>
                      <xs:annotation>
                        <xs:appinfo source="http://www.ogf.org/dfdl/">
                          <dfdl:discriminator><![CDATA[{ 
                                    if(dfdl:occursIndex() eq 1 ) then fn:true()
                                    else
                                    ../ex:r[dfdl:occursIndex() - 1]/ex:more eq 1 
                          }]]></dfdl:discriminator>
                        </xs:appinfo>
                      </xs:annotation>
                      <xs:element name="more" type="xs:int"
                        dfdl:lengthKind="explicit" dfdl:length="1" />
                      <xs:element name="c" type="xs:string"
                        dfdl:lengthKind="explicit" dfdl:length="1" />
                    </xs:sequence>
                  </xs:complexType>
                </xs:element>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="extra" type="xs:string" dfdl:lengthKind="delimited"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>


  </tdml:defineSchema>

<!--
     Test Name: repeatFlags1
        Schema: repeatFlags
       Purpose: This test demonstrates the use of presence and repeat flags. In this case, the presence flag is 0,
                so there are no occurrences.
-->

  <tdml:parserTestCase name="repeatFlags1" model="repeatFlags" description="Section 23 - Uses of Expression Language - DFDL-23-003R"
    root="e">
    <tdml:document>0</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e>
          <present>0</present>
          <extra></extra>
        </e>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
     Test Name: repeatFlags2
        Schema: repeatFlags
       Purpose: This test demonstrates the use of presence and repeat flags. In this case, the presence flag is 1,
                so there is at least one occurrence. The repeat flag is 0, so there is only one occurrence, which
                in this case is the character "A".
-->

  <tdml:parserTestCase name="repeatFlags2" model="repeatFlags" description="Section 23 - Uses of Expression Language - DFDL-23-003R"
    root="e">
    <tdml:document>10A</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e>
          <present>1</present>
          <s>
            <r>
              <more>0</more>
              <c>A</c>
            </r>
          </s>
          <extra></extra>
        </e>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
     Test Name: repeatFlags3
        Schema: repeatFlags
       Purpose: This test demonstrates the use of presence and repeat flags. In this case, the presence flag is 1,
                so there is at least one occurrence. The repeat flag is 1, so there is at least one more, etc.
-->

  <tdml:parserTestCase name="repeatFlags3" model="repeatFlags" description="Section 23 - Uses of Expression Language - DFDL-23-003R"
    root="e">
    <tdml:document>11A1B1C0D</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e>
          <present>1</present>
          <s>
            <r>
              <more>1</more>
              <c>A</c>
            </r>
            <r>
              <more>1</more>
              <c>B</c>
            </r>
            <r>
              <more>1</more>
              <c>C</c>
            </r>
            <r>
              <more>0</more>
              <c>D</c>
            </r>
          </s>
          <extra></extra>
        </e>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
     Test Name: repeatFlags4
        Schema: repeatFlags
       Purpose: This test demonstrates the use of presence and repeat flags. In this case, though the fourth repeat bit
                is 0, there is more data, which should be caught by the "extra" element and not included in the primary
                element tree
-->

  <tdml:parserTestCase name="repeatFlags4" model="repeatFlags" description="Section 23 - Uses of Expression Language - DFDL-23-003R"
    root="e">
    <tdml:document>11A1B1C0D1E1F0G</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e>
          <present>1</present>
          <s>
            <r>
              <more>1</more>
              <c>A</c>
            </r>
            <r>
              <more>1</more>
              <c>B</c>
            </r>
            <r>
              <more>1</more>
              <c>C</c>
            </r>
            <r>
              <more>0</more>
              <c>D</c>
            </r>
          </s>
          <extra>1E1F0G</extra>
        </e>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
     Test Name: repeatFlags5
        Schema: repeatFlags
       Purpose: This test demonstrates the use of presence and repeat flags. In this case, the presence flag is 0, but there
                is still data in the document. This data should be consumed by the "extra" element and not included in the primary
                element tree
-->

  <tdml:parserTestCase name="repeatFlags5" model="repeatFlags" description="Section 23 - Uses of Expression Language - DFDL-23-003R"
    root="e">
    <tdml:document>01A1B1C1D1E1F0G</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e>
          <present>0</present>
          <extra>1A1B1C1D1E1F0G</extra>
        </e>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <tdml:defineSchema name="repeatBitFlags">
    <xs:include schemaLocation="org/apache/daffodil/xsd/DFDLGeneralFormat.dfdl.xsd"/>
    <dfdl:format ref="ex:GeneralFormat" lengthUnits="bits"
      lengthKind="implicit" alignment="1" alignmentUnits="bits"
      representation="binary" byteOrder="bigEndian" />

    <xs:element name="bit1" type="xs:unsignedInt"
      dfdl:lengthKind="explicit" dfdl:length="1" dfdl:byteOrder="littleEndian" />

    <!-- intended for use in arrays with occursCountKind='parsed' environments -->
    <xs:group name="more">
      <xs:sequence>
        <xs:annotation>
          <xs:appinfo source="http://www.ogf.org/dfdl/">
            <dfdl:discriminator><![CDATA[{ 
                                    if (dfdl:occursIndex() eq 1 )
                                    then fn:true()
                                    else 
                                    ../ex:r[dfdl:occursIndex() - 1]/ex:more eq 1 
                          }]]></dfdl:discriminator>
          </xs:appinfo>
        </xs:annotation>
        <xs:element name="more" type="xs:unsignedInt"
          dfdl:lengthKind="explicit" dfdl:length="1" />
      </xs:sequence>
    </xs:group>

    <xs:element name="e">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="present" type="xs:unsignedInt"
            dfdl:lengthKind="explicit" dfdl:length="1" />
          <xs:element name="s" minOccurs="0" maxOccurs="1"
            dfdl:occursCountKind="expression" dfdl:occursCount="{ ../ex:present }">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="r" minOccurs="1" maxOccurs="unbounded"
                  dfdl:occursCountKind="parsed">
                  <xs:complexType>
                    <xs:sequence>
                      <xs:group ref="ex:more" />
                      <xs:element name="c" type="xs:unsignedInt"
                        dfdl:lengthKind="explicit" dfdl:length="3" />
                    </xs:sequence>
                  </xs:complexType>
                </xs:element>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="f">
      <xs:complexType>
        <xs:sequence dfdl:separator="">
          <xs:element name="present" type="xs:unsignedInt"
            dfdl:lengthKind="explicit" dfdl:length="1" />
          <xs:element name="s" minOccurs="0" maxOccurs="1"
            dfdl:occursCountKind="expression" dfdl:occursCount="{ ../ex:present }">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="r" minOccurs="1" maxOccurs="unbounded"
                  dfdl:occursCountKind="parsed">
                  <xs:complexType>
                    <xs:sequence>
                      <xs:group ref="ex:more" />
                      <xs:element name="c" type="xs:unsignedInt"
                        dfdl:lengthKind="explicit" dfdl:length="3" />
                    </xs:sequence>
                  </xs:complexType>
                </xs:element>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="extra" minOccurs="0" type="xs:unsignedInt" dfdl:lengthKind="explicit" dfdl:length="8"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

  </tdml:defineSchema>

  <tdml:parserTestCase name="bit1" model="repeatBitFlags"
    root="bit1">
    <tdml:document>
      <tdml:documentPart type="bits">1</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <bit1>1</bit1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
     Test Name: repeatBitFlags1
        Schema: repeatBitFlags
       Purpose: This test demonstrates the use of presence and repeat bits. In this case, the presence bit is 0,
                so there are no occurrences.
-->

  <tdml:parserTestCase name="repeatBitFlags1" model="repeatBitFlags" description="Section 23 - Uses of Expression Language - DFDL-23-003R"
    root="e">
    <tdml:document>
      <tdml:documentPart type="bits">0</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e>
          <present>0</present>
        </e>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
     Test Name: repeatBitFlags2
        Schema: repeatBitFlags
       Purpose: This test demonstrates the use of presence and repeat bits. In this case, the presence bit is 1,
                so there is at least one occurrence. The repeat bit is zero, so there will only be one occurrence,
                which in this case is the binary representation (in 3 bits) of 1.
-->

  <tdml:parserTestCase name="repeatBitFlags2" model="repeatBitFlags" description="Section 23 - Uses of Expression Language - DFDL-23-003R"
    root="e">
    <tdml:document>
      <tdml:documentPart type="bits">1 0 001</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e>
          <present>1</present>
          <s>
            <r>
              <more>0</more>
              <c>1</c>
            </r>
          </s>
        </e>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
     Test Name: repeatBitFlags3
        Schema: repeatBitFlags
       Purpose: This test demonstrates the use of presence and repeat bits. In this case, the presence bit is 1,
                so there is at least one occurrence. The repeat bit is 1, so after this occurrence there will be at least one more.
                After the first occurrence of the c element, the next repeat bit is also 1, followed by the next occurrence, etc.
                Eventually the repeat bit is 0, so the last bit of data is consumed, and parsing stops.
-->

  <tdml:parserTestCase name="repeatBitFlags3" model="repeatBitFlags" description="Section 23 - Uses of Expression Language - DFDL-23-003R"
    root="e">
    <tdml:document>
      <tdml:documentPart type="bits">1 1 001 1 010 1 011 0 100</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e>
          <present>1</present>
          <s>
            <r>
              <more>1</more>
              <c>1</c>
            </r>
            <r>
              <more>1</more>
              <c>2</c>
            </r>
            <r>
              <more>1</more>
              <c>3</c>
            </r>
            <r>
              <more>0</more>
              <c>4</c>
            </r>
          </s>
        </e>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
     Test Name: repeatBitFlags4
        Schema: repeatBitFlags
       Purpose: This test demonstrates the use of presence and repeat bits. In this case, the presence bit is 1,
                so there is at least one occurrence. The repeat bit is zero, so there will only be one occurrence.
                However, the document has extra data and the test runner should complain that there is leftover data.
-->

  <tdml:parserTestCase name="repeatBitFlags4" model="repeatBitFlags" description="Section 23 - Uses of Expression Language - DFDL-23-003R"
    root="e">
    <tdml:document>
      <tdml:documentPart type="bits">1 0 001 0 010</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Left over data</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
     Test Name: repeatBitFlags5
        Schema: repeatBitFlags
       Purpose: This test demonstrates the use of presence and repeat bits. In this case, the presence bit is 1,
                so there is at least one occurrence. The repeat bit is zero, so there will only be one occurrence.
                However, the document has extra data which should be parsed as the "extra" element.
-->

  <tdml:parserTestCase name="repeatBitFlags5" model="repeatBitFlags" description="Section 23 - Uses of Expression Language - DFDL-23-003R"
    root="f">
    <tdml:document>
      <tdml:documentPart type="bits">1 1 001 0 010 1 101 0 111</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <f>
          <present>1</present>
          <s>
            <r>
              <more>1</more>
              <c>1</c>
            </r>
            <r>
              <more>0</more>
              <c>2</c>
            </r>
          </s>
          <extra>215</extra>
        </f>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
     Test Name: repeatBitFlags6
        Schema: repeatBitFlags
       Purpose: This test demonstrates the use of presence and repeat bits. In this case, the presence bit is 1,
                so there is at least one occurrence. The repeat bit is 1, so there will be another occurrence, and so forth.
                In this case the optional extra element should not be needed.
-->

  <tdml:parserTestCase name="repeatBitFlags6" model="repeatBitFlags" description="Section 23 - Uses of Expression Language - DFDL-23-003R"
    root="f">
    <tdml:document>
      <tdml:documentPart type="bits">1 1 001 1 010 1 101 0 111</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <f>
          <present>1</present>
          <s>
            <r>
              <more>1</more>
              <c>1</c>
            </r>
            <r>
              <more>1</more>
              <c>2</c>
            </r>
            <r>
              <more>1</more>
              <c>5</c>
            </r>
            <r>
              <more>0</more>
              <c>7</c>
            </r>
          </s>
        </f>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
<!--
     Test Name: invalid_enum_1
        Schema: expressions_broken.dfdl.xsd
       Purpose: This test demonstrates that it is a schema definition error if a value other than one of the 
                enumerated values is specified for a schema property.
-->

  <tdml:parserTestCase name="invalid_enum_1" model="expressions_broken.dfdl.xsd" 
    description="Section 06 - DFDL Expressions - DFDL-6-083R" root="e1">
    <tdml:document>
      <tdml:documentPart type="text">word</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Value 'hieroglyphs' is not facet-valid with respect to enumeration</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
     Test Name: invalid_enum_2
        Schema: expressions_broken_2.dfdl.xsd
       Purpose: This test demonstrates that it is a schema definition error if the case of the specified value 
                does not match the expected case for the enumeration.
-->

  <tdml:parserTestCase name="invalid_enum_2" model="expressions_broken_2.dfdl.xsd" 
    description="Section 06 - DFDL Expressions - DFDL-6-084R" root="e1">
    <tdml:document>
      <tdml:documentPart type="text">word</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Value 'TExT' is not facet-valid with respect to enumeration</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
     Test Name: invalid_enum_3
        Schema: expressions_broken_3.dfdl
       Purpose: This test demonstrates that enumerations are strings unless otherwise stated. 
-->

  <tdml:parserTestCase name="invalid_enum_3" model="expressions_broken_3.dfdl.xsd" 
    description="Section 06 - DFDL Expressions - DFDL-6-085R" root="e1">
    <tdml:document>
      <tdml:documentPart type="text">word</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Value '0' is not facet-valid with respect to enumeration</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <tdml:defineSchema name="expressionRules">

    <xs:include schemaLocation="org/apache/daffodil/xsd/DFDLGeneralFormat.dfdl.xsd"/>
    <dfdl:format ref="ex:GeneralFormat" lengthKind="delimited"
      lengthUnits="bytes" encoding="US-ASCII" separator="" initiator=""
      terminator="" occursCountKind="parsed" ignoreCase="no"
      textNumberRep="standard" representation="text" />

    <xs:element name="e_01" dfdl:lengthKind="implicit">
      <xs:complexType>
        <xs:sequence dfdl:separator=".">
          <xs:element name="e1" type="xs:int"
            dfdl:lengthKind="explicit" dfdl:length="1" />
          <xs:element name="e2" type="xs:string"
            dfdl:lengthKind="delimited" dfdl:inputValueCalc="{fn:concat(../ex:e1, '}')}" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e_02" dfdl:lengthKind="implicit">
      <xs:complexType>
        <xs:sequence dfdl:separator=".">
          <xs:element name="e1" type="xs:int"
            dfdl:lengthKind="explicit" dfdl:length="1" />
          <xs:element name="e2" type="xs:string"
            dfdl:lengthKind="delimited" dfdl:inputValueCalc="{'}'}" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <dfdl:defineVariable name="v_literal_bracket" type="xs:string"
      defaultValue="{{"/>
    <dfdl:defineVariable name="v_literal_bracket2" type="xs:string"
      defaultValue="{{}"/>
 
    <xs:element name="e_03" dfdl:lengthKind="implicit">
      <xs:complexType>
        <xs:sequence dfdl:separator=".">
          <xs:element name="e1" type="xs:int"
            dfdl:lengthKind="explicit" dfdl:length="1" />
          <xs:element name="e2" type="xs:string"
            dfdl:lengthKind="delimited" dfdl:inputValueCalc="{ $ex:v_literal_bracket }" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e_04" dfdl:lengthKind="implicit">
      <xs:complexType>
        <xs:sequence dfdl:separator=".">
          <xs:element name="e1" type="xs:int"
            dfdl:lengthKind="explicit" dfdl:length="1" />
          <xs:element name="e2" type="xs:string"
            dfdl:lengthKind="delimited" dfdl:inputValueCalc="{ $ex:v_literal_bracket2 }" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e_05" dfdl:lengthKind="implicit">
      <xs:complexType>
        <xs:sequence dfdl:separator="{{ {{ [">
          <xs:element name="e1" type="xs:int" minOccurs="2" maxOccurs="6" dfdl:lengthKind="delimited" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e_06" dfdl:lengthKind="implicit">
      <xs:complexType>
        <xs:sequence dfdl:separator="{ {{ [">
          <xs:element name="e1" type="xs:int" minOccurs="2" maxOccurs="6" dfdl:lengthKind="delimited" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

  </tdml:defineSchema>

<!--
     Test Name: expressionRules01
        Schema: expressionRules
          Root: e_01
       Purpose: This test demonstrates that { used anywhere but the first position in an expression is treated as a literal 
-->
  
  <tdml:parserTestCase name="expressionRules01" root="e_01"
    model="expressionRules" description="Section 6 - DFDL Expressions - DFDL-06-076R">

    <tdml:document>3</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e_01>
          <ex:e1>3</ex:e1>
          <ex:e2>3}</ex:e2>
        </ex:e_01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
     Test Name: expressionRules02
        Schema: expressionRules
          Root: e_02
       Purpose: This test demonstrates that } used anywhere but the first position in an expression is treated as a literal 
-->
  
  <tdml:parserTestCase name="expressionRules02" root="e_02"
    model="expressionRules" description="Section 6 - DFDL Expressions - DFDL-06-077R">

    <tdml:document>3</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e_02>
          <ex:e1>3</ex:e1>
          <ex:e2>}</ex:e2>
        </ex:e_02>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
     Test Name: expressionRules03
        Schema: expressionRules
          Root: e_03
       Purpose: This test demonstrates that {{ as the first characters are treated as the literal '{' and not a DFDL expression 
-->
  
  <tdml:parserTestCase name="expressionRules03" root="e_03"
    model="expressionRules" description="Section 6 - DFDL Expressions - DFDL-06-078R">

    <tdml:document>3</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e_03>
          <ex:e1>3</ex:e1>
          <ex:e2>{</ex:e2>
        </ex:e_03>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: expressionRules04
        Schema: expressionRules
          Root: e_04
       Purpose: This test demonstrates that {{ as the first characters are treated as the literal '{' and not a DFDL expression 
-->
  
  <tdml:parserTestCase name="expressionRules04" root="e_04"
    model="expressionRules" description="Section 6 - DFDL Expressions - DFDL-06-078R">

    <tdml:document>3</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e_04>
          <ex:e1>3</ex:e1>
          <ex:e2>{}</ex:e2>
        </ex:e_04>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: expressionRules05
        Schema: expressionRules
          Root: e_05
       Purpose: This test demonstrates that {{ as the first characters are treated as the literal '{' and not a DFDL expression 
  -->
  
  <tdml:parserTestCase name="expressionRules05" root="e_05"
    model="expressionRules" description="Section 6 - DFDL Expressions - DFDL-06-078R"
    roundTrip="twoPass">

    <tdml:document>123{456{{789[123</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_05>
          <e1>123</e1>
          <e1>456</e1>
          <e1>789</e1>
          <e1>123</e1>
        </e_05>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: expressionRules06
        Schema: expressionRules
          Root: e_06
       Purpose: This test demonstrates that you need to use {{ as the first characters in order for
                it to be treated as the literal '{' and not a DFDL expression 
  -->
  
  <tdml:parserTestCase name="expressionRules06" root="e_06"
    model="expressionRules" description="Section 6 - DFDL Expressions - DFDL-06-078R">

    <tdml:document>123{456{{789[123</tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>'{ {{ [' is an unterminated expression</tdml:error>
    </tdml:errors>
    </tdml:parserTestCase>

<!--
     Test Name: regexLookahead
        Schema: newRegex 
          Root: s1
       Purpose: This test demonstrates the use of a lookahead regex to determine the length
-->
  
  <tdml:parserTestCase name="regexLookahead" root="s1"
    model="newRegex" description="Section -  - DFDL-R">

    <tdml:document>45someletters</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <s1>
          <e1>45</e1>
          <extra>someletters</extra>
        </s1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
     Test Name: regexLookaheadFail
        Schema: newRegex 
          Root: s1
       Purpose: This test demonstrates the case that a lookahead regex fails to find a match. 
       Note that for lengthKind='pattern' no match means zero length. Not an error.
-->
  
  <tdml:parserTestCase name="regexLookaheadFail" root="s1"
    model="newRegex" description="Section -  - DFDL-R">

    <tdml:document>45</tdml:document>
    <tdml:infoset>
    <tdml:dfdlInfoset>
    <s1><e1></e1><extra>45</extra></s1>
    </tdml:dfdlInfoset>
    </tdml:infoset>
 
  </tdml:parserTestCase>

<!--
     Test Name: regexLookaheadFail2
        Schema: newRegex 
          Root: s3
       Purpose: This test demonstrates that the pattern facet uses the XML Schema Regex library, which does not have lookaheads
-->
  
  <tdml:parserTestCase name="regexLookaheadFail2" root="s3"
    model="newRegex" description="Section -  - DFDL-R">

    <tdml:document>45someletters</tdml:document>
    <tdml:errors>
      <tdml:error>Assertion failed for dfdl:checkConstraints</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
     Test Name: regexCompatFail
        Schema: newRegex 
          Root: s4
       Purpose: This test
-->
  
  <tdml:parserTestCase name="regexCompatFail" root="s4"
    model="newRegex" description="Section -  - DFDL-R">

    <tdml:document>45someletters</tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>InvalidRegex</tdml:error>
      <tdml:error>not a valid regular expression</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
     Test Name: indexLimit
        Schema: csv.dfdl.xsd
       Purpose: This test attempts to find an upper-limit to array indexing within expressions.
                It parses a large csv file, hides the actual data, and prints out the 29,030th entry.
-->

  <tdml:parserTestCase name="indexLimit" model="csv_mod_hidden.dfdl.xsd" root="file"
    description="Section 23 - Uses of Expression Language - DFDL-23-003R">
    <tdml:document>
      <tdml:documentPart type="file">csv_1.6m</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <file>
          <header>
            <title>last</title>
            <title>first</title>
            <title>sigil</title>
          </header>
          <scoop>lannister</scoop>
        </file>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <tdml:defineSchema name="trueFalseTypeCorrect">
  
     <xs:include schemaLocation="org/apache/daffodil/xsd/DFDLGeneralFormat.dfdl.xsd"/>
    <dfdl:format ref="ex:GeneralFormat"/>
     
     <xs:element name="e">
     <xs:complexType>
     <xs:sequence>
     <xs:element name="x" type="xs:int" dfdl:inputValueCalc="{ 0 }"/>
     <xs:element name="f" type="xs:int" dfdl:inputValueCalc="{ if (xs:boolean(dfdlx:trace((if (xs:int(../ex:x) eq 0) then fn:true() else fn:false()), 'predicate'))) then 2 else 3 }"/>
     </xs:sequence>
     </xs:complexType>
     </xs:element>
  </tdml:defineSchema>
  
  <tdml:parserTestCase name="trueFalseTypeCorrect" model="trueFalseTypeCorrect" root="e"
    description="Test for JIRA DFDL-433 which demonstrates the use of a corrected expression.">
    <tdml:document/>
    <tdml:infoset>
    <tdml:dfdlInfoset>
    <ex:e><ex:x>0</ex:x><ex:f>2</ex:f></ex:e>
    </tdml:dfdlInfoset>
    </tdml:infoset>
    
    </tdml:parserTestCase>

  <!--
     Test Name: whitespace_expression
        Schema: expressions-Embedded.dfdl.xsd
          Root: ws_expr
       Purpose: This test demonstrates that whitespace can be preserved with daffodil entities.
-->

  <tdml:parserTestCase name="whitespace_expression" root="ws_expr"
    model="expressions-Embedded.dfdl.xsd" description="Section 6 - DFDL Expressions - DFDL-06-078R">

    <tdml:document>
	  <tdml:documentPart type="text" replaceDFDLEntities="true">3]%LF;=4]%LF;=5]%LF;=</tdml:documentPart>
	</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:ws_expr>
          <ex:e1>3</ex:e1>
          <ex:e1>4</ex:e1>
          <ex:e1>5</ex:e1>
        </ex:ws_expr>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: whitespace_expression2
        Schema: expressions-Embedded.dfdl.xsd
          Root: ws_expr2
       Purpose: This test demonstrates that whitespace will not be preserved without daffodil entities.
  -->

  <tdml:parserTestCase name="whitespace_expression2" root="ws_expr2"
    model="expressions-Embedded.dfdl.xsd" description="Section 6 - DFDL Expressions - DFDL-06-078R"
    roundTrip="twoPass">

    <tdml:document>3]4=5]</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:ws_expr2>
          <ex:e1>3</ex:e1>
          <ex:e1>4</ex:e1>
          <ex:e1>5</ex:e1>
        </ex:ws_expr2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_01
        Schema: comparisonOperators 
          Root: e1
       Purpose: This test demonstrates that only two-character versions of comparison operators are supported
  -->

  <tdml:parserTestCase name="comparison_operators_01" root="e1"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>fish,bird</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e1>
          <string1>fish</string1>
          <string2>bird</string2>
          <same>false</same>
        </e1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_02
        Schema: comparisonOperators 
          Root: e1
       Purpose: This test demonstrates that only two-character versions of comparison operators are supported
  -->

  <tdml:parserTestCase name="comparison_operators_02" root="e1"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>fish,fish</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e1>
          <string1>fish</string1>
          <string2>fish</string2>
          <same>true</same>
        </e1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_03
        Schema: comparisonOperators 
          Root: e2
       Purpose: This test demonstrates that only two-character versions of comparison operators are supported
  -->

  <tdml:parserTestCase name="comparison_operators_03" root="e2"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>fish,bird</tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Unsupported operation</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_04
        Schema: comparisonOperators 
          Root: e2
       Purpose: This test demonstrates that only two-character versions of comparison operators are supported
  -->

  <tdml:parserTestCase name="comparison_operators_04" root="e2"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>bird,bird</tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Unsupported operation</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_05
        Schema: comparisonOperators 
          Root: e3
       Purpose: This test demonstrates that only two-character versions of comparison operators are supported
  -->

  <tdml:parserTestCase name="comparison_operators_05" root="e3"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>4,700</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e3>
          <int1>4</int1>
          <int2>700</int2>
          <oneLTtwo>true</oneLTtwo>
        </e3>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_06
        Schema: comparisonOperators 
          Root: e3
       Purpose: This test demonstrates that only two-character versions of comparison operators are supported
  -->

  <tdml:parserTestCase name="comparison_operators_06" root="e3"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>700,2</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e3>
          <int1>700</int1>
          <int2>2</int2>
          <oneLTtwo>false</oneLTtwo>
        </e3>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_07
        Schema: comparisonOperators 
          Root: e4
       Purpose: This test demonstrates that only two-character versions of comparison operators are supported
  -->

  <tdml:parserTestCase name="comparison_operators_07" root="e4"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>1,5</tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Unsupported operation</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_08
        Schema: comparisonOperators 
          Root: e5
       Purpose: This test demonstrates that only two-character versions of comparison operators are supported
  -->

  <tdml:parserTestCase name="comparison_operators_08" root="e5"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1"
    roundTrip="twoPass">

    <tdml:document>7.509,7.510</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e5>
          <float1>7.509</float1>
          <float2>7.51</float2>
          <oneGTtwo>false</oneGTtwo>
        </e5>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_09
        Schema: comparisonOperators 
          Root: e5
       Purpose: This test demonstrates that only two-character versions of comparison operators are supported
  -->

  <tdml:parserTestCase name="comparison_operators_09" root="e5"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>10,9.99</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e5>
          <float1>10.0</float1>
          <float2>9.99</float2>
          <oneGTtwo>true</oneGTtwo>
        </e5>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_10
        Schema: comparisonOperators 
          Root: e6
       Purpose: This test demonstrates that only two-character versions of comparison operators are supported
  -->

  <tdml:parserTestCase name="comparison_operators_10" root="e6"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>1.5,5</tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Unsupported operation</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_11
        Schema: comparisonOperators 
          Root: e7
       Purpose: This test demonstrates that only two-character versions of comparison operators are supported
  -->

  <tdml:parserTestCase name="comparison_operators_11" root="e7"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>lemon,lemons</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e7>
          <string1>lemon</string1>
          <string2>lemons</string2>
          <notEqual>true</notEqual>
        </e7>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_12
        Schema: comparisonOperators 
          Root: e7
       Purpose: This test demonstrates that only two-character versions of comparison operators are supported
  -->

  <tdml:parserTestCase name="comparison_operators_12" root="e7"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>lemonade,lemonade</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e7>
          <string1>lemonade</string1>
          <string2>lemonade</string2>
          <notEqual>false</notEqual>
        </e7>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_13
        Schema: comparisonOperators 
          Root: e8
       Purpose: This test demonstrates that only two-character versions of comparison operators are supported
  -->

  <tdml:parserTestCase name="comparison_operators_13" root="e8"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>potayto,potahto</tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Unsupported operation</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_14
        Schema: comparisonOperators 
          Root: e9
       Purpose: This test demonstrates that only two-character versions of comparison operators are supported
  -->

  <tdml:parserTestCase name="comparison_operators_14" root="e9"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>1,-1</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e9>
          <int1>1</int1>
          <int2>-1</int2>
          <notEqual>true</notEqual>
        </e9>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_15
        Schema: comparisonOperators 
          Root: e10
       Purpose: This test demonstrates that only two-character versions of comparison operators are supported
  -->

  <tdml:parserTestCase name="comparison_operators_15" root="e10"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>5,5</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e10>
          <int1>5</int1>
          <int2>5</int2>
          <lessThanEqualTo>true</lessThanEqualTo>
        </e10>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_16
        Schema: comparisonOperators 
          Root: e10
       Purpose: This test demonstrates that only two-character versions of comparison operators are supported
  -->

  <tdml:parserTestCase name="comparison_operators_16" root="e10"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>5,10</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e10>
          <int1>5</int1>
          <int2>10</int2>
          <lessThanEqualTo>true</lessThanEqualTo>
        </e10>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_17
        Schema: comparisonOperators 
          Root: e10
       Purpose: This test demonstrates that only two-character versions of comparison operators are supported
  -->

  <tdml:parserTestCase name="comparison_operators_17" root="e10"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>50,10</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e10>
          <int1>50</int1>
          <int2>10</int2>
          <lessThanEqualTo>false</lessThanEqualTo>
        </e10>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_18
        Schema: comparisonOperators 
          Root: e11
       Purpose: This test demonstrates that only two-character versions of comparison operators are supported
  -->

  <tdml:parserTestCase name="comparison_operators_18" root="e11"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>7,7</tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Unsupported operation</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_19
        Schema: comparisonOperators 
          Root: e12
       Purpose: This test demonstrates that only two-character versions of comparison operators are supported
  -->

  <tdml:parserTestCase name="comparison_operators_19" root="e12"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>7,7</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e12>
          <int1>7</int1>
          <int2>7</int2>
          <greaterThanEqualTo>true</greaterThanEqualTo>
        </e12>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: comparison_operators_20
        Schema: comparisonOperators 
          Root: e12
       Purpose: This test demonstrates that only two-character versions of comparison operators are supported
  -->

  <tdml:parserTestCase name="comparison_operators_20" root="e12"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>9,7</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e12>
          <int1>9</int1>
          <int2>7</int2>
          <greaterThanEqualTo>true</greaterThanEqualTo>
        </e12>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_21
        Schema: comparisonOperators 
          Root: e12
       Purpose: This test demonstrates that only two-character versions of comparison operators are supported
  -->

  <tdml:parserTestCase name="comparison_operators_21" root="e12"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>9,700</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e12>
          <int1>9</int1>
          <int2>700</int2>
          <greaterThanEqualTo>false</greaterThanEqualTo>
        </e12>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_22
        Schema: comparisonOperators 
          Root: e13
       Purpose: This test demonstrates that only two-character versions of comparison operators are supported
  -->

  <tdml:parserTestCase name="comparison_operators_22" root="e13"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>7,7</tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Unsupported operation</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
     Test Name: attribute_axis_01
        Schema: attributeAxis
          Root: e1
       Purpose: This test demonstrates that the attribute axis is not supported in path expressions
  -->

  <tdml:parserTestCase name="attribute_axis_01" root="e1"
    model="attributeAxis" description="Section 23 - DFDL Expressions - DFDL-23-066R">

    <tdml:document>NIL</tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>attribute</tdml:error>
      <tdml:error>unsupported axis</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
     Test Name: attribute_axis_02
        Schema: attributeAxis
          Root: e2
       Purpose: This test demonstrates that the attribute axis is not supported in path expressions
  -->

  <tdml:parserTestCase name="attribute_axis_02" root="e2"
    model="attributeAxis" description="Section 23 - DFDL Expressions - DFDL-23-066R">

    <tdml:document>NIL</tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>attribute</tdml:error>
      <tdml:error>unsupported axis</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
     Test Name: attribute_axis_03
        Schema: attributeAxis
          Root: e3
       Purpose: This test demonstrates that the attribute axis is not supported in path expressions
  -->

  <tdml:parserTestCase name="attribute_axis_03" root="e3"
    model="attributeAxis" description="Section 23 - DFDL Expressions - DFDL-23-066R">

    <tdml:document>NIL</tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>attribute</tdml:error>
      <tdml:error>unsupported axis</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
     Test Name: asterisk_01
        Schema: asterisk
          Root: e1
       Purpose: This test demonstrates that in an expression, the asterisk cannot be used to denote all children 
  -->

  <tdml:parserTestCase name="asterisk_01" root="e1"
    model="asterisk" description="Section 23 - DFDL Expressions - DFDL-23-068R2">

    <tdml:document>one,two,three</tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Wildcard</tdml:error>
      <tdml:error>unsupported</tdml:error>
      <tdml:error>DFDL Expression Syntax</tdml:error>
      <tdml:error>'*'</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
     Test Name: asterisk_02
        Schema: asterisk
          Root: e2
       Purpose: This test demonstrates that in an expression, the asterisk cannot be used to denote all children 
  -->

  <tdml:parserTestCase name="asterisk_02" root="e2"
    model="asterisk" description="Section 23 - DFDL Expressions - DFDL-23-068R2">

    <tdml:document>one,two,three</tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Wildcard</tdml:error>
      <tdml:error>unsupported</tdml:error>
      <tdml:error>DFDL Expression Syntax</tdml:error>
      <tdml:error>'*'</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
     Test Name: asterisk_03
        Schema: asterisk
          Root: e3
       Purpose: This test demonstrates that in an expression, the asterisk can be used as a literal character
  -->

  <tdml:parserTestCase name="asterisk_03" root="e3"
    model="asterisk" description="Section 23 - DFDL Expressions - DFDL-23-068R2">

    <tdml:document>one,two,three</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e3>
          <nest>
            <item>one</item>
            <item>two</item>
            <item>three</item>
          </nest>
          <literal>*</literal>
        </e3>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <tdml:defineSchema name="predicates">

    <xs:include schemaLocation="org/apache/daffodil/xsd/DFDLGeneralFormat.dfdl.xsd"/>
    <dfdl:format ref="ex:GeneralFormat" lengthKind="delimited" />

    <xs:element name="e1">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="index" type="xs:int" />
          <xs:element name="item" type="xs:string" minOccurs="0" maxOccurs="10"/>
          <xs:element name="p" type="xs:string" dfdl:inputValueCalc="{ /ex:e1/ex:item[ /ex:e1/ex:index ] }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e2">
      <xs:complexType>
        <xs:sequence dfdl:separator=";">
          <xs:element name="item" minOccurs="0" maxOccurs="10" >
            <xs:complexType>
              <xs:sequence dfdl:separator=",">
                <xs:element name="a" type="xs:string"/>
                <xs:element name="b" type="xs:string"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="p" type="xs:string" dfdl:inputValueCalc="{ /ex:e2/ex:item[ b='four' ]/ex:a }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e3">
      <xs:complexType>
        <xs:sequence dfdl:separator=";">
          <xs:element name="item" minOccurs="0" maxOccurs="10" >
            <xs:complexType>
              <xs:sequence dfdl:separator=",">
                <xs:element name="a" type="xs:int"/>
                <xs:element name="b" type="xs:int"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="p" type="xs:int" dfdl:inputValueCalc="{ /ex:e3/ex:item[ a>5 ]/ex:a }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e4">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="item" type="xs:string" minOccurs="0" maxOccurs="10"/>
          <xs:element name="p" type="xs:string" dfdl:inputValueCalc="{ /ex:e4/ex:item[ 6-5 ] }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e5">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="index" type="xs:int" />
          <xs:element name="item" type="xs:string" minOccurs="0" maxOccurs="10"/>
          <xs:element name="p" type="xs:string" dfdl:inputValueCalc="{ /ex:e5/ex:index[ 1 ] }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

  </tdml:defineSchema>

  <!--
     Test Name: predicate_01
        Schema: predicates
          Root: e1
       Purpose: This test demonstrates that DPath can use predicates to index arrays. 
  -->

  <tdml:parserTestCase name="predicate_01" root="e1"
    model="predicates" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document>2,one,two,three</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e1>
          <ex:index>2</ex:index>
          <ex:item>one</ex:item>
          <ex:item>two</ex:item>
          <ex:item>three</ex:item>
          <ex:p>two</ex:p>
        </ex:e1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: predicate_02
        Schema: predicates
          Root: e2
       Purpose: This test demonstrates that DPath can only use integer expressions as predicates.
  -->

  <tdml:parserTestCase name="predicate_02" root="e2"
    model="predicates" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document>one,two;three,four;five,six</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e4>
          <ex:item>one</ex:item>
          <ex:item>two</ex:item>
          <ex:item>three</ex:item>
          <ex:p>one</ex:p>
        </ex:e4>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>

  <!--
     Test Name: predicate_03
        Schema: predicates
          Root: e3
       Purpose: This test demonstrates that DPath can only use integer expressions as predicates. 
  -->

  <tdml:parserTestCase name="predicate_03" root="e3"
    model="predicates" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document>1,6;14,3;2,9</tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Placeholder</tdml:error>
    </tdml:errors>

  </tdml:parserTestCase>

  <!--
     Test Name: predicate_04
        Schema: predicates
          Root: e4
       Purpose: This test demonstrates that DPath can use predicates to index arrays.
  -->

  <tdml:parserTestCase name="predicate_04" root="e4"
    model="predicates" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document>one,two,three</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e4>
          <ex:item>one</ex:item>
          <ex:item>two</ex:item>
          <ex:item>three</ex:item>
          <ex:p>one</ex:p>
        </ex:e4>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: predicate_05
        Schema: predicates
          Root: e5
       Purpose: This test demonstrates that subset indexing is only allowed on arrays.
  -->

  <tdml:parserTestCase name="predicate_05" root="e5"
    model="predicates" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document>2,one,two,three</tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Subset Indexing is only allowed on arrays.</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <!--
     Test Name: comparison_operators_23
        Schema: comparisonOperators 
          Root: e14
       Purpose: This test demonstrates that lexicographic collation order is used for string comparison 
  -->

  <tdml:parserTestCase name="comparison_operators_23" root="e14"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>one2,one12</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e14>
          <string1>one2</string1>
          <string2>one12</string2>
          <oneGTtwo>true</oneGTtwo>
        </e14>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_24
        Schema: comparisonOperators 
          Root: e14
       Purpose: This test demonstrates that lexicographic collation order is used for string comparison 
  -->

  <tdml:parserTestCase name="comparison_operators_24" root="e14"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>125,4</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e14>
          <string1>125</string1>
          <string2>4</string2>
          <oneGTtwo>false</oneGTtwo>
        </e14>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_25
        Schema: comparisonOperators 
          Root: e15
       Purpose: This test demonstrates that lexicographic collation order is used for string comparison 
  -->

  <tdml:parserTestCase name="comparison_operators_25" root="e15"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>100,2</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e15>
          <string1>100</string1>
          <string2>2</string2>
          <oneLTtwo>true</oneLTtwo>
        </e15>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_26
        Schema: comparisonOperators 
          Root: e15
       Purpose: This test demonstrates that lexicographic collation order is used for string comparison 
  -->

  <tdml:parserTestCase name="comparison_operators_26" root="e15"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>100000,2</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e15>
          <string1>100000</string1>
          <string2>2</string2>
          <oneLTtwo>true</oneLTtwo>
        </e15>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_27
        Schema: comparisonOperators 
          Root: e16
       Purpose: This test demonstrates that DPath supports string comparison 
  -->

  <tdml:parserTestCase name="comparison_operators_27" root="e16"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>
      <tdml:documentPart type="byte">7061696e73 2c 7061696e74</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e16>
          <string1>pains</string1>
          <string2>paint</string2>
          <oneEQtwo>false</oneEQtwo>
        </e16>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_28
        Schema: comparisonOperators 
          Root: e17
       Purpose: This test demonstrates that DPath supports string comparison 
  -->

  <tdml:parserTestCase name="comparison_operators_28" root="e17"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>
      <tdml:documentPart type="byte">7061696e73 2c 7061696e74</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e17>
          <string1>pains</string1>
          <string2>paint</string2>
          <oneLTtwo>true</oneLTtwo>
        </e17>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <tdml:defineSchema name="and_or_schema">

    <xs:include schemaLocation="org/apache/daffodil/xsd/DFDLGeneralFormat.dfdl.xsd"/>
    <dfdl:format ref="ex:GeneralFormat" lengthKind="delimited" />

    <xs:element name="e1">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string1" type="xs:string"/>
          <xs:element name="string2" type="xs:string"/>
          <xs:element name="float1" type="xs:float" dfdl:lengthKind="delimited" dfdl:textStandardNaNRep="NaN" />
          <xs:element name="and" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:string1 eq ../ex:string2 and fn:round(../ex:float1) eq 1.0 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e2">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string1" type="xs:string"/>
          <xs:element name="string2" type="xs:string"/>
          <xs:element name="float1" type="xs:float" dfdl:lengthKind="delimited" dfdl:textStandardNaNRep="NaN" />
          <xs:element name="float2" type="xs:float" dfdl:lengthKind="delimited" dfdl:textStandardNaNRep="NaN" />
          <xs:element name="and" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:string1 eq ../ex:string2 and fn:round(../ex:float1) eq 1.0 and fn:round(../ex:float2) eq 2.0 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e3">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string1" type="xs:string"/>
          <xs:element name="string2" type="xs:string"/>
          <xs:element name="float1" type="xs:float" dfdl:lengthKind="delimited" dfdl:textStandardNaNRep="NaN" />
          <xs:element name="or" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:string1 eq ../ex:string2 or fn:round(../ex:float1) eq 1.0 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e4">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string1" type="xs:string"/>
          <xs:element name="string2" type="xs:string"/>
          <xs:element name="float1" type="xs:float" dfdl:lengthKind="delimited" dfdl:textStandardNaNRep="NaN" />
          <xs:element name="float2" type="xs:float" dfdl:lengthKind="delimited" dfdl:textStandardNaNRep="NaN" />
          <xs:element name="or" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:string1 eq ../ex:string2 or fn:round(../ex:float1) eq 1.0 or fn:round(../ex:float2) eq 2.0 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e5">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string1" type="xs:string"/>
          <xs:element name="string2" type="xs:string"/>
          <xs:element name="float1" type="xs:float" dfdl:lengthKind="delimited" dfdl:textStandardNaNRep="NaN" />
          <xs:element name="float2" type="xs:float" dfdl:lengthKind="delimited" dfdl:textStandardNaNRep="NaN" />
          <xs:element name="andor" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:string1 eq ../ex:string2 and fn:round(../ex:float1) eq 1.0 or fn:round(../ex:float2) eq 2.0 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e6">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string1" type="xs:string"/>
          <xs:element name="string2" type="xs:string"/>
          <xs:element name="float1" type="xs:float" dfdl:lengthKind="delimited" dfdl:textStandardNaNRep="NaN" />
          <xs:element name="float2" type="xs:float" dfdl:lengthKind="delimited" dfdl:textStandardNaNRep="NaN" />
          <xs:element name="andor" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:string1 eq ../ex:string2 or fn:round(../ex:float1) eq 1.0 and fn:round(../ex:float2) eq 2.0 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e7">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string1" type="xs:string"/>
          <xs:element name="string2" type="xs:string"/>
          <xs:element name="float1" type="xs:float" dfdl:lengthKind="delimited" dfdl:textStandardNaNRep="NaN" />
          <xs:element name="float2" type="xs:float" dfdl:lengthKind="delimited" dfdl:textStandardNaNRep="NaN" />
          <xs:element name="andor" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:string1 eq 'abc' or ../ex:string1 eq ../ex:string2 or fn:round(../ex:float1) eq 1.0 and fn:round(../ex:float2) eq 2.0 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e8">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string1" type="xs:string"/>
          <xs:element name="string2" type="xs:string"/>
          <xs:element name="float1" type="xs:float" dfdl:lengthKind="delimited" dfdl:textStandardNaNRep="NaN" />
          <xs:element name="float2" type="xs:float" dfdl:lengthKind="delimited" dfdl:textStandardNaNRep="NaN" />
          <xs:element name="andor" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:string1 eq ../ex:string2 or fn:round(../ex:float1) eq 1.0 and fn:round(../ex:float2) eq 2.0 or ../ex:string1 eq 'abc' }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e9">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string1" type="xs:string"/>
          <xs:element name="string2" type="xs:string"/>
          <xs:element name="float1" type="xs:float" dfdl:lengthKind="delimited" dfdl:textStandardNaNRep="NaN" />
          <xs:element name="float2" type="xs:float" dfdl:lengthKind="delimited" dfdl:textStandardNaNRep="NaN" />
          <xs:element name="andor" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:string1 eq ../ex:string2 and fn:round(../ex:float1) eq 1.0 or fn:round(../ex:float2) eq 2.0 and ../ex:string1 eq 'abc' }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

  </tdml:defineSchema>

  <!--
     Test Name: sequential_and_01
        Schema: and_or_schema
          Root: e1
       Purpose: This test demonstrates that the and operator is evaluated sequentially, so it stops at the first false.
  -->

  <tdml:parserTestCase name="sequential_and_01" root="e1"
    model="and_or_schema" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document>abc,def,NaN</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e1>
          <ex:string1>abc</ex:string1>
          <ex:string2>def</ex:string2>
          <ex:float1>NaN</ex:float1>
          <ex:and>false</ex:and>
        </ex:e1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: sequential_and_02
        Schema: and_or_schema
          Root: e2
       Purpose: This test demonstrates that the and operator is evaluated sequentially, so it stops at the first false.
  -->

  <tdml:parserTestCase name="sequential_and_02" root="e2"
    model="and_or_schema" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document>abc,abc,3.5,NaN</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e2>
          <ex:string1>abc</ex:string1>
          <ex:string2>abc</ex:string2>
          <ex:float1>3.5</ex:float1>
          <ex:float2>NaN</ex:float2>
          <ex:and>false</ex:and>
        </ex:e2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: sequential_and_03
        Schema: and_or_schema
          Root: e2
       Purpose: This test demonstrates that the and operator is evaluated sequentially, so it stops at the first false.
          This test gets a Parse Error because the first expression evaluated to true so it continues to parse.
  -->

  <tdml:parserTestCase name="sequential_and_03" root="e2"
    model="and_or_schema" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document>abc,abc,NaN,2</tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>NaN</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <!--
     Test Name: sequential_and_04
        Schema: and_or_schema
          Root: e2
       Purpose: This test demonstrates that the and operator is evaluated sequentially, so it stops at the first false.
          This test does not have a false so it continues parsing until the parse error.
  -->

  <tdml:parserTestCase name="sequential_and_04" root="e2"
    model="and_or_schema" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document>abc,abc,1,NaN</tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>NaN</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <!--
     Test Name: sequential_and_05
        Schema: and_or_schema
          Root: e2
       Purpose: This test demonstrates that multiple and operators can be used in an expression.
  -->

  <tdml:parserTestCase name="sequential_and_05" root="e2"
    model="and_or_schema" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document>abc,abc,1,7.5</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e2>
          <ex:string1>abc</ex:string1>
          <ex:string2>abc</ex:string2>
          <ex:float1>1.0</ex:float1>
          <ex:float2>7.5</ex:float2>
          <ex:and>false</ex:and>
        </ex:e2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: sequential_or_01
        Schema: and_or_schema
          Root: e3
       Purpose: This test demonstrates that the or operator is evaluated sequentially, so it stops at the first true.
  -->

  <tdml:parserTestCase name="sequential_or_01" root="e3"
    model="and_or_schema" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document>abc,abc,NaN</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e3>
          <ex:string1>abc</ex:string1>
          <ex:string2>abc</ex:string2>
          <ex:float1>NaN</ex:float1>
          <ex:or>true</ex:or>
        </ex:e3>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: sequential_or_02
        Schema: and_or_schema
          Root: e4
       Purpose: This test demonstrates that the or operator is evaluated sequentially, so it stops at the first true.
  -->

  <tdml:parserTestCase name="sequential_or_02" root="e4"
    model="and_or_schema" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document>abc,def,1.2,NaN</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e4>
          <ex:string1>abc</ex:string1>
          <ex:string2>def</ex:string2>
          <ex:float1>1.2</ex:float1>
          <ex:float2>NaN</ex:float2>
          <ex:or>true</ex:or>
        </ex:e4>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: sequential_or_03
        Schema: and_or_schema
          Root: e4
       Purpose: This test demonstrates that the or operator is evaluated sequentially, so it stops at the first true.
          This test gets a Parse Error because the first expression evaluated to false so it continues to parse.
  -->

  <tdml:parserTestCase name="sequential_or_03" root="e4"
    model="and_or_schema" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document>abc,def,NaN,2</tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>NaN</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <!--
     Test Name: sequential_or_04
        Schema: and_or_schema
          Root: e4
       Purpose: This test demonstrates that the or operator is evaluated sequentially, so it stops at the first true.
          This test does not have a true so it continues parsing until the parse error.
  -->

  <tdml:parserTestCase name="sequential_or_04" root="e4"
    model="and_or_schema" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document>abc,def,5.2,NaN</tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>NaN</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
     Test Name: sequential_or_05
        Schema: and_or_schema
          Root: e4
       Purpose: This test demonstrates that multiple or operators can be used in an expression.
  -->

  <tdml:parserTestCase name="sequential_or_05" root="e4"
    model="and_or_schema" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document>abc,def,4.6,2</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e4>
          <ex:string1>abc</ex:string1>
          <ex:string2>def</ex:string2>
          <ex:float1>4.6</ex:float1>
          <ex:float2>2.0</ex:float2>
          <ex:or>true</ex:or>
        </ex:e4>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: sequential_and_or_01
        Schema: and_or_schema
          Root: e5
       Purpose: This test demonstrates that and/or operators can be used in the same expression.
  -->

  <tdml:parserTestCase name="sequential_and_or_01" root="e5"
    model="and_or_schema" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document>abc,abc,4.6,2</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e5>
          <ex:string1>abc</ex:string1>
          <ex:string2>abc</ex:string2>
          <ex:float1>4.6</ex:float1>
          <ex:float2>2.0</ex:float2>
          <ex:andor>true</ex:andor>
        </ex:e5>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: sequential_and_or_02
        Schema: and_or_schema
          Root: e6
       Purpose: This test demonstrates that and/or operators can be used in the same expression.
  -->

  <tdml:parserTestCase name="sequential_and_or_02" root="e6"
    model="and_or_schema" description="Section 23 - DFDL Expressions - DFDL-23-067R"
    roundTrip="twoPass">

    <tdml:document>abc,abc,1.0,5</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e6>
          <ex:string1>abc</ex:string1>
          <ex:string2>abc</ex:string2>
          <ex:float1>1.0</ex:float1>
          <ex:float2>5.0</ex:float2>
          <ex:andor>true</ex:andor>
        </ex:e6>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: sequential_and_or_03
        Schema: and_or_schema
          Root: e6
       Purpose: This test demonstrates that and/or operators can be used in the same expression.
  -->

  <tdml:parserTestCase name="sequential_and_or_03" root="e6"
    model="and_or_schema" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document>abc,def,5,NaN</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e6>
          <ex:string1>abc</ex:string1>
          <ex:string2>def</ex:string2>
          <ex:float1>5.0</ex:float1>
          <ex:float2>NaN</ex:float2>
          <ex:andor>false</ex:andor>
        </ex:e6>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: sequential_and_or_04
        Schema: and_or_schema
          Root: e7
       Purpose: This test demonstrates that and/or operators can be used in the same expression.
  -->

  <tdml:parserTestCase name="sequential_and_or_04" root="e7"
    model="and_or_schema" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document>abc,def,5,2</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e7>
          <ex:string1>abc</ex:string1>
          <ex:string2>def</ex:string2>
          <ex:float1>5.0</ex:float1>
          <ex:float2>2.0</ex:float2>
          <ex:andor>true</ex:andor>
        </ex:e7>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: sequential_and_or_05
        Schema: and_or_schema
          Root: e7
       Purpose: This test demonstrates that and/or operators can be used in the same expression.
  -->

  <tdml:parserTestCase name="sequential_and_or_05" root="e7"
    model="and_or_schema" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document>abc,def,5,7</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e7>
          <ex:string1>abc</ex:string1>
          <ex:string2>def</ex:string2>
          <ex:float1>5.0</ex:float1>
          <ex:float2>7.0</ex:float2>
          <ex:andor>true</ex:andor>
        </ex:e7>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: sequential_and_or_06
        Schema: and_or_schema
          Root: e8
       Purpose: This test demonstrates that and/or operators can be used in the same expression.
  -->

  <tdml:parserTestCase name="sequential_and_or_06" root="e8"
    model="and_or_schema" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document>abc,def,5,7</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e8>
          <ex:string1>abc</ex:string1>
          <ex:string2>def</ex:string2>
          <ex:float1>5.0</ex:float1>
          <ex:float2>7.0</ex:float2>
          <ex:andor>true</ex:andor>
        </ex:e8>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: sequential_and_or_07
        Schema: and_or_schema
          Root: e9
       Purpose: This test demonstrates that and/or operators can be used in the same expression.
  -->

  <tdml:parserTestCase name="sequential_and_or_07" root="e9"
    model="and_or_schema" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document>def,def,1,2</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e9>
          <ex:string1>def</ex:string1>
          <ex:string2>def</ex:string2>
          <ex:float1>1.0</ex:float1>
          <ex:float2>2.0</ex:float2>
          <ex:andor>true</ex:andor>
        </ex:e9>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: hiddenDataExpression
        Schema: hiddenElem 
          Root: e1
       Purpose: This test demonstrates that expressions operate on the augmented infoset (which includes hidden elements) 
                Note that this test does not round trip.
  -->

  <tdml:parserTestCase name="hiddenDataExpression" root="e1"
    model="hiddenElem" description="Section 23 - DFDL Expressions - DFDL-23-010R"
    roundTrip="false">

    <tdml:document>pw:p455w0rd</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e1>
          <hideme>p***</hideme>
        </e1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
             
  </tdml:parserTestCase>
  
  <!--
     Test Name: arrayIndexOutOfBounds_01
        Schema: hiddenElem 
          Root: e1
       Purpose: This test demonstrates that a proper error occurs if array doesn't exist with valid indices.
  -->

  <tdml:parserTestCase name="arrayIndexOutOfBounds_01" root="e1"
    model="hiddenElem" description="Section 23 - DFDL Expressions">

    <tdml:document>p455w0rd</tdml:document>
      <tdml:errors>
        <tdml:error>Schema Definition Error</tdml:error>
        <tdml:error>expression evaluation error</tdml:error>
        <tdml:error>Child element</tdml:error>
        <tdml:error>password</tdml:error>
        <tdml:error>does not exist</tdml:error>
      </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
     Test Name: arrayIndexOutOfBounds_02
        Schema: hiddenElem 
          Root: e1b
       Purpose: This test demonstrates that a proper error occurs if an array index in an expression is out of bounds 
  -->

  <tdml:parserTestCase name="arrayIndexOutOfBounds_02" root="e1b"
    model="hiddenElem" description="Section 23 - DFDL Expressions">

    <tdml:document>pw:p455w0rd</tdml:document>
      <tdml:errors>
        <tdml:error>Schema Definition Error</tdml:error>
        <tdml:error>expression evaluation error</tdml:error>
        <tdml:error>Value -1 is out of range</tdml:error>
        <tdml:error>with length 1</tdml:error>
      </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
     Test Name: arrayIndexOutOfBounds_03
        Schema: hiddenElem 
          Root: e1c
       Purpose: This test demonstrates that a proper error occurs if an array index in an expression is out of bounds 
  -->

  <tdml:parserTestCase name="arrayIndexOutOfBounds_03" root="e1c"
    model="hiddenElem" description="Section 23 - DFDL Expressions">

    <tdml:document>pw:p455w0rd</tdml:document>
      <tdml:errors>
        <tdml:error>Schema Definition Error</tdml:error>
        <tdml:error>expression evaluation error</tdml:error>
        <tdml:error>Value 10 is out of range</tdml:error>
        <tdml:error>with length 1</tdml:error>
      </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
     Test Name: arrayIndexOutOfBounds_05
        Schema: hiddenElem 
          Root: e1c
       Purpose: This test demonstrates that a proper error occurs if an array index in an expression is out of bounds
       (positive, so requires the element to exist) for an array that does not exist. 
  -->

  <tdml:parserTestCase name="arrayIndexOutOfBounds_05" root="e1c"
    model="hiddenElem" description="Section 23 - DFDL Expressions">

    <tdml:document>p455w0rd</tdml:document>
      <tdml:errors>
        <tdml:error>Schema Definition Error</tdml:error>
        <tdml:error>expression evaluation error</tdml:error>
        <tdml:error>Child element</tdml:error>
        <tdml:error>password</tdml:error>
        <tdml:error>does not exist</tdml:error>
      </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
     Test Name: hiddenDataExpression2
        Schema: hiddenElem 
          Root: e2
       Purpose: This test demonstrates that expressions operate on the augmented infoset (which includes hidden elements) 
                Note that this test does not round trip.
  -->

  <tdml:parserTestCase name="hiddenDataExpression2" root="e2"
    model="hiddenElem" description="Section 23 - DFDL Expressions - DFDL-23-010R"
    roundTrip="false">

    <tdml:document>pw:p455w0rd</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e2>
          <unhideme>p455w0rd</unhideme>
        </e2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: sequenceReturned_01
        Schema: paths 
          Root: e1
       Purpose: This test demonstrates that DFDL expressions never return node-sequences 
  -->

  <tdml:parserTestCase name="sequenceReturned_01" root="e1"
    model="paths" description="Section 23 - DFDL Expressions - DFDL-23-009R1">

    <tdml:document>1,2,3,4,5</tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Query-style paths not supported</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
     Test Name: sequenceReturned_02
        Schema: paths 
          Root: e4
       Purpose: This test demonstrates that DFDL expressions never return node-sequences 
  -->

  <tdml:parserTestCase name="sequenceReturned_02" root="e4"
    model="paths" description="Section 23 - DFDL Expressions - DFDL-23-009R1">

    <tdml:document>1,1,1,1,1.2|2|2|2|2.3:3:3:3:3:3:3:3</tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Query-style paths not supported</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
     Test Name: sequenceReturned_03
        Schema: paths 
          Root: e5
       Purpose: This test demonstrates that DFDL expressions never return node-sequences 
  -->

  <tdml:parserTestCase name="sequenceReturned_03" root="e5"
    model="paths" description="Section 23 - DFDL Expressions - DFDL-23-009R1">

    <tdml:document>1+3!</tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Query-style paths not supported</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
     Test Name: longPath_01
        Schema: paths 
          Root: e2
       Purpose: This test exercises DPath paths
  -->

  <tdml:parserTestCase name="longPath_01" root="e2"
    model="paths" description="Section 23 - DFDL Expressions - DFDL-23-009R">

    <tdml:document>1,2,3,4,5</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e2>
          <seq>
            <item>1</item>
            <item>2</item>
            <item>3</item>
            <item>4</item>
            <item>5</item>
          </seq>
          <items>2</items>
        </e2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: longPath_02
        Schema: paths 
          Root: e3
       Purpose: This test exercises DPath paths
  -->

  <tdml:parserTestCase name="longPath_02" root="e3"
    model="paths" description="Section 23 - DFDL Expressions - DFDL-23-009R">

    <tdml:document>1,1,1,1,1.2|2|2|2|2.3:3:3:3:3:3:3:3</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e3>
          <seq>
            <item>1</item>
            <item>1</item>
            <item>1</item>
            <item>1</item>
            <item>1</item>
          </seq>
          <seq2>
            <item>2</item>
            <item>2</item>
            <item>2</item>
            <item>2</item>
            <item>2</item>
          </seq2>
          <seq3>
            <item>3</item>
            <item>3</item>
            <item>3</item>
            <item>3</item>
            <item>3</item>
            <item>3</item>
            <item>3</item>
            <item>3</item>
          </seq3>
          <items>6</items>
        </e3>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <tdml:defineSchema name="axes">

    <xs:include schemaLocation="org/apache/daffodil/xsd/DFDLGeneralFormat.dfdl.xsd"/>
    <dfdl:format ref="ex:GeneralFormat" lengthKind="delimited" />

    <xs:element name="e1">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="c1" type="xs:string" />
          <xs:element name="c2" type="xs:string" dfdl:inputValueCalc="{ parent::ex:e1/ex:c1 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e2">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="c1" type="xs:string" />
          <xs:element name="c2" dfdl:terminator="{ self::ex:c2/../ex:c1 }">
            <xs:complexType>
              <xs:sequence dfdl:separator="/" >
                <xs:element name="d1" type="xs:string"/>
                <xs:element name="d2" type="xs:string"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e3">
      <xs:complexType>
        <xs:sequence dfdl:separator="," >
          <xs:element name="c1">
            <xs:complexType>
              <xs:sequence dfdl:separator=";" >
                <xs:element name="d1" type="xs:string" />
                <xs:element name="d2" type="xs:string" />
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="c2" type="xs:string" dfdl:inputValueCalc="{ ../ex:c1/child::ex:d1 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e4">
      <xs:complexType>
        <xs:sequence dfdl:separator="," >
          <xs:element name="c1" type="xs:string" dfdl:inputValueCalc="{ 'test' }"/>
          <xs:element name="c2">
            <xs:complexType>
              <xs:sequence dfdl:separator=";" >
                <xs:element name="d1" type="xs:string" />
                <xs:element name="d2" type="xs:string" dfdl:inputValueCalc="{ ancestor::ex:e4/ex:c1 }"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e5">
      <xs:complexType>
        <xs:sequence dfdl:separator="," >
          <xs:element name="c1" type="xs:string" dfdl:inputValueCalc="{ 'test' }"/>
          <xs:element name="c2">
            <xs:complexType>
              <xs:sequence dfdl:separator=";" >
                <xs:element name="d1" type="xs:string" />
                <xs:element name="d2" type="xs:string" dfdl:inputValueCalc="{ ancestor-or-self::ex:c2/ex:d1 }"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e6" type="xs:boolean" dfdl:nilKind="literalValue" nillable="true" dfdl:nilValue="NIL" dfdl:inputValueCalc="{ attribute::nil }"/>

    <xs:element name="e7">
      <xs:complexType>
        <xs:sequence dfdl:separator="," >
          <xs:element name="c1">
            <xs:complexType>
              <xs:sequence dfdl:separator=";" >
                <xs:element name="d1" type="xs:string" />
                <xs:element name="d2" type="xs:string" />
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="c2" type="xs:string" dfdl:inputValueCalc="{ /ex:e7/descendant::ex:c1/ex:d1 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e8">
      <xs:complexType>
        <xs:sequence dfdl:separator="," >
          <xs:element name="c1">
            <xs:complexType>
              <xs:sequence dfdl:separator=";" >
                <xs:element name="d1" type="xs:string" />
                <xs:element name="d2" type="xs:string" />
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="c2" type="xs:string" dfdl:inputValueCalc="{ /ex:e8/descendant-or-self::ex:c1/ex:d2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e9">
      <xs:complexType>
        <xs:sequence dfdl:separator="," >
          <xs:element name="c1" type="xs:string" dfdl:inputValueCalc="{ following::ex:d1 }"/>
          <xs:element name="c2">
            <xs:complexType>
              <xs:sequence dfdl:separator=";" >
                <xs:element name="d1" type="xs:string" />
                <xs:element name="d2" type="xs:string" />
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e10">
      <xs:complexType>
        <xs:sequence dfdl:separator="," >
          <xs:element name="c1" type="xs:string" dfdl:inputValueCalc="{ following-sibling::ex:c3 }"/>
          <xs:element name="c2" type="xs:string" />
          <xs:element name="c3" type="xs:string" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e11" type="xs:string" dfdl:inputValueCalc="{ namespace::* }" />

    <xs:element name="e12">
      <xs:complexType>
        <xs:sequence dfdl:separator="," >
          <xs:element name="c1">
            <xs:complexType>
              <xs:sequence dfdl:separator=";" >
                <xs:element name="d1" type="xs:string" />
                <xs:element name="d2" type="xs:string" />
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="c2" type="xs:string" dfdl:inputValueCalc="{ preceding::ex:d1 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e13">
      <xs:complexType>
        <xs:sequence dfdl:separator="," >
          <xs:element name="c1" type="xs:string" />
          <xs:element name="c2" type="xs:string" />
          <xs:element name="c3" type="xs:string" dfdl:inputValueCalc="{ preceding-sibling::ex:c1 }" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e14">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="c1" type="xs:string" />
          <xs:element name="c2">
            <xs:complexType>
              <xs:sequence dfdl:separator="/" >
                <xs:element name="d1" type="xs:string" dfdl:inputValueCalc="{ self::ex:d1/parent::ex:c2/parent::ex:e14/child::ex:c1 }"/>
                <xs:element name="d2" type="xs:string" dfdl:inputValueCalc="{ parent::ex:d1 }" />
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="c3" type="xs:string" dfdl:inputValueCalc="{ parent::ex:e14/ex:c2/child::ex:d2}" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e15">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="c1" type="xs:string" />
          <xs:element name="c2" dfdl:terminator="{ ../ex:c1 }" >
            <xs:complexType>
              <xs:sequence dfdl:separator="/" >
                <xs:element name="d1" type="xs:string" />
                <xs:element name="d2" type="xs:string" />
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
  </tdml:defineSchema>

  <!--
     Test Name: parent_axis_01
        Schema: axes
          Root: e1
       Purpose: This test demonstrates the use of "parent" as an axis.
  -->

  <tdml:parserTestCase name="parent_axis_01" root="e1"
    model="axes" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document>test</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e1>
          <ex:c1>test</ex:c1>
          <ex:c2>test</ex:c2>
        </ex:e1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: self_axis_01
        Schema: axes
          Root: e2
       Purpose: This test demonstrates the use of "self" as an axis.
  -->

  <tdml:parserTestCase name="self_axis_01" root="e2"
    model="axes" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document>;,abc/def;</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e2>
          <ex:c1>;</ex:c1>
          <ex:c2>
            <ex:d1>abc</ex:d1>
            <ex:d2>def</ex:d2>
          </ex:c2>
        </ex:e2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: child_axis_01
        Schema: axes
          Root: e3
       Purpose: This test demonstrates the use of "child" as an axis.
  -->

  <tdml:parserTestCase name="child_axis_01" root="e3"
    model="axes" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document>abc;test</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e3>
          <ex:c1>
            <ex:d1>abc</ex:d1>
            <ex:d2>test</ex:d2>
          </ex:c1>
          <ex:c2>abc</ex:c2>
        </ex:e3>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: ancestor_axis_01
        Schema: axes
          Root: e4
       Purpose: This test demonstrates that DPath does not support the "ancestor" axis.
  -->

  <tdml:parserTestCase name="ancestor_axis_01" root="e4"
    model="axes" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document />
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>ancestor</tdml:error>
      <tdml:error>unsupported axis</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <!--
     Test Name: ancestor_or_self_axis_01
        Schema: axes
          Root: e5
       Purpose: This test demonstrates that DPath does not support the "ancestor-or-self" axis.
  -->

  <tdml:parserTestCase name="ancestor_or_self_axis_01" root="e5"
    model="axes" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document />
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>ancestor-or-self</tdml:error>
      <tdml:error>unsupported axis</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <!--
     Test Name: attribute_axis_04
        Schema: axes
          Root: e6
       Purpose: This test demonstrates that DPath does not support the "attribute" axis.
  -->

  <tdml:parserTestCase name="attribute_axis_04" root="e6"
    model="axes" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document />
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>attribute</tdml:error>
      <tdml:error>unsupported axis</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <!--
     Test Name: descendant_axis_01
        Schema: axes
          Root: e7
       Purpose: This test demonstrates that DPath does not support the "descendant" axis.
  -->

  <tdml:parserTestCase name="descendant_axis_01" root="e7"
    model="axes" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document />
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>descendant</tdml:error>
      <tdml:error>unsupported axis</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <!--
     Test Name: descendant_or_self_axis_01
        Schema: axes
          Root: e8
       Purpose: This test demonstrates that DPath does not support the "descendant-or-self" axis.
  -->

  <tdml:parserTestCase name="descendant_or_self_axis_01" root="e8"
    model="axes" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document />
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>descendant-or-self</tdml:error>
      <tdml:error>unsupported axis</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <!--
     Test Name: following_axis_01
        Schema: axes
          Root: e9
       Purpose: This test demonstrates that DPath does not support the "following" axis.
  -->

  <tdml:parserTestCase name="following_axis_01" root="e9"
    model="axes" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document />
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>following</tdml:error>
      <tdml:error>unsupported axis</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <!--
     Test Name: following_sibling_axis_01
        Schema: axes
          Root: e10
       Purpose: This test demonstrates that DPath does not support the "following-sibling" axis.
  -->

  <tdml:parserTestCase name="following_sibling_axis_01" root="e10"
    model="axes" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document />
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>following-sibling</tdml:error>
      <tdml:error>unsupported axis</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <!--
     Test Name: namespace_axis_01
        Schema: axes
          Root: e11
       Purpose: This test demonstrates that DPath does not support the "namespace" axis.
  -->

  <tdml:parserTestCase name="namespace_axis_01" root="e11"
    model="axes" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document />
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>namespace</tdml:error>
      <tdml:error>unsupported axis</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <!--
     Test Name: preceding_axis_01
        Schema: axes
          Root: e12
       Purpose: This test demonstrates that DPath does not support the "preceding" axis.
  -->

  <tdml:parserTestCase name="preceding_axis_01" root="e12"
    model="axes" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document />
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>preceding</tdml:error>
      <tdml:error>unsupported axis</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <!--
     Test Name: preceding_sibling_axis_01
        Schema: axes
          Root: e13
       Purpose: This test demonstrates that DPath does not support the "preceding-sibling" axis.
  -->

  <tdml:parserTestCase name="preceding_sibling_axis_01" root="e13"
    model="axes" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document />
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>preceding-sibling</tdml:error>
      <tdml:error>unsupported axis</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <!--
     Test Name: multiple_axis_01
        Schema: axes
          Root: e14
       Purpose: This test demonstrates the use of "parent", "child", and "self" as axes.
  -->

  <tdml:parserTestCase name="multiple_axis_01" root="e14"
    model="axes" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document>abc</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e14>
          <ex:c1>abc</ex:c1>
          <ex:c2>
            <ex:d1>abc</ex:d1>
            <ex:d2>abc</ex:d2>
          </ex:c2>
          <ex:c3>abc</ex:c3>
        </ex:e14>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: short_parent_axis_01
        Schema: axes
          Root: e15
       Purpose: This test demonstrates the use of "../" in a path expression as AbbrevReverseStep.
  -->

  <tdml:parserTestCase name="short_parent_axis_01" root="e15"
    model="axes" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document>;,abc/def;</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e15>
          <ex:c1>;</ex:c1>
          <ex:c2>
            <ex:d1>abc</ex:d1>
            <ex:d2>def</ex:d2>
          </ex:c2>
        </ex:e15>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  
  <tdml:defineSchema name="array_index">

    <xs:include schemaLocation="org/apache/daffodil/xsd/DFDLGeneralFormat.dfdl.xsd"/>
    <dfdl:format ref="ex:GeneralFormat" lengthKind="delimited" />

    <xs:element name="e1">
      <xs:complexType>
        <xs:sequence dfdl:separator=";">
          <xs:element name="data">
            <xs:complexType>
              <xs:sequence dfdl:separator="|">
                <xs:element name="arr" minOccurs='0' maxOccurs='unbounded' type="xs:string" />
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="idx" type="xs:int" />
          <xs:element name="ivc" type="xs:string" dfdl:inputValueCalc="{ /ex:e1/ex:data/ex:arr[/ex:e1/ex:idx] }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e2">
      <xs:complexType>
        <xs:sequence dfdl:separator=";">
          <xs:element name="data">
            <xs:complexType>
              <xs:sequence dfdl:separator="|">
                <xs:element name="arr" minOccurs='0' maxOccurs='unbounded' type="xs:string" />
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="parent">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="idx" type="xs:int" />
                <xs:element name="ivc" type="xs:string" dfdl:inputValueCalc="{ ../../ex:data/ex:arr[../ex:idx] }"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

  </tdml:defineSchema>

  <!--
     Test Name: array_index_oob_01
        Schema: array_index
          Root: e1
       Purpose: This test demonstrates that array indexing works, can access the first element
  -->
  <tdml:parserTestCase name="array_index_oob_01" root="e1"
    model="array_index" description="Section 23 - DFDL Expressions - DFDL-23-067R">
    <tdml:document>a|b|c;1</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e1>
          <ex:data>
            <ex:arr>a</ex:arr>
            <ex:arr>b</ex:arr>
            <ex:arr>c</ex:arr>
          </ex:data>
          <ex:idx>1</ex:idx>
          <ex:ivc>a</ex:ivc>
        </ex:e1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: array_index_oob_02
        Schema: array_index
          Root: e1
       Purpose: This test demonstrates that array indexing works, can access the last element
  -->
  <tdml:parserTestCase name="array_index_oob_02" root="e1"
    model="array_index" description="Section 23 - DFDL Expressions - DFDL-23-067R">
    <tdml:document>a|b|c;3</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e1>
          <ex:data>
            <ex:arr>a</ex:arr>
            <ex:arr>b</ex:arr>
            <ex:arr>c</ex:arr>
          </ex:data>
          <ex:idx>3</ex:idx>
          <ex:ivc>c</ex:ivc>
        </ex:e1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: array_index_oob_03
        Schema: array_index
          Root: e1
       Purpose: This test demonstrates that accessing the 0th index of an array element causes an SDE
  -->
  <tdml:parserTestCase name="array_index_oob_03" root="e1"
    model="array_index" description="Section 23 - DFDL Expressions - DFDL-23-067R">
    <tdml:document>a|b|c;0</tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>expression evaluation error</tdml:error>
      <tdml:error>Value 0</tdml:error>
      <tdml:error>arr</tdml:error>
      <tdml:error>length 3</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <!--
     Test Name: array_index_oob_04
        Schema: array_index
          Root: e1
       Purpose: This test demonstrates that accessing beyond the last index of an array element causes an SDE
  -->
  <tdml:parserTestCase name="array_index_oob_04" root="e1"
    model="array_index" description="Section 23 - DFDL Expressions - DFDL-23-067R">
    <tdml:document>a|b|c;4</tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>expression evaluation error</tdml:error>
      <tdml:error>Value 4</tdml:error>
      <tdml:error>arr</tdml:error>
      <tdml:error>length 3</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <!--
     Test Name: array_index_oob_05
        Schema: array_index
          Root: e1
       Purpose: This test demonstrates that accessing a negative index of an array element causes an SDE
  -->
  <tdml:parserTestCase name="array_index_oob_05" root="e1"
    model="array_index" description="Section 23 - DFDL Expressions - DFDL-23-067R">
    <tdml:document>a|b|c;-1</tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>expression evaluation error</tdml:error>
      <tdml:error>Value -1</tdml:error>
      <tdml:error>arr</tdml:error>
      <tdml:error>length 3</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <!--
     Test Name: array_index_relative_path_subexpression_01
        Schema: array_index
          Root: e1
       Purpose: This test demonstrates that the context node of relative sub expression remains correct
  -->
  <tdml:parserTestCase name="array_index_relative_path_subexpression_01" root="e2"
    model="array_index" description="Section 23 - DFDL Expressions - DFDL-23-067R">
    <tdml:document>a|b|c;2</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e2>
          <ex:data>
            <ex:arr>a</ex:arr>
            <ex:arr>b</ex:arr>
            <ex:arr>c</ex:arr>
          </ex:data>
          <ex:parent>
            <ex:idx>2</ex:idx>
            <ex:ivc>b</ex:ivc>
          </ex:parent>
        </ex:e2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: comparison_operators_76
        Schema: comparisonOperators 
          Root: e37
       Purpose: This test demonstrates that comparison operators work for dateTime
  -->

  <tdml:parserTestCase name="comparison_operators_76" root="e37"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document><![CDATA[03-24-1988 04:55:23,03-24-1988 04:55:24]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e37>
          <dateTime1>1988-03-24T04:55:23</dateTime1>
          <dateTime2>1988-03-24T04:55:24</dateTime2>
          <lessThanEqualTo>true</lessThanEqualTo>
        </e37>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_77
        Schema: comparisonOperators 
          Root: e38
       Purpose: This test demonstrates that comparison operators work for dateTime
  -->

  <tdml:parserTestCase name="comparison_operators_77" root="e38"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document><![CDATA[03-24-1988 04:55:24,03-24-1988 04:55:23]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e38>
          <dateTime1>1988-03-24T04:55:24</dateTime1>
          <dateTime2>1988-03-24T04:55:23</dateTime2>
          <greaterThanEqualTo>true</greaterThanEqualTo>
        </e38>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_29
        Schema: comparisonOperators 
          Root: e18
       Purpose: This test demonstrates that comparison operators work for dateTime
  -->

  <tdml:parserTestCase name="comparison_operators_29" root="e18"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document><![CDATA[03-24-1988 04:55:24,03-24-1988 04:55:23]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e18>
          <dateTime1>1988-03-24T04:55:24</dateTime1>
          <dateTime2>1988-03-24T04:55:23</dateTime2>
          <oneGTtwo>true</oneGTtwo>
        </e18>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_30
        Schema: comparisonOperators 
          Root: e19
       Purpose: This test demonstrates that comparison operators work for dateTime
  -->

  <tdml:parserTestCase name="comparison_operators_30" root="e19"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document><![CDATA[03-24-1988 04:55:23,03-24-1988 04:55:24]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e19>
          <dateTime1>1988-03-24T04:55:23</dateTime1>
          <dateTime2>1988-03-24T04:55:24</dateTime2>
          <oneLTtwo>true</oneLTtwo>
        </e19>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_31
        Schema: comparisonOperators 
          Root: e20
       Purpose: This test demonstrates that comparison operators work for dateTime
  -->

  <tdml:parserTestCase name="comparison_operators_31" root="e20"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document><![CDATA[03-24-1988 04:55:23,03-24-1988 04:55:24]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e20>
          <dateTime1>1988-03-24T04:55:23</dateTime1>
          <dateTime2>1988-03-24T04:55:24</dateTime2>
          <notEqual>true</notEqual>
        </e20>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_32
        Schema: comparisonOperators 
          Root: e21
       Purpose: This test demonstrates that comparison operators work for dateTime
  -->

  <tdml:parserTestCase name="comparison_operators_32" root="e21"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document><![CDATA[03-24-1988 04:55:23,03-24-1988 04:55:23]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e21>
          <dateTime1>1988-03-24T04:55:23</dateTime1>
          <dateTime2>1988-03-24T04:55:23</dateTime2>
          <same>true</same>
        </e21>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_33
        Schema: comparisonOperators 
          Root: e22
       Purpose: This test demonstrates that comparison operators work for date
  -->

  <tdml:parserTestCase name="comparison_operators_33" root="e22"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document><![CDATA[03-23-1988,03-24-1988]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e22>
          <date1>1988-03-23</date1>
          <date2>1988-03-24</date2>
          <lessThanEqualTo>true</lessThanEqualTo>
        </e22>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_34
        Schema: comparisonOperators 
          Root: e23
       Purpose: This test demonstrates that comparison operators work for date
  -->

  <tdml:parserTestCase name="comparison_operators_34" root="e23"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document><![CDATA[03-24-1988,03-23-1988]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e23>
          <date1>1988-03-24</date1>
          <date2>1988-03-23</date2>
          <greaterThanEqualTo>true</greaterThanEqualTo>
        </e23>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_35
        Schema: comparisonOperators 
          Root: e24
       Purpose: This test demonstrates that comparison operators work for date
  -->

  <tdml:parserTestCase name="comparison_operators_35" root="e24"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document><![CDATA[03-24-1988,03-23-1988]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e24>
          <date1>1988-03-24</date1>
          <date2>1988-03-23</date2>
          <oneGTtwo>true</oneGTtwo>
        </e24>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_36
        Schema: comparisonOperators 
          Root: e25
       Purpose: This test demonstrates that comparison operators work for date
  -->

  <tdml:parserTestCase name="comparison_operators_36" root="e25"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document><![CDATA[03-24-1988,03-25-1988]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e25>
          <date1>1988-03-24</date1>
          <date2>1988-03-25</date2>
          <oneLTtwo>true</oneLTtwo>
        </e25>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_37
        Schema: comparisonOperators 
          Root: e26
       Purpose: This test demonstrates that comparison operators work for date
  -->

  <tdml:parserTestCase name="comparison_operators_37" root="e26"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document><![CDATA[03-24-1988,03-25-1988]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e26>
          <date1>1988-03-24</date1>
          <date2>1988-03-25</date2>
          <notEqual>true</notEqual>
        </e26>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_38
        Schema: comparisonOperators 
          Root: e27
       Purpose: This test demonstrates that comparison operators work for date
  -->

  <tdml:parserTestCase name="comparison_operators_38" root="e27"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document><![CDATA[03-24-1988,03-24-1988]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e27>
          <date1>1988-03-24</date1>
          <date2>1988-03-24</date2>
          <same>true</same>
        </e27>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
    <!--
     Test Name: comparison_operators_39
        Schema: comparisonOperators 
          Root: e28
       Purpose: This test demonstrates that comparison operators work for time
  -->

  <tdml:parserTestCase name="comparison_operators_39" root="e28"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document><![CDATA[04:55:23,04:55:24]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e28>
          <time1>04:55:23</time1>
          <time2>04:55:24</time2>
          <lessThanEqualTo>true</lessThanEqualTo>
        </e28>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_40
        Schema: comparisonOperators 
          Root: e29
       Purpose: This test demonstrates that comparison operators work for time
  -->

  <tdml:parserTestCase name="comparison_operators_40" root="e29"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document><![CDATA[04:55:24,04:55:23]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e29>
          <time1>04:55:24</time1>
          <time2>04:55:23</time2>
          <greaterThanEqualTo>true</greaterThanEqualTo>
        </e29>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_41
        Schema: comparisonOperators 
          Root: e30
       Purpose: This test demonstrates that comparison operators work for time
  -->

  <tdml:parserTestCase name="comparison_operators_41" root="e30"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document><![CDATA[04:55:24,04:55:23]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e30>
          <time1>04:55:24</time1>
          <time2>04:55:23</time2>
          <oneGTtwo>true</oneGTtwo>
        </e30>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_42
        Schema: comparisonOperators 
          Root: e31
       Purpose: This test demonstrates that comparison operators work for time
  -->

  <tdml:parserTestCase name="comparison_operators_42" root="e31"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document><![CDATA[04:55:23,04:55:24]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e31>
          <time1>04:55:23</time1>
          <time2>04:55:24</time2>
          <oneLTtwo>true</oneLTtwo>
        </e31>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_43
        Schema: comparisonOperators 
          Root: e32
       Purpose: This test demonstrates that comparison operators work for time
  -->

  <tdml:parserTestCase name="comparison_operators_43" root="e32"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document><![CDATA[04:55:23,04:55:24]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e32>
          <time1>04:55:23</time1>
          <time2>04:55:24</time2>
          <notEqual>true</notEqual>
        </e32>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_44
        Schema: comparisonOperators 
          Root: e33
       Purpose: This test demonstrates that comparison operators work for time
  -->

  <tdml:parserTestCase name="comparison_operators_44" root="e33"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document><![CDATA[04:55:23,04:55:23]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e33>
          <time1>04:55:23</time1>
          <time2>04:55:23</time2>
          <same>true</same>
        </e33>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: comparison_operators_45
        Schema: comparisonOperators 
          Root: e34
       Purpose: This test demonstrates that comparison operators work for dateTime
       			Example taken from spec. Determinate example.
  -->

  <tdml:parserTestCase name="comparison_operators_45" root="e34"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document><![CDATA[2000-01-15T00:00:00,2000-02-15T00:00:00]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e34>
          <dateTime1>2000-01-15T00:00:00</dateTime1>
          <dateTime2>2000-02-15T00:00:00</dateTime2>
          <oneLTtwo>true</oneLTtwo>
        </e34>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: comparison_operators_46
        Schema: comparisonOperators 
          Root: e35
       Purpose: This test demonstrates that comparison operators work for dateTime
       			Example taken from spec. Indeterminate example.
  -->

  <tdml:parserTestCase name="comparison_operators_46" root="e35"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1"
    roundTrip="twoPass">

    <tdml:document><![CDATA[2000-01-01T12:00:00,1999-12-31T23:00:00+00:00]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e35>
          <dateTime1>2000-01-01T12:00:00+00:00</dateTime1>
          <dateTime2>1999-12-31T23:00:00+00:00</dateTime2>
          <oneLTtwo>false</oneLTtwo>
        </e35>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <tdml:parserTestCase name="comparison_operators_46a" root="e35a"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1"
    roundTrip="twoPass">

    <tdml:document><![CDATA[2000-01-01T12:00:00,1999-12-31T23:00:00+00:00]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e35a>
          <dateTime1>2000-01-01T12:00:00</dateTime1>
          <dateTime2>1999-12-31T23:00:00+00:00</dateTime2>
          <oneLTtwo>true</oneLTtwo>
        </e35a>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  
  <!--
     Test Name: comparison_operators_47
        Schema: comparisonOperators 
          Root: e36
       Purpose: This test demonstrates that comparison operators work for dateTime
                From XPath spec examples in sec 10.4.6.1 in http://www.w3.org/TR/xpath-functions/
  -->

  <tdml:parserTestCase name="comparison_operators_47" root="e36"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document><![CDATA[2002-04-02T12:00:00-01:00,2002-04-02T17:00:00+04:00]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e36>
          <dateTime1>2002-04-02T12:00:00-01:00</dateTime1>
          <dateTime2>2002-04-02T17:00:00+04:00</dateTime2>
          <same>true</same>
        </e36>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_48
        Schema: comparisonOperators 
          Root: e36
       Purpose: This test demonstrates that comparison operators work for dateTime
                From XPath spec examples in sec 10.4.6.1 in http://www.w3.org/TR/xpath-functions/
  -->

  <tdml:parserTestCase name="comparison_operators_48" root="e36"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document><![CDATA[2002-04-02T12:00:00-05:00,2002-04-02T23:00:00+06:00]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e36>
          <dateTime1>2002-04-02T12:00:00-05:00</dateTime1>
          <dateTime2>2002-04-02T23:00:00+06:00</dateTime2>
          <same>true</same>
        </e36>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_49
        Schema: comparisonOperators 
          Root: e36
       Purpose: This test demonstrates that comparison operators work for dateTime
                From XPath spec examples in sec 10.4.6.1 in http://www.w3.org/TR/xpath-functions/
  -->

  <tdml:parserTestCase name="comparison_operators_49" root="e36"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document><![CDATA[2002-04-02T12:00:00-05:00,2002-04-02T17:00:00-05:00]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e36>
          <dateTime1>2002-04-02T12:00:00-05:00</dateTime1>
          <dateTime2>2002-04-02T17:00:00-05:00</dateTime2>
          <same>false</same>
        </e36>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_50
        Schema: comparisonOperators 
          Root: e36
       Purpose: This test demonstrates that comparison operators work for dateTime
                From XPath spec examples in sec 10.4.6.1 in http://www.w3.org/TR/xpath-functions/
  -->

  <tdml:parserTestCase name="comparison_operators_50" root="e36"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document><![CDATA[2002-04-02T12:00:00-05:00,2002-04-02T12:00:00-05:00]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e36>
          <dateTime1>2002-04-02T12:00:00-05:00</dateTime1>
          <dateTime2>2002-04-02T12:00:00-05:00</dateTime2>
          <same>true</same>
        </e36>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_51
        Schema: comparisonOperators 
          Root: e36
       Purpose: This test demonstrates that comparison operators work for dateTime
                From XPath spec examples in sec 10.4.6.1 in http://www.w3.org/TR/xpath-functions/
  -->

  <tdml:parserTestCase name="comparison_operators_51" root="e36"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document><![CDATA[2002-04-02T23:00:00-04:00,2002-04-03T02:00:00-01:00]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e36>
          <dateTime1>2002-04-02T23:00:00-04:00</dateTime1>
          <dateTime2>2002-04-03T02:00:00-01:00</dateTime2>
          <same>true</same>
        </e36>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_52
        Schema: comparisonOperators 
          Root: e36
       Purpose: This test demonstrates that comparison operators work for dateTime
                From XPath spec examples in sec 10.4.6.1 in http://www.w3.org/TR/xpath-functions/
                
                NOTE: 2000-01-01T00:00:00 == 1999-12-31T24:00:00, so it appears that 
                2000-01-01T00:00:00 is printed instead.
  -->

  <tdml:parserTestCase name="comparison_operators_52" root="e36"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1"
    roundTrip="twoPass">

    <tdml:document><![CDATA[1999-12-31T24:00:00-05:00,2000-01-01T00:00:00-05:00]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e36>
          <dateTime1>2000-01-01T00:00:00-05:00</dateTime1>
          <dateTime2>2000-01-01T00:00:00-05:00</dateTime2>
          <same>true</same>
        </e36>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_53
        Schema: comparisonOperators 
          Root: e36
       Purpose: This test demonstrates that comparison operators work for dateTime
                From XPath spec examples in sec 10.4.6.1 in http://www.w3.org/TR/xpath-functions/
  -->

  <tdml:parserTestCase name="comparison_operators_53" root="e36"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1"
    roundTrip="twoPass">

    <tdml:document><![CDATA[2005-04-04T24:00:00-05:00,2005-04-04T00:00:00-05:00]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e36>
          <dateTime1>2005-04-05T00:00:00-05:00</dateTime1>
          <dateTime2>2005-04-04T00:00:00-05:00</dateTime2>
          <same>false</same>
        </e36>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_54
        Schema: comparisonOperators 
          Root: e39
       Purpose: This test demonstrates that comparison operators work for boolean
  -->

  <tdml:parserTestCase name="comparison_operators_54" root="e39"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document><![CDATA[true,true]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e39>
          <bool1>true</bool1>
          <bool2>true</bool2>
          <same>true</same>
        </e39>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_55
        Schema: comparisonOperators 
          Root: e39
       Purpose: This test demonstrates that comparison operators work for boolean
  -->

  <tdml:parserTestCase name="comparison_operators_55" root="e39"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document><![CDATA[true,false]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e39>
          <bool1>true</bool1>
          <bool2>false</bool2>
          <same>false</same>
        </e39>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_56
        Schema: comparisonOperators 
          Root: e39
       Purpose: This test demonstrates that comparison operators work for boolean
  -->

  <tdml:parserTestCase name="comparison_operators_56" root="e39"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document><![CDATA[false,false]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e39>
          <bool1>false</bool1>
          <bool2>false</bool2>
          <same>true</same>
        </e39>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_57
        Schema: comparisonOperators 
          Root: e40
       Purpose: This test demonstrates that comparison operators work for boolean
  -->

  <tdml:parserTestCase name="comparison_operators_57" root="e40"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document><![CDATA[false,true]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e40>
          <bool1>false</bool1>
          <bool2>true</bool2>
          <oneLTtwo>true</oneLTtwo>
        </e40>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_58
        Schema: comparisonOperators 
          Root: e40
       Purpose: This test demonstrates that comparison operators work for boolean
  -->

  <tdml:parserTestCase name="comparison_operators_58" root="e40"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document><![CDATA[true,true]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e40>
          <bool1>true</bool1>
          <bool2>true</bool2>
          <oneLTtwo>false</oneLTtwo>
        </e40>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_59
        Schema: comparisonOperators 
          Root: e40
       Purpose: This test demonstrates that comparison operators work for boolean
  -->

  <tdml:parserTestCase name="comparison_operators_59" root="e40"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document><![CDATA[true,false]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e40>
          <bool1>true</bool1>
          <bool2>false</bool2>
          <oneLTtwo>false</oneLTtwo>
        </e40>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_60
        Schema: comparisonOperators 
          Root: e40
       Purpose: This test demonstrates that comparison operators work for boolean
  -->

  <tdml:parserTestCase name="comparison_operators_60" root="e40"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document><![CDATA[false,false]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e40>
          <bool1>false</bool1>
          <bool2>false</bool2>
          <oneLTtwo>false</oneLTtwo>
        </e40>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_61
        Schema: comparisonOperators 
          Root: e41
       Purpose: This test demonstrates that comparison operators work for boolean
  -->

  <tdml:parserTestCase name="comparison_operators_61" root="e41"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document><![CDATA[true,false]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e41>
          <bool1>true</bool1>
          <bool2>false</bool2>
          <oneGTtwo>true</oneGTtwo>
        </e41>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_62
        Schema: comparisonOperators 
          Root: e41
       Purpose: This test demonstrates that comparison operators work for boolean
  -->

  <tdml:parserTestCase name="comparison_operators_62" root="e41"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document><![CDATA[true,true]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e41>
          <bool1>true</bool1>
          <bool2>true</bool2>
          <oneGTtwo>false</oneGTtwo>
        </e41>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_63
        Schema: comparisonOperators 
          Root: e41
       Purpose: This test demonstrates that comparison operators work for boolean
  -->

  <tdml:parserTestCase name="comparison_operators_63" root="e41"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document><![CDATA[true,false]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e41>
          <bool1>true</bool1>
          <bool2>false</bool2>
          <oneGTtwo>true</oneGTtwo>
        </e41>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_64
        Schema: comparisonOperators 
          Root: e41
       Purpose: This test demonstrates that comparison operators work for boolean
  -->

  <tdml:parserTestCase name="comparison_operators_64" root="e41"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document><![CDATA[false,false]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e41>
          <bool1>false</bool1>
          <bool2>false</bool2>
          <oneGTtwo>false</oneGTtwo>
        </e41>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_65
        Schema: comparisonOperators 
          Root: e42
       Purpose: This test demonstrates that comparison operators work for boolean
  -->

  <tdml:parserTestCase name="comparison_operators_65" root="e42"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document><![CDATA[false,false]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e42>
          <bool1>false</bool1>
          <bool2>false</bool2>
          <oneLEtwo>true</oneLEtwo>
        </e42>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_66
        Schema: comparisonOperators 
          Root: e42
       Purpose: This test demonstrates that comparison operators work for boolean
  -->

  <tdml:parserTestCase name="comparison_operators_66" root="e42"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document><![CDATA[false,true]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e42>
          <bool1>false</bool1>
          <bool2>true</bool2>
          <oneLEtwo>true</oneLEtwo>
        </e42>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_67
        Schema: comparisonOperators 
          Root: e42
       Purpose: This test demonstrates that comparison operators work for boolean
  -->

  <tdml:parserTestCase name="comparison_operators_67" root="e42"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document><![CDATA[true,false]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e42>
          <bool1>true</bool1>
          <bool2>false</bool2>
          <oneLEtwo>false</oneLEtwo>
        </e42>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_68
        Schema: comparisonOperators 
          Root: e42
       Purpose: This test demonstrates that comparison operators work for boolean
  -->

  <tdml:parserTestCase name="comparison_operators_68" root="e42"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document><![CDATA[true,true]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e42>
          <bool1>true</bool1>
          <bool2>true</bool2>
          <oneLEtwo>true</oneLEtwo>
        </e42>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_69
        Schema: comparisonOperators 
          Root: e43
       Purpose: This test demonstrates that comparison operators work for boolean
  -->

  <tdml:parserTestCase name="comparison_operators_69" root="e43"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document><![CDATA[true,false]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e43>
          <bool1>true</bool1>
          <bool2>false</bool2>
          <oneGEtwo>true</oneGEtwo>
        </e43>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_70
        Schema: comparisonOperators 
          Root: e43
       Purpose: This test demonstrates that comparison operators work for boolean
  -->

  <tdml:parserTestCase name="comparison_operators_70" root="e43"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document><![CDATA[true,true]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e43>
          <bool1>true</bool1>
          <bool2>true</bool2>
          <oneGEtwo>true</oneGEtwo>
        </e43>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_71
        Schema: comparisonOperators 
          Root: e43
       Purpose: This test demonstrates that comparison operators work for boolean
  -->

  <tdml:parserTestCase name="comparison_operators_71" root="e43"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document><![CDATA[false,false]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e43>
          <bool1>false</bool1>
          <bool2>false</bool2>
          <oneGEtwo>true</oneGEtwo>
        </e43>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_72
        Schema: comparisonOperators 
          Root: e43
       Purpose: This test demonstrates that comparison operators work for boolean
  -->

  <tdml:parserTestCase name="comparison_operators_72" root="e43"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document><![CDATA[false,true]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e43>
          <bool1>false</bool1>
          <bool2>true</bool2>
          <oneGEtwo>false</oneGEtwo>
        </e43>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_73
        Schema: comparisonOperators 
          Root: e44
       Purpose: This test demonstrates that comparison operators work for boolean
  -->

  <tdml:parserTestCase name="comparison_operators_73" root="e44"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document><![CDATA[true,true]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e44>
          <bool1>true</bool1>
          <bool2>true</bool2>
          <notEqual>false</notEqual>
        </e44>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_74
        Schema: comparisonOperators 
          Root: e44
       Purpose: This test demonstrates that comparison operators work for boolean
  -->

  <tdml:parserTestCase name="comparison_operators_74" root="e44"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document><![CDATA[false,true]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e44>
          <bool1>false</bool1>
          <bool2>true</bool2>
          <notEqual>true</notEqual>
        </e44>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_75
        Schema: comparisonOperators 
          Root: e44
       Purpose: This test demonstrates that comparison operators work for boolean
  -->

  <tdml:parserTestCase name="comparison_operators_75" root="e44"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document><![CDATA[cray,false]]></tdml:document>
    <tdml:errors>
        <tdml:error>Value 'cray' is not a valid xs:boolean</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <!--
     Test Name: comparison_operators_78
        Schema: comparisonOperators
          Root: e45
       Purpose: This test demonstrates that int and unsignedLong types can compare
  -->

  <tdml:parserTestCase name="comparison_operators_78" root="e45"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>0,0</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e45>
          <int1>0</int1>
          <ulong1>0</ulong1>
          <intEqULong>true</intEqULong>
        </e45>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: comparison_operators_79
        Schema: comparisonOperators
          Root: e45
       Purpose: This test demonstrates that int and unsignedLong types can compare
  -->

  <tdml:parserTestCase name="comparison_operators_79" root="e45"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>1,0</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e45>
          <int1>1</int1>
          <ulong1>0</ulong1>
          <intEqULong>false</intEqULong>
        </e45>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: comparison_operators_80
        Schema: comparisonOperators
          Root: e46
       Purpose: This test demonstrates that hexBinary values can be compared for equality
  -->

  <tdml:parserTestCase name="comparison_operators_80" root="e46"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>
      <tdml:documentPart type="byte"><![CDATA[FF FF FF FF FF FF]]></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e46>
          <hexBinary1>FFFFFF</hexBinary1>
          <hexBinary2>FFFFFF</hexBinary2>
          <equal>true</equal>
        </e46>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: comparison_operators_81
        Schema: comparisonOperators
          Root: e46
       Purpose: This test demonstrates that hexBinary values can be compared for equality
  -->

  <tdml:parserTestCase name="comparison_operators_81" root="e46"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>
      <tdml:documentPart type="byte"><![CDATA[FF FF FF AA AA AA]]></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e46>
          <hexBinary1>FFFFFF</hexBinary1>
          <hexBinary2>AAAAAA</hexBinary2>
          <equal>false</equal>
        </e46>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: comparison_operators_82
        Schema: comparisonOperators
          Root: e47
       Purpose: This test demonstrates that hexBinary values can be compared for non-equality
  -->

  <tdml:parserTestCase name="comparison_operators_82" root="e47"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>
      <tdml:documentPart type="byte"><![CDATA[FF FF FF AA AA AA]]></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e47>
          <hexBinary1>FFFFFF</hexBinary1>
          <hexBinary2>AAAAAA</hexBinary2>
          <notEqual>true</notEqual>
        </e47>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: comparison_operators_83
        Schema: comparisonOperators
          Root: e47
       Purpose: This test demonstrates that hexBinary values can be compared for non-equality
  -->

  <tdml:parserTestCase name="comparison_operators_83" root="e47"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>
      <tdml:documentPart type="byte"><![CDATA[FF FF FF FF FF FF]]></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e47>
          <hexBinary1>FFFFFF</hexBinary1>
          <hexBinary2>FFFFFF</hexBinary2>
          <notEqual>false</notEqual>
        </e47>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: beyondRoot_01
        Schema: paths 
          Root: e6
       Purpose: This test demonstrates that DFDL will detect if a path expression goes beyond the bounds of the tree 
  -->

  <tdml:parserTestCase name="beyondRoot_01" root="e6"
    model="paths" description="Section 23 - DFDL Expressions">

    <tdml:document>1,2,3</tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <!--
     Test Name: quuery_style_01
        Schema: paths
          Root: e7
       Purpose: This test demonstrates that Daffodil does not support query style path expressions
  -->

  <tdml:parserTestCase name="query_style_01" root="e7"
    model="paths" description="Section 23 - DFDL Expressions">

    <tdml:document>1,2,3</tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Statically ambiguous or query-style paths not supported</tdml:error>
      <tdml:error>ex:a</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <!--
     Test Name: quuery_style_02
        Schema: paths
          Root: e8
       Purpose: This test demonstrates that Daffodil does not support query style path expressions
  -->

  <tdml:parserTestCase name="query_style_02" root="e8"
    model="paths" description="Section 23 - DFDL Expressions">

    <tdml:document>1,2,3</tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Statically ambiguous or query-style paths not supported</tdml:error>
      <tdml:error>ex:a</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <!--
     Test Name: diagnostics_01
        Schema: diagnostics 
          Root: e1
       Purpose: This test demonstrates that DFDL will provide meaningful diagnostics for invalid path expressions 
  -->

  <tdml:parserTestCase name="diagnostics_01" root="e1"
    model="diagnostics" description="Section 23 - DFDL Expressions">

    <tdml:document>1,2,3</tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Invalid</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
     Test Name: diagnostics_02
        Schema: diagnostics 
          Root: e2
       Purpose: This test demonstrates that DFDL will provide meaningful diagnostics for invalid path expressions 
  -->

  <tdml:parserTestCase name="diagnostics_02" root="e2"
    model="diagnostics" description="Section 23 - DFDL Expressions">

    <tdml:document>1,2,3</tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Invalid</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <!--
     Test Name: diagnostics_03
        Schema: diagnostics 
          Root: e3
       Purpose: This test demonstrates that DFDL will provide meaningful diagnostics for invalid path expressions 
  -->

  <tdml:parserTestCase name="diagnostics_03" root="e3"
    model="diagnostics" description="Section 23 - DFDL Expressions">

    <tdml:document>1,2,3</tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Invalid</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>



  <tdml:defineSchema name="XPathMath">
    <xs:include schemaLocation="org/apache/daffodil/xsd/DFDLGeneralFormat.dfdl.xsd"/>
    <dfdl:format ref="ex:GeneralFormat"/>

    <xs:element name="div01" type="xs:double" dfdl:inputValueCalc="{ xs:double(5) div xs:double(2) }" />
    <xs:element name="div02" type="xs:float" dfdl:inputValueCalc="{ xs:float(5) div xs:float(2) }" />
    <xs:element name="div03" type="xs:decimal" dfdl:inputValueCalc="{ xs:decimal(5) div xs:decimal(2) }" />
    <xs:element name="div04" type="xs:decimal" dfdl:inputValueCalc="{ xs:integer(5) div xs:integer(2) }" />
    <xs:element name="div05" type="xs:float" dfdl:inputValueCalc="{ xs:int(5) div xs:int(2) }" />
    <xs:element name="div06" type="xs:float" dfdl:inputValueCalc="{ xs:short(5) div xs:short(2) }" />
    <xs:element name="div07" type="xs:double" dfdl:inputValueCalc="{ xs:double(5) div xs:double(0) }" />
    <xs:element name="div08" type="xs:float" dfdl:inputValueCalc="{ xs:float(5) div xs:float(0) }" />
    <xs:element name="div09" type="xs:decimal" dfdl:inputValueCalc="{ xs:decimal(5) div xs:decimal(0) }" />
    <xs:element name="div10" type="xs:decimal" dfdl:inputValueCalc="{ xs:integer(5) div xs:integer(0) }" />
    <xs:element name="div11" type="xs:float" dfdl:inputValueCalc="{ xs:int(5) div xs:int(0) }" />
    <xs:element name="div12" type="xs:float" dfdl:inputValueCalc="{ xs:short(5) div xs:short(0) }" />
    <xs:element name="div13" type="xs:double" dfdl:inputValueCalc="{ xs:double('INF') div xs:double(2) }" />
    <xs:element name="div14" type="xs:float" dfdl:inputValueCalc="{ xs:float('INF') div xs:float(2) }" />
    <xs:element name="div15" type="xs:double" dfdl:inputValueCalc="{ xs:double('NaN') div xs:double(2) }" />
    <xs:element name="div16" type="xs:float" dfdl:inputValueCalc="{ xs:float('NaN') div xs:float(2) }" />
    <xs:element name="div17" type="xs:double" dfdl:inputValueCalc="{ xs:double(5) div xs:double('NaN') }" />
    <xs:element name="div18" type="xs:float" dfdl:inputValueCalc="{ xs:float(5) div xs:float('NaN') }" />
    <xs:element name="div19" type="xs:double" dfdl:inputValueCalc="{ xs:double(5) div xs:double('INF') }" />
    <xs:element name="div20" type="xs:float" dfdl:inputValueCalc="{ xs:float(5) div xs:float('INF') }" />
    <xs:element name="div21" type="xs:double" dfdl:inputValueCalc="{ 90.0 div 1234567.0 }" />
    <xs:element name="div22" type="xs:decimal" dfdl:inputValueCalc="{ (9 * xs:long(5)) div 1600 }" />
    <xs:element name="div23" type="xs:double" dfdl:inputValueCalc="{ (9 * xs:long(5)) div 1600 }" />
    <xs:element name="div24" type="xs:float" dfdl:inputValueCalc="{ (xs:int(5)) div xs:int(3) }" />

    <xs:element name="idiv01" type="xs:int" dfdl:inputValueCalc="{ xs:double(5) idiv xs:double(2) }" />
    <xs:element name="idiv02" type="xs:int" dfdl:inputValueCalc="{ xs:float(5) idiv xs:float(2) }" />
    <xs:element name="idiv03" type="xs:int" dfdl:inputValueCalc="{ xs:decimal(5) idiv xs:decimal(2) }" />
    <xs:element name="idiv04" type="xs:int" dfdl:inputValueCalc="{ xs:integer(5) idiv xs:integer(2) }" />
    <xs:element name="idiv05" type="xs:int" dfdl:inputValueCalc="{ xs:int(5) idiv xs:int(2) }" />
    <xs:element name="idiv06" type="xs:int" dfdl:inputValueCalc="{ xs:short(5) idiv xs:short(2) }" />
    <xs:element name="idiv07" type="xs:int" dfdl:inputValueCalc="{ xs:double(5) idiv xs:double(0) }" />
    <xs:element name="idiv08" type="xs:int" dfdl:inputValueCalc="{ xs:float(5) idiv xs:float(0) }" />
    <xs:element name="idiv09" type="xs:int" dfdl:inputValueCalc="{ xs:decimal(5) idiv xs:decimal(0) }" />
    <xs:element name="idiv10" type="xs:int" dfdl:inputValueCalc="{ xs:integer(5) idiv xs:integer(0) }" />
    <xs:element name="idiv11" type="xs:int" dfdl:inputValueCalc="{ xs:int(5) idiv xs:int(0) }" />
    <xs:element name="idiv12" type="xs:int" dfdl:inputValueCalc="{ xs:short(5) idiv xs:short(0) }" />
    <xs:element name="idiv13" type="xs:int" dfdl:inputValueCalc="{ xs:double('INF') idiv xs:double(2) }" />
    <xs:element name="idiv14" type="xs:int" dfdl:inputValueCalc="{ xs:float('INF') idiv xs:float(2) }" />
    <xs:element name="idiv15" type="xs:int" dfdl:inputValueCalc="{ xs:double('NaN') idiv xs:double(2) }" />
    <xs:element name="idiv16" type="xs:int" dfdl:inputValueCalc="{ xs:float('NaN') idiv xs:float(2) }" />
    <xs:element name="idiv17" type="xs:int" dfdl:inputValueCalc="{ xs:double(5) idiv xs:double('NaN') }" />
    <xs:element name="idiv18" type="xs:int" dfdl:inputValueCalc="{ xs:float(5) idiv xs:float('NaN') }" />
    <xs:element name="idiv19" type="xs:int" dfdl:inputValueCalc="{ xs:double(5) idiv xs:double('INF') }" />
    <xs:element name="idiv20" type="xs:int" dfdl:inputValueCalc="{ xs:float(5) idiv xs:float('INF') }" />

    <xs:element name="add01" type="xs:int" dfdl:inputValueCalc="{ xs:unsignedInt(5) + (-1) }" />
  </tdml:defineSchema>

  <tdml:parserTestCase name="div01" root="div01" model="XPathMath" description="Section 23 - DFDL Expressions - div">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><div01>2.5</div01></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="div02" root="div02" model="XPathMath" description="Section 23 - DFDL Expressions - div">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><div02>2.5</div02></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="div03" root="div03" model="XPathMath" description="Section 23 - DFDL Expressions - div">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><div03>2.5</div03></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="div04" root="div04" model="XPathMath" description="Section 23 - DFDL Expressions - div">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><div04>2.5</div04></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="div05" root="div05" model="XPathMath" description="Section 23 - DFDL Expressions - div">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><div05>2.5</div05></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="div06" root="div06" model="XPathMath" description="Section 23 - DFDL Expressions - div">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><div06>2.5</div06></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="div07" root="div07" model="XPathMath" description="Section 23 - DFDL Expressions - div">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><div07>INF</div07></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="div08" root="div08" model="XPathMath" description="Section 23 - DFDL Expressions - div">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><div08>INF</div08></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="div09" root="div09" model="XPathMath" description="Section 23 - DFDL Expressions - div">
    <tdml:document></tdml:document>
    <tdml:errors>
      <tdml:error>by zero</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="div10" root="div10" model="XPathMath" description="Section 23 - DFDL Expressions - div">
    <tdml:document></tdml:document>
    <tdml:errors>
      <tdml:error>by zero</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="div11" root="div11" model="XPathMath" description="Section 23 - DFDL Expressions - div">
    <tdml:document></tdml:document>
    <tdml:errors>
      <tdml:error>by zero</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="div12" root="div12" model="XPathMath" description="Section 23 - DFDL Expressions - div">
    <tdml:document></tdml:document>
    <tdml:errors>
      <tdml:error>by zero</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="div13" root="div13" model="XPathMath" description="Section 23 - DFDL Expressions - div">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><div13>INF</div13></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="div14" root="div14" model="XPathMath" description="Section 23 - DFDL Expressions - div">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><div14>INF</div14></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="div15" root="div15" model="XPathMath" description="Section 23 - DFDL Expressions - div">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><div15>NaN</div15></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="div16" root="div16" model="XPathMath" description="Section 23 - DFDL Expressions - div">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><div16>NaN</div16></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="div17" root="div17" model="XPathMath" description="Section 23 - DFDL Expressions - div">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><div17>NaN</div17></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="div18" root="div18" model="XPathMath" description="Section 23 - DFDL Expressions - div">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><div18>NaN</div18></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="div19" root="div19" model="XPathMath" description="Section 23 - DFDL Expressions - div">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><div19>0.0</div19></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="div20" root="div20" model="XPathMath" description="Section 23 - DFDL Expressions - div">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><div20>0.0</div20></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="div21" root="div21" model="XPathMath" description="Section 23 - DFDL Expressions - div">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><div21>7.290005321703885E-5</div21></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="div22" root="div22" model="XPathMath" description="Section 23 - DFDL Expressions - div"
    config="cfg_errorOnResultCoercion">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><div22>0.028125</div22></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="div23" root="div23" model="XPathMath" description="Section 23 - DFDL Expressions - div"
    config="cfg_errorOnResultCoercion">
    <tdml:document></tdml:document>
      <tdml:errors>
        <tdml:error>result type</tdml:error>
        <tdml:error>Decimal</tdml:error>
        <tdml:error>must be manually cast</tdml:error>
        <tdml:error>Double</tdml:error>
      </tdml:errors>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="div24" root="div24" model="XPathMath" description="Section 23 - DFDL Expressions - div"
    config="cfg_errorOnResultCoercion">
    <tdml:document></tdml:document>
      <tdml:errors>
        <tdml:error>result type</tdml:error>
        <tdml:error>Decimal</tdml:error>
        <tdml:error>must be manually cast</tdml:error>
        <tdml:error>Float</tdml:error>
      </tdml:errors>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="idiv01" root="idiv01" model="XPathMath" description="Section 23 - DFDL Expressions - idiv">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><idiv01>2</idiv01></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="idiv02" root="idiv02" model="XPathMath" description="Section 23 - DFDL Expressions - idiv">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><idiv02>2</idiv02></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="idiv03" root="idiv03" model="XPathMath" description="Section 23 - DFDL Expressions - idiv">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><idiv03>2</idiv03></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="idiv04" root="idiv04" model="XPathMath" description="Section 23 - DFDL Expressions - idiv">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><idiv04>2</idiv04></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="idiv05" root="idiv05" model="XPathMath" description="Section 23 - DFDL Expressions - idiv">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><idiv05>2</idiv05></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="idiv06" root="idiv06" model="XPathMath" description="Section 23 - DFDL Expressions - idiv">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><idiv06>2</idiv06></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="idiv07" root="idiv07" model="XPathMath" description="Section 23 - DFDL Expressions - idiv">
    <tdml:document></tdml:document>
    <tdml:errors>
      <tdml:error>by zero</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="idiv08" root="idiv08" model="XPathMath" description="Section 23 - DFDL Expressions - idiv">
    <tdml:document></tdml:document>
    <tdml:errors>
      <tdml:error>by zero</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="idiv09" root="idiv09" model="XPathMath" description="Section 23 - DFDL Expressions - idiv">
    <tdml:document></tdml:document>
    <tdml:errors>
      <tdml:error>by zero</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="idiv10" root="idiv10" model="XPathMath" description="Section 23 - DFDL Expressions - idiv">
    <tdml:document></tdml:document>
    <tdml:errors>
      <tdml:error>by zero</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="idiv11" root="idiv11" model="XPathMath" description="Section 23 - DFDL Expressions - idiv">
    <tdml:document></tdml:document>
    <tdml:errors>
      <tdml:error>by zero</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="idiv12" root="idiv12" model="XPathMath" description="Section 23 - DFDL Expressions - idiv">
    <tdml:document></tdml:document>
    <tdml:errors>
      <tdml:error>by zero</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="idiv13" root="idiv13" model="XPathMath" description="Section 23 - DFDL Expressions - idiv">
    <tdml:document></tdml:document>
    <tdml:errors>
      <tdml:error>integer division</tdml:error>
      <tdml:error>Infinity</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="idiv14" root="idiv14" model="XPathMath" description="Section 23 - DFDL Expressions - idiv">
    <tdml:document></tdml:document>
    <tdml:errors>
      <tdml:error>integer division</tdml:error>
      <tdml:error>Infinity</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="idiv15" root="idiv15" model="XPathMath" description="Section 23 - DFDL Expressions - idiv">
    <tdml:document></tdml:document>
    <tdml:errors>
      <tdml:error>integer division</tdml:error>
      <tdml:error>NaN</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="idiv16" root="idiv16" model="XPathMath" description="Section 23 - DFDL Expressions - idiv">
    <tdml:document></tdml:document>
    <tdml:errors>
      <tdml:error>integer division</tdml:error>
      <tdml:error>NaN</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="idiv17" root="idiv17" model="XPathMath" description="Section 23 - DFDL Expressions - idiv">
    <tdml:document></tdml:document>
    <tdml:errors>
      <tdml:error>integer division</tdml:error>
      <tdml:error>NaN</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="idiv18" root="idiv18" model="XPathMath" description="Section 23 - DFDL Expressions - idiv">
    <tdml:document></tdml:document>
    <tdml:errors>
      <tdml:error>integer division</tdml:error>
      <tdml:error>NaN</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="idiv19" root="idiv19" model="XPathMath" description="Section 23 - DFDL Expressions - div">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><idiv19>0</idiv19></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="idiv20" root="idiv20" model="XPathMath" description="Section 23 - DFDL Expressions - div">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><idiv20>0</idiv20></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="add01" root="add01" model="XPathMath" description="Section 23 - DFDL Expressions - div">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><add01>4</add01></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

</tdml:testSuite>
