<?xml version="1.0" encoding="UTF-8"?>
<!--
  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->

<tdml:testSuite suiteName="SimpleTypes" description="Section 5 - simple types"
  xmlns:tdml="http://www.ibm.com/xmlns/dfdl/testData" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:dfdl="http://www.ogf.org/dfdl/dfdl-1.0/" xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:fn="http://www.w3.org/2005/xpath-functions"
  xmlns:math="http://www.w3.org/2005/xpath-functions/math"
  xmlns:ex="http://example.com"
  defaultRoundTrip="onePass">
    
  <tdml:defineSchema name="Functions.dfdl.xsd">
    <xs:include schemaLocation="org/apache/daffodil/xsd/DFDLGeneralFormat.dfdl.xsd"/>
    <dfdl:format ref="ex:GeneralFormat" initiator=""
      separator="," terminator="" leadingSkip="0" trailingSkip="0"
      textBidi="no" floating="no" byteOrder="bigEndian"
      alignment="1" alignmentUnits="bytes" fillByte="f" occursCountKind="implicit"
      truncateSpecifiedLengthString="no" ignoreCase="no" representation="text"
      lengthKind="delimited" nilValueDelimiterPolicy="both"
      emptyValueDelimiterPolicy="none" documentFinalTerminatorCanBeMissing="yes"
      initiatedContent="no" separatorSuppressionPolicy="trailingEmpty" separatorPosition="infix" />

    <xs:element name="testBit">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="byte" type="xs:byte"
            dfdl:representation="binary" dfdl:lengthKind="implicit" />
          <xs:element name="bit0" type="xs:boolean"
            dfdl:lengthKind="implicit" dfdl:inputValueCalc="{ dfdl:testBit( ../ex:byte, 0) }" />
          <xs:element name="bit7" type="xs:boolean"
            dfdl:lengthKind="implicit" dfdl:inputValueCalc="{ dfdl:testBit( ../ex:byte, 7) }" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="testBit1">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="byte" type="xs:byte"
            dfdl:representation="binary" dfdl:lengthKind="implicit" />
          <xs:element name="bit1" type="xs:boolean"
            dfdl:lengthKind="implicit" dfdl:inputValueCalc="{ dfdl:testBit( ../ex:byte, 1) }" />
          <xs:element name="bit2" type="xs:boolean"
            dfdl:lengthKind="implicit" dfdl:inputValueCalc="{ dfdl:testBit( ../ex:byte, 2) }" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="testBit2">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="int" type="xs:unsignedInt" dfdl:representation="binary" dfdl:lengthKind="implicit" />
          <xs:element name="bit1" type="xs:boolean"
            dfdl:lengthKind="implicit" dfdl:inputValueCalc="{ dfdl:testBit( ../ex:int, 1) }" />
          <xs:element name="bit2" type="xs:boolean"
            dfdl:lengthKind="implicit" dfdl:inputValueCalc="{ dfdl:testBit( ../ex:int, 2) }" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="testBit3">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="byte" type="xs:byte"
            dfdl:representation="binary" dfdl:lengthKind="implicit" />
          <xs:element name="bit0" type="xs:boolean"
            dfdl:lengthKind="implicit" dfdl:inputValueCalc="{ dfdl:testBit( ../ex:byte) }" />
          <xs:element name="bit7" type="xs:boolean"
            dfdl:lengthKind="implicit" dfdl:inputValueCalc="{ dfdl:testBit( ../ex:byte, 7) }" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="testBit4">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="byte" type="xs:byte"
            dfdl:representation="binary" dfdl:lengthKind="implicit" />
          <xs:element name="bit0" type="xs:boolean"
            dfdl:lengthKind="implicit" dfdl:inputValueCalc="{ dfdl:testBit( ../ex:byte, 7, 1) }" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="setBits">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="e" type="xs:byte" dfdl:lengthKind="implicit"
            dfdl:representation="binary" />
          <xs:element name="e0" type="xs:unsignedByte" dfdl:lengthKind="implicit"
            dfdl:inputValueCalc="{ dfdl:setBits(1, 0, 0, 0, 0, 0 , 0, 0) }" />
          <xs:element name="e1" type="xs:unsignedByte" dfdl:lengthKind="implicit"
            dfdl:inputValueCalc="{ dfdl:setBits(0, 1, 0, 0, 0, 0 , 0, 0) }" />
          <xs:element name="e2" type="xs:unsignedByte" dfdl:lengthKind="implicit"
            dfdl:inputValueCalc="{ dfdl:setBits(0, 0, 1, 0, 0, 0 , 0, 0) }" />
          <xs:element name="e3" type="xs:unsignedByte" dfdl:lengthKind="implicit"
            dfdl:inputValueCalc="{ dfdl:setBits(0, 0, 0, 1, 0, 0 , 0, 0) }" />
          <xs:element name="e4" type="xs:unsignedByte" dfdl:lengthKind="implicit"
            dfdl:inputValueCalc="{ dfdl:setBits(0, 0, 0, 0, 1, 0 , 0, 0) }" />
          <xs:element name="e5" type="xs:unsignedByte" dfdl:lengthKind="implicit"
            dfdl:inputValueCalc="{ dfdl:setBits(0, 0, 0, 0, 0, 1 , 0, 0) }" />
          <xs:element name="e6" type="xs:unsignedByte" dfdl:lengthKind="implicit"
            dfdl:inputValueCalc="{ dfdl:setBits(0, 0, 0, 0, 0, 0 , 1, 0) }" />
          <xs:element name="e7" type="xs:unsignedByte" dfdl:lengthKind="implicit"
            dfdl:inputValueCalc="{ dfdl:setBits(0, 0, 0, 0, 0, 0 , 0, 1) }" />
          <xs:element name="e8" type="xs:unsignedByte" dfdl:lengthKind="implicit"
            dfdl:inputValueCalc="{ dfdl:setBits(1, 1, 1, 1, 1, 1 , 1, 1) }" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="setBits1" type="xs:byte" dfdl:lengthKind="implicit"
            dfdl:inputValueCalc="{ dfdl:setBits(0, 0, 1, 0 , 0, 0) }" />
    
    <xs:element name="setBits2">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="e0" type="xs:int" dfdl:lengthKind="explicit" dfdl:length="1" dfdl:representation="text" />
          <xs:element name="e1" type="xs:int" dfdl:lengthKind="explicit" dfdl:length="1" dfdl:representation="text" />
          <xs:element name="e2" type="xs:int" dfdl:lengthKind="explicit" dfdl:length="1" dfdl:representation="text" />
          <xs:element name="e3" type="xs:int" dfdl:lengthKind="explicit" dfdl:length="1" dfdl:representation="text" />
          <xs:element name="e4" type="xs:int" dfdl:lengthKind="explicit" dfdl:length="1" dfdl:representation="text" />
          <xs:element name="e5" type="xs:int" dfdl:lengthKind="explicit" dfdl:length="1" dfdl:representation="text" />
          <xs:element name="e6" type="xs:int" dfdl:lengthKind="explicit" dfdl:length="1" dfdl:representation="text" />
          <xs:element name="e7" type="xs:int" dfdl:lengthKind="explicit" dfdl:length="1" dfdl:representation="text" />
          <xs:element name="e" type="xs:byte" dfdl:lengthKind="implicit" dfdl:inputValueCalc="{ dfdl:setBits(/ex:setBits2/ex:e7, /ex:setBits2/ex:e6, /ex:setBits2/ex:e5, /ex:setBits2/ex:e4, /ex:setBits2/ex:e3, /ex:setBits2/ex:e2, /ex:setBits2/ex:e1, /ex:setBits2/ex:e0) }" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="more_count">
      <xs:annotation>
        <xs:appinfo source="http://www.ogf.org/dfdl/">
          <dfdl:assert test="{ fn:count( /ex:more_count ) eq 3 }"
            message="Assertion 
            failed for fn:count( /ex:more_count ) eq 3" />
        </xs:appinfo>
      </xs:annotation>
      <xs:complexType>
        <xs:sequence>
          <xs:element name="i1" type="xs:int" />
          <xs:element name="i2" type="xs:int" />
          <xs:element name="i3" type="xs:int" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="more_count1">
      <xs:annotation>
        <xs:appinfo source="http://www.ogf.org/dfdl/">
          <dfdl:assert test="{ fn:count( /ex:more_count1 ) eq 3 }"
            message="Assertion 
            failed for fn:count( /ex:more_count ) eq 3" />
        </xs:appinfo>
      </xs:annotation>
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="i1" type="xs:int" dfdl:initiator="#:" minOccurs="1" maxOccurs="10"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="more_count1b">
      <xs:annotation>
        <xs:appinfo source="http://www.ogf.org/dfdl/">
          <dfdl:assert test="{ fn:count( /ex:more_count1b ) eq 1 }"
            message="Assertion 
            failed for fn:count( /ex:more_count ) eq 1" />
        </xs:appinfo>
      </xs:annotation>
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="i1" type="xs:int" dfdl:initiator="#:" minOccurs="1" maxOccurs="10"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="more_count2">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="array">
            <xs:complexType>
              <xs:sequence dfdl:separator=",">
                <xs:element name="i1" type="xs:int" dfdl:initiator="#:" minOccurs="1" maxOccurs="10"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="occurs" type="xs:int" dfdl:inputValueCalc="{ fn:count(/ex:more_count2/ex:array) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="more_count3">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="array">
            <xs:complexType>
              <xs:sequence dfdl:separator=",">
                <xs:element name="i1" type="xs:int" dfdl:initiator="#:" minOccurs="1" maxOccurs="10"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="occurs" type="xs:int" dfdl:inputValueCalc="{ fn:count(/ex:more_count3/ex:array/ex:i1) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="more_count4">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="array" minOccurs="1" maxOccurs="10">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="i1" type="xs:int" dfdl:initiator="#:" />
                <xs:element name="count" type="xs:int" dfdl:inputValueCalc="{ fn:count(..) }"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="stringLiteralFromString">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="str" type="xs:string"
            dfdl:representation="text" />
          <xs:element name="literal" type="xs:string"
            dfdl:lengthKind="implicit"
            dfdl:inputValueCalc="{ dfdl:stringLiteralFromString( ../ex:str) }" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="encodeDFDLEntities">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="str" type="xs:string"
            dfdl:representation="text" />
          <xs:element name="literal" type="xs:string"
            dfdl:lengthKind="implicit"
            dfdl:inputValueCalc="{ dfdl:encodeDFDLEntities( ../ex:str) }" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="containsEntity">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="str" type="xs:string"
            dfdl:representation="text" />
          <xs:element name="hasEntity" type="xs:boolean"
            dfdl:lengthKind="implicit" dfdl:inputValueCalc="{ dfdl:containsEntity('TEST%NL;TEST') }" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="containsDFDLEntities">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="str" type="xs:string"
            dfdl:representation="text" />
          <xs:element name="hasEntity" type="xs:boolean"
            dfdl:lengthKind="implicit" dfdl:inputValueCalc="{ dfdl:containsDFDLEntities('TEST%NL;TEST') }" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="containsDFDLEntities1">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="str" type="xs:string"  dfdl:representation="text" />
          <xs:element name="hasEntity" type="xs:boolean"
            dfdl:lengthKind="implicit" dfdl:inputValueCalc="{ dfdl:containsDFDLEntities(xs:string(/ex:containsDFDLEntities1/ex:str)) }" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="valueLength">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="str" type="xs:string"  dfdl:lengthKind="delimited" dfdl:textTrimKind="padChar" 
            dfdl:textStringPadCharacter="/" dfdl:textStringJustification="center" />
          <xs:element name="valLen" type="xs:long"
            dfdl:lengthKind="delimited" dfdl:inputValueCalc="{ dfdl:valueLength( ../ex:str, 'bits') }" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="valueLength2">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="str" type="xs:string"  dfdl:lengthKind="delimited" dfdl:textTrimKind="padChar" 
            dfdl:textStringPadCharacter="/" dfdl:textStringJustification="center" />
          <xs:element name="valLen" type="xs:long"
            dfdl:lengthKind="delimited" dfdl:inputValueCalc="{ dfdl:valueLength( ../ex:str, 'bytes' ) }" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="valueLength3">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="str" type="xs:string" dfdl:lengthKind="delimited" dfdl:textTrimKind="padChar"
            dfdl:textStringPadCharacter="/" dfdl:textStringJustification="center" />
          <xs:element name="valLen" type="xs:long"
            dfdl:lengthKind="delimited" dfdl:inputValueCalc="{ dfdl:valueLength( ../ex:str, 'characters') }" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <dfdl:defineEscapeScheme name="es1">
      <dfdl:escapeScheme escapeCharacter='*'
        escapeKind="escapeCharacter" escapeEscapeCharacter="!"
        extraEscapedCharacters="?" generateEscapeBlock="whenNeeded" />
    </dfdl:defineEscapeScheme>

    <xs:element name="valueLength4">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="str" type="xs:string"  dfdl:lengthKind="delimited" dfdl:textTrimKind="padChar"
            dfdl:textStringPadCharacter="/" dfdl:textStringJustification="center" dfdl:escapeSchemeRef="ex:es1"
            dfdl:terminator=";" />
          <xs:element name="valLen" type="xs:long"
            dfdl:lengthKind="delimited" dfdl:inputValueCalc="{ dfdl:valueLength( ../ex:str, 'bytes' ) }" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="valueLength5">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="str" type="xs:string"  dfdl:lengthKind="delimited" dfdl:textTrimKind="padChar"
            dfdl:textStringPadCharacter="/" dfdl:textStringJustification="center" dfdl:escapeSchemeRef="ex:es1"
            dfdl:terminator=";" />
          <xs:element name="valLen" type="xs:string"
            dfdl:lengthKind="delimited" dfdl:outputValueCalc="{ xs:string(dfdl:valueLength( ../ex:str, 'bits' )) }" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="valueLength6">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="str" type="xs:string"  dfdl:lengthKind="delimited" dfdl:textTrimKind="padChar"
            dfdl:textStringPadCharacter="/" dfdl:textStringJustification="center" />
          <xs:element name="valLen" type="xs:string"
            dfdl:lengthKind="delimited" dfdl:outputValueCalc="{ xs:string(dfdl:valueLength( ../ex:str, 'characters')) }" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="valueLength7">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="str" type="xs:string"  dfdl:lengthKind="delimited" dfdl:textTrimKind="padChar"
            dfdl:textStringPadCharacter="/" dfdl:textStringJustification="center" />
          <xs:element name="valLen" type="xs:string"
            dfdl:lengthKind="delimited" dfdl:outputValueCalc="{ xs:string(dfdl:valueLength( ../ex:str, 'bytes')) }" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="valueLength8">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="str" type="xs:string"  dfdl:lengthKind="delimited"
             nillable="true" dfdl:nilKind="literalValue" dfdl:nilValue="NIL" />
          <xs:element name="valLen" type="xs:long"
            dfdl:lengthKind="delimited" dfdl:inputValueCalc="{ dfdl:valueLength( ../ex:str, 'bytes' ) }" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="valueLength9">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="str" type="xs:string"  dfdl:lengthKind="delimited"
             nillable="true" dfdl:nilKind="literalValue" dfdl:nilValue="NIL" />
          <xs:element name="valLen" type="xs:string"
            dfdl:lengthKind="delimited" dfdl:outputValueCalc="{ xs:string(dfdl:valueLength( ../ex:str, 'bytes' )) }" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="valueLength10">
      <xs:complexType>
        <xs:sequence dfdl:separator="/">
          <xs:element name="seq">
            <xs:complexType>
              <xs:sequence dfdl:initiatedContent="no"
                dfdl:separatorPosition="infix" dfdl:separator=","
                dfdl:separatorSuppressionPolicy="anyEmpty" dfdl:terminator=";">
                <xs:element name="num" type="xs:int" maxOccurs="unbounded"
                  minOccurs="0" />
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="valLen" type="xs:long"
            dfdl:lengthKind="delimited" dfdl:inputValueCalc="{ dfdl:valueLength( ../ex:seq, 'bytes' ) }" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="valueLength11">
      <xs:complexType>
        <xs:sequence dfdl:separator="/">
          <xs:element name="seq">
            <xs:complexType>
              <xs:sequence dfdl:initiatedContent="no"
                dfdl:separatorPosition="infix" dfdl:separator=","
                dfdl:separatorSuppressionPolicy="anyEmpty" dfdl:terminator=";">
                <xs:element name="num" type="xs:int" maxOccurs="unbounded"
                  minOccurs="0" />
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="valLen" type="xs:string"
            dfdl:lengthKind="delimited" dfdl:outputValueCalc="{ xs:string(dfdl:valueLength( ../ex:seq, 'bytes' )) }" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="valueLength12">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="str" type="xs:string"  dfdl:lengthKind="delimited" />
          <xs:element name="valLen" type="xs:string"
            dfdl:lengthKind="delimited" dfdl:inputValueCalc="{ xs:string(dfdl:valueLength( ../ex:str, 'wrong')) }" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="valueLength13">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="x" dfdl:lengthKind="explicit" dfdl:length="{ 1 }">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="y" type="xs:int" maxOccurs="2" dfdl:occursCountKind="expression"
                  dfdl:occursCount='{ if(dfdl:valueLength(.., "bits") eq 0) then 1 else 2 }' />
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="contentLength">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="str" type="xs:string"  dfdl:lengthKind="delimited" dfdl:textTrimKind="padChar" 
            dfdl:textStringPadCharacter="/" dfdl:textStringJustification="center" />
          <xs:element name="conLen" dfdl:representation="binary" dfdl:lengthKind="implicit" type="xs:unsignedLong"
            dfdl:inputValueCalc="{ dfdl:contentLength( ../ex:str, 'bytes' ) }" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="contentLength2">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="str" type="xs:string"  dfdl:lengthKind="delimited" dfdl:textTrimKind="padChar" 
            dfdl:textStringPadCharacter="/" dfdl:textStringJustification="center" />
          <xs:element name="conLen" dfdl:lengthKind="delimited" type="xs:long" dfdl:inputValueCalc="{ dfdl:contentLength( ../ex:str, 'bits' ) }" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="contentLength3">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="x" dfdl:lengthKind="explicit" dfdl:length="{ 1 }">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="y" type="xs:int" maxOccurs="2" dfdl:occursCountKind="expression"
                  dfdl:occursCount='{ if (dfdl:contentLength(.., "bits") eq 0) then 1 else 2 }' />
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e_concat">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="one" type="xs:int" dfdl:lengthKind="delimited"/>
          <xs:element name="two" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="concat" type="xs:string" dfdl:inputValueCalc="{ fn:concat(../ex:one,../ex:two) }"/>
          <xs:element name="concat2" type="xs:string" dfdl:inputValueCalc="{ fn:concat(../ex:concat,'2') }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e_concat2" type="xs:string" dfdl:inputValueCalc="{ fn:concat(1, 'cat', 0.2) }" />

    <xs:element name="e_concat3">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="one" type="xs:float" dfdl:lengthKind="delimited" dfdl:textNumberPattern="#E0" />
          <xs:element name="two" type="xs:dateTime" dfdl:lengthKind="delimited"/>
          <xs:element name="concat" type="xs:string" dfdl:inputValueCalc="{ fn:concat(../ex:one,../ex:two) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e_concat4" type="xs:int" dfdl:inputValueCalc="{ xs:int(fn:concat(1, 2)) }" />
    <xs:element name="e_concat5" type="xs:string" dfdl:inputValueCalc="{ fn:concat('a','','b','c') }" />

    <xs:element name="e_substring1" type="xs:string" dfdl:inputValueCalc="{ fn:substring('A substring test', 6) }" />
    <xs:element name="e_substring2" type="xs:string" dfdl:inputValueCalc="{ fn:substring('A substring test', 3, 9) }" />
    <xs:element name="e_substring3" type="xs:string" dfdl:inputValueCalc="{ fn:substring('A substring test', -5) }" />
    <xs:element name="e_substring4" type="xs:string" dfdl:inputValueCalc="{ fn:substring('A substring test', 15, 5) }" />
    <xs:element name="e_substring5" type="xs:string" dfdl:inputValueCalc="{ fn:substring('A substring test', 20) }" />
    <xs:element name="e_substring6" type="xs:string" dfdl:inputValueCalc="{ fn:substring('A substring test', 4.7, 6.01) }" />
    <xs:element name="e_substring7">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="start" type="xs:double" dfdl:lengthKind="delimited"/>
          <xs:element name="length" type="xs:double" dfdl:lengthKind="delimited"/>
          <xs:element name="substring" type="xs:string" dfdl:inputValueCalc="{ fn:substring(../ex:string,../ex:start,../ex:length) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    <xs:element name="e_substring8" type="xs:string" dfdl:inputValueCalc="{ fn:substring('', 1, 2) }" />
    <xs:element name="e_substring9" type="xs:string" dfdl:inputValueCalc="{ fn:substring('12345', -42, 1 div 0E0) }" />
    <xs:element name="e_substring10" type="xs:string" dfdl:inputValueCalc="{ fn:substring('12345', -1 div 0E0, 1 div 0E0) }" />
    <xs:element name="e_substring11" type="xs:string" dfdl:inputValueCalc="{ fn:substring('12345', -3, 5) }" />

    <xs:element name="e_stringlength1" type="xs:int" dfdl:inputValueCalc="{ fn:string-length('string') }" />
    <xs:element name="e_stringlength2" type="xs:int" dfdl:inputValueCalc="{ fn:string-length() }" />
    <xs:element name="e_stringlength3" type="xs:int" dfdl:inputValueCalc="{ fn:string-length('') }" />
    <xs:element name="e_stringlength4">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="one" type="xs:string" />
          <xs:element name="length" type="xs:int" dfdl:inputValueCalc="{ fn:string-length(../ex:one) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e_uppercase1" type="xs:string" dfdl:inputValueCalc="{ fn:upper-case('test upper') }" />
    <xs:element name="e_uppercase2" type="xs:string" dfdl:inputValueCalc="{ fn:upper-case('TeSt UpPeR') }" />
    <xs:element name="e_uppercase3" type="xs:string" dfdl:inputValueCalc="{ fn:upper-case('') }" />

    <xs:element name="e_lowercase1" type="xs:string" dfdl:inputValueCalc="{ fn:lower-case('TEST LOWER') }" />
    <xs:element name="e_lowercase2" type="xs:string" dfdl:inputValueCalc="{ fn:lower-case('TeSt LoWeR') }" />
    <xs:element name="e_lowercase3" type="xs:string" dfdl:inputValueCalc="{ fn:lower-case('') }" />

    <xs:element name="e_contains1" type="xs:boolean" dfdl:inputValueCalc="{ fn:contains('The quick brown fox.', 'quick') }" />
    <xs:element name="e_contains2" type="xs:boolean" dfdl:inputValueCalc="{ fn:contains('The quick brown fox.', 'slow') }" />
    <xs:element name="e_contains3" type="xs:boolean" dfdl:inputValueCalc="{ fn:contains('The quick brown fox.', '') }" />
    <xs:element name="e_contains4" type="xs:boolean" dfdl:inputValueCalc="{ fn:contains('', 'test') }" />
    <xs:element name="e_contains5">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="one" type="xs:string" dfdl:lengthKind="delimited" />
          <xs:element name="two" type="xs:string" dfdl:lengthKind="delimited" />
          <xs:element name="contains" type="xs:boolean" dfdl:inputValueCalc="{ fn:contains(../ex:one, ../ex:two) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    <xs:element name="e_contains6" type="xs:boolean" dfdl:inputValueCalc="{ fn:contains('test', 'est', 'collation') }" />

    <xs:element name="e_startswith1" type="xs:boolean" dfdl:inputValueCalc="{ fn:starts-with('The quick brown fox.', 'The q') }" />
    <xs:element name="e_startswith2" type="xs:boolean" dfdl:inputValueCalc="{ fn:starts-with('The quick brown fox.', 'he qu') }" />
    <xs:element name="e_startswith3" type="xs:boolean" dfdl:inputValueCalc="{ fn:starts-with('The quick brown fox.', '') }" />
    <xs:element name="e_startswith4" type="xs:boolean" dfdl:inputValueCalc="{ fn:starts-with('', 'The') }" />
    <xs:element name="e_startswith5">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="one" type="xs:string" dfdl:lengthKind="delimited" />
          <xs:element name="two" type="xs:string" dfdl:lengthKind="delimited" />
          <xs:element name="starts" type="xs:boolean" dfdl:inputValueCalc="{ fn:starts-with(../ex:one, ../ex:two) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    <xs:element name="e_startswith6" type="xs:boolean" dfdl:inputValueCalc="{ fn:starts-with('test', 'te', 'collation') }" />

    <xs:element name="e_endswith1" type="xs:boolean" dfdl:inputValueCalc="{ fn:ends-with('The quick brown fox.', 'fox.') }" />
    <xs:element name="e_endswith2" type="xs:boolean" dfdl:inputValueCalc="{ fn:ends-with('The quick brown fox.', 'The') }" />
    <xs:element name="e_endswith3" type="xs:boolean" dfdl:inputValueCalc="{ fn:ends-with('The quick brown fox.', '') }" />
    <xs:element name="e_endswith4" type="xs:boolean" dfdl:inputValueCalc="{ fn:ends-with('', 'fox') }" />
    <xs:element name="e_endswith5">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="one" type="xs:string" dfdl:lengthKind="delimited" />
          <xs:element name="two" type="xs:string" dfdl:lengthKind="delimited" />
          <xs:element name="ends" type="xs:boolean" dfdl:inputValueCalc="{ fn:ends-with(../ex:one, ../ex:two) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    <xs:element name="e_endswith6" type="xs:boolean" dfdl:inputValueCalc="{ fn:ends-with('test', 'est', 'collation') }" />

    <xs:element name="e_substringbefore1" type="xs:string" dfdl:inputValueCalc="{ fn:substring-before('The quick brown fox.', 'quick') }" />
    <xs:element name="e_substringbefore2" type="xs:string" dfdl:inputValueCalc="{ fn:substring-before('', '') }" />
    <xs:element name="e_substringbefore3" type="xs:string" dfdl:inputValueCalc="{ fn:substring-before('The quick brown fox.', '') }" />
    <xs:element name="e_substringbefore4">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="one" type="xs:string" dfdl:lengthKind="delimited" />
          <xs:element name="two" type="xs:string" dfdl:lengthKind="delimited" />
          <xs:element name="before" type="xs:string" dfdl:inputValueCalc="{ fn:substring-before(../ex:one, ../ex:two) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    <xs:element name="e_substringbefore5" type="xs:string" dfdl:inputValueCalc="{ fn:substring-before('test', 's', 'collation') }" />
    <xs:element name="e_substringbefore6" type="xs:string" dfdl:inputValueCalc="{ fn:substring-before('test') }" />

    <xs:element name="e_substringafter1" type="xs:string" dfdl:inputValueCalc="{ fn:substring-after('The quick brown fox.', 'brown') }" />
    <xs:element name="e_substringafter2" type="xs:string" dfdl:inputValueCalc="{ fn:substring-after('', '') }" />
    <xs:element name="e_substringafter3" type="xs:string" dfdl:inputValueCalc="{ fn:substring-after('The quick brown fox.', '') }" />
    <xs:element name="e_substringafter4">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="one" type="xs:string" dfdl:lengthKind="delimited" />
          <xs:element name="two" type="xs:string" dfdl:lengthKind="delimited" />
          <xs:element name="after" type="xs:string" dfdl:inputValueCalc="{ fn:substring-after(../ex:one, ../ex:two) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    <xs:element name="e_substringafter5" type="xs:string" dfdl:inputValueCalc="{ fn:substring-after('test', 'e', 'collation') }" />

    <xs:element name="e_yearfromdatetime1" type="xs:int" dfdl:inputValueCalc="{ fn:year-from-dateTime(xs:dateTime('1999-05-31T13:20:00-05:00')) }" />
    <xs:element name="e_yearfromdatetime2">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="date" type="xs:dateTime" dfdl:lengthKind="delimited" />
          <xs:element name="year" type="xs:int" dfdl:inputValueCalc="{ fn:year-from-dateTime(../ex:date) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e_monthfromdatetime1" type="xs:int" dfdl:inputValueCalc="{ fn:month-from-dateTime(xs:dateTime('1999-05-31T13:20:00-05:00')) }" />
    <xs:element name="e_monthfromdatetime2">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="date" type="xs:dateTime" dfdl:lengthKind="delimited" />
          <xs:element name="month" type="xs:int" dfdl:inputValueCalc="{ fn:month-from-dateTime(../ex:date) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e_dayfromdatetime1" type="xs:int" dfdl:inputValueCalc="{ fn:day-from-dateTime(xs:dateTime('1999-05-31T13:20:00-05:00')) }" />
    <xs:element name="e_dayfromdatetime2">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="date" type="xs:dateTime" dfdl:lengthKind="delimited" />
          <xs:element name="day" type="xs:int" dfdl:inputValueCalc="{ fn:day-from-dateTime(../ex:date) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e_hoursfromdatetime1" type="xs:int" dfdl:inputValueCalc="{ fn:hours-from-dateTime(xs:dateTime('1999-05-31T13:20:00-05:00')) }" />
    <xs:element name="e_hoursfromdatetime2">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="date" type="xs:dateTime" dfdl:lengthKind="delimited" />
          <xs:element name="hours" type="xs:int" dfdl:inputValueCalc="{ fn:hours-from-dateTime(../ex:date) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e_minutesfromdatetime1" type="xs:int" dfdl:inputValueCalc="{ fn:minutes-from-dateTime(xs:dateTime('1999-05-31T13:20:00-05:00')) }" />
    <xs:element name="e_minutesfromdatetime2">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="date" type="xs:dateTime" dfdl:lengthKind="delimited" />
          <xs:element name="minutes" type="xs:int" dfdl:inputValueCalc="{ fn:minutes-from-dateTime(../ex:date) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e_secondsfromdatetime1" type="xs:decimal" dfdl:inputValueCalc="{ fn:seconds-from-dateTime(xs:dateTime('1999-05-31T13:20:00-05:00')) }" />
    <xs:element name="e_secondsfromdatetime2">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="date" type="xs:dateTime" dfdl:lengthKind="delimited" />
          <xs:element name="seconds" type="xs:decimal" dfdl:inputValueCalc="{ fn:seconds-from-dateTime(../ex:date) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    <xs:element name="e_secondsfromdatetime3">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="date" type="xs:dateTime" dfdl:calendarPatternKind="explicit" dfdl:lengthKind="explicit"
            dfdl:length="22" dfdl:calendarPattern="uuuu-MM-dd'T'HH:mm:ss.SS" />
          <xs:element name="seconds" type="xs:decimal" dfdl:inputValueCalc="{ fn:seconds-from-dateTime(../ex:date) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e_xfromdatetime1">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="date" type="xs:dateTime" dfdl:calendarPatternKind="explicit" dfdl:lengthKind="explicit"
            dfdl:length="45" dfdl:calendarPattern="'It is 'hh:mm:ss' on the 'd'st of 'MMMM', year 'yyyy" />
          <xs:element name="year" type="xs:int" dfdl:inputValueCalc="{ fn:year-from-dateTime(../ex:date) }"/>
          <xs:element name="month" type="xs:int" dfdl:inputValueCalc="{ fn:month-from-dateTime(../ex:date) }"/>
          <xs:element name="day" type="xs:int" dfdl:inputValueCalc="{ fn:day-from-dateTime(../ex:date) }"/>
          <xs:element name="hours" type="xs:int" dfdl:inputValueCalc="{ fn:hours-from-dateTime(../ex:date) }"/>
          <xs:element name="minutes" type="xs:int" dfdl:inputValueCalc="{ fn:minutes-from-dateTime(../ex:date) }"/>
          <xs:element name="seconds" type="xs:decimal" dfdl:inputValueCalc="{ fn:seconds-from-dateTime(../ex:date) }"/>
          <xs:element name="timeZone" type="xs:string" dfdl:inputValueCalc="{ dfdl:timeZoneFromDateTime(../ex:date) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e_xfromdatetime2">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="date" type="xs:dateTime" dfdl:calendarCheckPolicy="lax" dfdl:calendarPatternKind="implicit"
            dfdl:lengthKind="explicit" dfdl:length="19" dfdl:calendarTimeZone="UTC" />
          <xs:element name="year" type="xs:int" dfdl:inputValueCalc="{ fn:year-from-dateTime(../ex:date) }"/>
          <xs:element name="month" type="xs:int" dfdl:inputValueCalc="{ fn:month-from-dateTime(../ex:date) }"/>
          <xs:element name="day" type="xs:int" dfdl:inputValueCalc="{ fn:day-from-dateTime(../ex:date) }"/>
          <xs:element name="hours" type="xs:int" dfdl:inputValueCalc="{ fn:hours-from-dateTime(../ex:date) }"/>
          <xs:element name="minutes" type="xs:int" dfdl:inputValueCalc="{ fn:minutes-from-dateTime(../ex:date) }"/>
          <xs:element name="seconds" type="xs:decimal" dfdl:inputValueCalc="{ fn:seconds-from-dateTime(../ex:date) }"/>
          <xs:element name="timeZone" type="xs:string" dfdl:inputValueCalc="{ dfdl:timeZoneFromDateTime(../ex:date) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e_xfromdatetime3">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="date" type="xs:dateTime" dfdl:calendarCheckPolicy="lax" dfdl:calendarPatternKind="implicit"
            dfdl:lengthKind="explicit" dfdl:length="20" dfdl:calendarTimeZone="UTC-08:00" />
          <xs:element name="year" type="xs:int" dfdl:inputValueCalc="{ fn:year-from-dateTime(../ex:date) }"/>
          <xs:element name="month" type="xs:int" dfdl:inputValueCalc="{ fn:month-from-dateTime(../ex:date) }"/>
          <xs:element name="day" type="xs:int" dfdl:inputValueCalc="{ fn:day-from-dateTime(../ex:date) }"/>
          <xs:element name="hours" type="xs:int" dfdl:inputValueCalc="{ fn:hours-from-dateTime(../ex:date) }"/>
          <xs:element name="minutes" type="xs:int" dfdl:inputValueCalc="{ fn:minutes-from-dateTime(../ex:date) }"/>
          <xs:element name="seconds" type="xs:decimal" dfdl:inputValueCalc="{ fn:seconds-from-dateTime(../ex:date) }"/>
          <xs:element name="timeZone" type="xs:string" dfdl:inputValueCalc="{ dfdl:timeZoneFromDateTime(../ex:date) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e_yearfromdate1" type="xs:int" dfdl:inputValueCalc="{ fn:year-from-date(xs:date('2014-11-03')) }" />
    <xs:element name="e_yearfromdate2">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="date" type="xs:date" dfdl:lengthKind="delimited" />
          <xs:element name="year" type="xs:int" dfdl:inputValueCalc="{ fn:year-from-date(../ex:date) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e_monthfromdate1" type="xs:int" dfdl:inputValueCalc="{ fn:month-from-date(xs:date('2014-11-03')) }" />
    <xs:element name="e_monthfromdate2">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="date" type="xs:date" dfdl:lengthKind="delimited" />
          <xs:element name="month" type="xs:int" dfdl:inputValueCalc="{ fn:month-from-date(../ex:date) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e_dayfromdate1" type="xs:int" dfdl:inputValueCalc="{ fn:day-from-date(xs:date('2014-11-03')) }" />
    <xs:element name="e_dayfromdate2">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="date" type="xs:date" dfdl:lengthKind="delimited" />
          <xs:element name="day" type="xs:int" dfdl:inputValueCalc="{ fn:day-from-date(../ex:date) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e_xfromdate1">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="date" type="xs:date" dfdl:calendarCheckPolicy="lax" dfdl:calendarPatternKind="implicit"
            dfdl:lengthKind="explicit" dfdl:length="11" />
          <xs:element name="year" type="xs:int" dfdl:inputValueCalc="{ fn:year-from-date(../ex:date) }"/>
          <xs:element name="month" type="xs:int" dfdl:inputValueCalc="{ fn:month-from-date(../ex:date) }"/>
          <xs:element name="day" type="xs:int" dfdl:inputValueCalc="{ fn:day-from-date(../ex:date) }"/>
          <xs:element name="timeZone" type="xs:string" dfdl:inputValueCalc="{ dfdl:timeZoneFromDate(../ex:date) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e_xfromdate2">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="date" type="xs:date" dfdl:calendarCheckPolicy="lax" dfdl:calendarPatternKind="implicit"
            dfdl:lengthKind="explicit" dfdl:length="10" dfdl:calendarTimeZone="UTC+01:00" />
          <xs:element name="year" type="xs:int" dfdl:inputValueCalc="{ fn:year-from-date(../ex:date) }"/>
          <xs:element name="month" type="xs:int" dfdl:inputValueCalc="{ fn:month-from-date(../ex:date) }"/>
          <xs:element name="day" type="xs:int" dfdl:inputValueCalc="{ fn:day-from-date(../ex:date) }"/>
          <xs:element name="timeZone" type="xs:string" dfdl:inputValueCalc="{ dfdl:timeZoneFromDate(../ex:date) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e_hoursfromtime1" type="xs:int" dfdl:inputValueCalc="{ fn:hours-from-time(xs:time('13:25:14')) }" />
    <xs:element name="e_hoursfromtime2">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="time" type="xs:time" dfdl:lengthKind="delimited" />
          <xs:element name="hours" type="xs:int" dfdl:inputValueCalc="{ fn:hours-from-time(../ex:time) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e_minutesfromtime1" type="xs:int" dfdl:inputValueCalc="{ fn:minutes-from-time(xs:time('13:25:14')) }" />
    <xs:element name="e_minutesfromtime2">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="time" type="xs:time" dfdl:lengthKind="delimited" />
          <xs:element name="minutes" type="xs:int" dfdl:inputValueCalc="{ fn:minutes-from-time(../ex:time) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e_secondsfromtime1" type="xs:decimal" dfdl:inputValueCalc="{ fn:seconds-from-time(xs:time('13:25:14')) }" />
    <xs:element name="e_secondsfromtime2">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="time" type="xs:time" dfdl:lengthKind="delimited" />
          <xs:element name="seconds" type="xs:decimal" dfdl:inputValueCalc="{ fn:seconds-from-time(../ex:time) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e_xfromtime1">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="time" type="xs:time" dfdl:lengthKind="delimited" />
          <xs:element name="hours" type="xs:int" dfdl:inputValueCalc="{ fn:hours-from-time(../ex:time) }"/>
          <xs:element name="minutes" type="xs:int" dfdl:inputValueCalc="{ fn:minutes-from-time(../ex:time) }"/>
          <xs:element name="seconds" type="xs:decimal" dfdl:inputValueCalc="{ fn:seconds-from-time(../ex:time) }"/>
          <xs:element name="timeZone" type="xs:string" dfdl:inputValueCalc="{ dfdl:timeZoneFromTime(../ex:time) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e_xfromtime2">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="time" type="xs:time" dfdl:lengthKind="delimited" dfdl:calendarPatternKind="explicit"
            dfdl:calendarPattern="HH:mm:ss.SSSz"  />
          <xs:element name="hours" type="xs:int" dfdl:inputValueCalc="{ fn:hours-from-time(../ex:time) }"/>
          <xs:element name="minutes" type="xs:int" dfdl:inputValueCalc="{ fn:minutes-from-time(../ex:time) }"/>
          <xs:element name="seconds" type="xs:decimal" dfdl:inputValueCalc="{ fn:seconds-from-time(../ex:time) }"/>
          <xs:element name="timeZone" type="xs:string" dfdl:inputValueCalc="{ dfdl:timeZoneFromTime(../ex:time) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e_text1">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="str" type="xs:string"  dfdl:lengthKind="delimited" />
          <xs:element name="str2" type="xs:string"
            dfdl:lengthKind="delimited" dfdl:inputValueCalc="{ fn:concat( ../ex:str/text(), 'a') }" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e_text2">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="str" type="xs:string"  dfdl:lengthKind="delimited" />
          <xs:element name="str2" type="xs:string"
            dfdl:lengthKind="delimited" dfdl:inputValueCalc="{ ../ex:str/text() }" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e_timezonefromdatetime1" type="xs:string" dfdl:inputValueCalc="{ dfdl:timeZoneFromDateTime(xs:dateTime('1999-05-31T13:20:00-05:00')) }" />
    <xs:element name="e_timezonefromdatetime2" type="xs:string" dfdl:inputValueCalc="{ dfdl:timeZoneFromDateTime(xs:dateTime('1999-05-31T13:20:00')) }" />
    <xs:element name="e_timezonefromdate1" type="xs:string" dfdl:inputValueCalc="{ dfdl:timeZoneFromDate(xs:date('1999-05-31-05:00')) }" />
    <xs:element name="e_timezonefromdate2" type="xs:string" dfdl:inputValueCalc="{ dfdl:timeZoneFromDate(xs:date('1999-05-31')) }" />
    <xs:element name="e_timezonefromtime1" type="xs:string" dfdl:inputValueCalc="{ dfdl:timeZoneFromTime(xs:time('13:20:00-05:00')) }" />
    <xs:element name="e_timezonefromtime2" type="xs:string" dfdl:inputValueCalc="{ dfdl:timeZoneFromTime(xs:time('13:20:00')) }" />
    <xs:element name="e_timezonefromtime3">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="time" type="xs:time" dfdl:lengthKind="delimited" dfdl:calendarTimeZone="UTC-04:00" />
          <xs:element name="timeZone" type="xs:string" dfdl:inputValueCalc="{ dfdl:timeZoneFromTime(../ex:time) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

</tdml:defineSchema>
  
  <tdml:defineSchema name="Functions-binary.dfdl.xsd">
    <xs:include schemaLocation="org/apache/daffodil/xsd/DFDLGeneralFormat.dfdl.xsd"/>
    <dfdl:format ref="ex:GeneralFormat" initiator=""
      separator="" terminator="" leadingSkip="0" trailingSkip="0"
      textBidi="no" floating="no" byteOrder="bigEndian"
      alignment="1" alignmentUnits="bytes" fillByte="f" occursCountKind="implicit"
      truncateSpecifiedLengthString="no" ignoreCase="no" representation="binary"
      lengthKind="implicit" nilValueDelimiterPolicy="both"
      emptyValueDelimiterPolicy="none" documentFinalTerminatorCanBeMissing="yes"
      initiatedContent="no" separatorSuppressionPolicy="trailingEmpty" separatorPosition="infix" />

    <xs:element name="valueContentLength1">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="c1" dfdl:lengthKind="explicit" dfdl:lengthUnits="bits" dfdl:length="15">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="e1" type="xs:unsignedInt"  dfdl:lengthKind="explicit" dfdl:lengthUnits="bits" dfdl:length="6" />
                <xs:element name="e2" type="xs:unsignedInt"  dfdl:lengthKind="explicit" dfdl:lengthUnits="bits" dfdl:length="6" />
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="e3" type="xs:unsignedInt" dfdl:lengthKind="explicit" dfdl:lengthUnits="bits" dfdl:length="6" />
          <xs:element name="c1CL" type="xs:unsignedInt" dfdl:inputValueCalc="{ dfdl:contentLength(../ex:c1, 'bits') }" />
          <xs:element name="c1VL" type="xs:unsignedInt" dfdl:inputValueCalc="{ dfdl:valueLength(../ex:c1, 'bits') }" />
          <xs:element name="e1CL" type="xs:unsignedInt" dfdl:inputValueCalc="{ dfdl:contentLength(../ex:c1/ex:e1, 'bits') }" />
          <xs:element name="e1VL" type="xs:unsignedInt" dfdl:inputValueCalc="{ dfdl:valueLength(../ex:c1/ex:e1, 'bits') }" />
          <xs:element name="e2CL" type="xs:unsignedInt" dfdl:inputValueCalc="{ dfdl:contentLength(../ex:c1/ex:e2, 'bits') }" />
          <xs:element name="e2VL" type="xs:unsignedInt" dfdl:inputValueCalc="{ dfdl:valueLength(../ex:c1/ex:e2, 'bits') }" />
          <xs:element name="e3CL" type="xs:unsignedInt" dfdl:inputValueCalc="{ dfdl:contentLength(../ex:e3, 'bits') }" />
          <xs:element name="e3VL" type="xs:unsignedInt" dfdl:inputValueCalc="{ dfdl:valueLength(../ex:e3, 'bits') }" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="valueContentLength2">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="c1" dfdl:lengthKind="implicit">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="e1" type="xs:unsignedInt"  dfdl:lengthKind="explicit" dfdl:lengthUnits="bits" dfdl:length="6" />
                <xs:element name="e2" type="xs:unsignedInt"  dfdl:lengthKind="explicit" dfdl:lengthUnits="bits" dfdl:length="6" />
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="e3" type="xs:unsignedInt" dfdl:lengthKind="explicit" dfdl:lengthUnits="bits" dfdl:length="6" />
          <xs:element name="c1CL" type="xs:unsignedInt" dfdl:inputValueCalc="{ dfdl:contentLength(../ex:c1, 'bits') }" />
          <xs:element name="c1VL" type="xs:unsignedInt" dfdl:inputValueCalc="{ dfdl:valueLength(../ex:c1, 'bits') }" />
          <xs:element name="e1CL" type="xs:unsignedInt" dfdl:inputValueCalc="{ dfdl:contentLength(../ex:c1/ex:e1, 'bits') }" />
          <xs:element name="e1VL" type="xs:unsignedInt" dfdl:inputValueCalc="{ dfdl:valueLength(../ex:c1/ex:e1, 'bits') }" />
          <xs:element name="e2CL" type="xs:unsignedInt" dfdl:inputValueCalc="{ dfdl:contentLength(../ex:c1/ex:e2, 'bits') }" />
          <xs:element name="e2VL" type="xs:unsignedInt" dfdl:inputValueCalc="{ dfdl:valueLength(../ex:c1/ex:e2, 'bits') }" />
          <xs:element name="e3CL" type="xs:unsignedInt" dfdl:inputValueCalc="{ dfdl:contentLength(../ex:e3, 'bits') }" />
          <xs:element name="e3VL" type="xs:unsignedInt" dfdl:inputValueCalc="{ dfdl:valueLength(../ex:e3, 'bits') }" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>


  </tdml:defineSchema>

<!--
    Test Name: concat_01
       Schema: Functions.dfdl.xsd
         Root: e_concat
      Purpose: This test demonstrates the use of the concat function to concatenate two or more anyAtomicType objects
               into a string.
-->

  <tdml:parserTestCase name="concat_01" root="e_concat"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:concat - DFDL-23-099R">

    <tdml:document>
      <tdml:documentPart type="text">45,two</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_concat>
          <one>45</one>
          <two>two</two>
          <concat>45two</concat>
          <concat2>45two2</concat2>
        </e_concat>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: concat_02
       Schema: Functions.dfdl.xsd
         Root: e_concat2
      Purpose: This test demonstrates the use of the concat function to concatenate three anyAtomicType objects
               into a string.
-->

  <tdml:parserTestCase name="concat_02" root="e_concat2"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:concat - DFDL-23-099R">

    <tdml:document />
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_concat2>1cat0.2</e_concat2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: concat_03
       Schema: Functions.dfdl.xsd
         Root: e_concat3
      Purpose: This test demonstrates the use of the concat function to concatenate two or more anyAtomicType objects
               into a string.
-->

  <tdml:parserTestCase name="concat_03" root="e_concat3"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:concat - DFDL-23-099R">

    <tdml:document>
      <tdml:documentPart type="text">-5E3,2004-04-12T13:20:00</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_concat3>
          <one>-5000.0</one>
          <two>2004-04-12T13:20:00</two>
          <concat>-5000.02004-04-12T13:20:00</concat>
        </e_concat3>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: concat_04
       Schema: Functions.dfdl.xsd
         Root: e_concat4
      Purpose: This test demonstrates the use of the concat function to concatenate two or more anyAtomicType objects
               into a string.
-->

  <tdml:parserTestCase name="concat_04" root="e_concat4"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:concat - DFDL-23-099R">

    <tdml:document />
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_concat4>12</e_concat4>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: concat_05
       Schema: Functions.dfdl.xsd
         Root: e_concat5
      Purpose: This test demonstrates the use of the concat function to concatenate two or more anyAtomicType objects
               into a string and shows that an empty argument is treated as a zero length string.
-->

  <tdml:parserTestCase name="concat_05" root="e_concat5"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:concat - DFDL-23-099R">

    <tdml:document />
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_concat5>abc</e_concat5>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: substring_01
       Schema: Functions.dfdl.xsd
         Root: e_substring1
      Purpose: This test demonstrates the use of the substring function to return a portion of a string.
-->

  <tdml:parserTestCase name="substring_01" root="e_substring1"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:substring - DFDL-23-100R">

    <tdml:document />
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_substring1>string test</e_substring1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: substring_02
       Schema: Functions.dfdl.xsd
         Root: e_substring2
      Purpose: This test demonstrates the use of the substring function to return a portion of a string.
-->

  <tdml:parserTestCase name="substring_02" root="e_substring2"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:substring - DFDL-23-100R">

    <tdml:document />
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_substring2>substring</e_substring2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: substring_03
       Schema: Functions.dfdl.xsd
         Root: e_substring3
      Purpose: This test demonstrates the use of the substring function to return a portion of a string. When the starting location is negative or zero characters in positions greater than zero are returned.
-->

  <tdml:parserTestCase name="substring_03" root="e_substring3"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:substring - DFDL-23-100R">

    <tdml:document />
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_substring3>A substring test</e_substring3>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: substring_04
       Schema: Functions.dfdl.xsd
         Root: e_substring4
      Purpose: This test demonstrates the use of the substring function to return a portion of a string.
-->

  <tdml:parserTestCase name="substring_04" root="e_substring4"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:substring - DFDL-23-100R">

    <tdml:document />
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_substring4>st</e_substring4>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: substring_05
       Schema: Functions.dfdl.xsd
         Root: e_substring5
      Purpose: This test demonstrates the use of the substring function to return a portion of a string.
-->

  <tdml:parserTestCase name="substring_05" root="e_substring5"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:substring - DFDL-23-100R">

    <tdml:document />
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_substring5/>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: substring_06
       Schema: Functions.dfdl.xsd
         Root: e_substring6
      Purpose: This test demonstrates the use of the substring function to return a portion of a string and that the values for start and length are rounded.
-->

  <tdml:parserTestCase name="substring_06" root="e_substring6"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:substring - DFDL-23-100R">

    <tdml:document />
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_substring6>bstrin</e_substring6>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: substring_07
       Schema: Functions.dfdl.xsd
         Root: e_substring7
      Purpose: This test demonstrates the use of the substring function to return a portion of a string.
-->

  <tdml:parserTestCase name="substring_07" root="e_substring7"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:substring - DFDL-23-100R">

    <tdml:document>A substring test,3,-2</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_substring7>
          <string>A substring test</string>
          <start>3.0</start>
          <length>-2.0</length>
          <substring/>
        </e_substring7>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: substring_08
       Schema: Functions.dfdl.xsd
         Root: e_substring8
      Purpose: This test demonstrates the use of the substring function to return a portion of a string.
-->

  <tdml:parserTestCase name="substring_08" root="e_substring8"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:substring - DFDL-23-100R">

    <tdml:document />
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_substring8/>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: substring_09
       Schema: Functions.dfdl.xsd
         Root: e_substring9
      Purpose: This test demonstrates the use of the substring function to return a portion of a string.
-->

  <tdml:parserTestCase name="substring_09" root="e_substring9"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:substring - DFDL-23-100R">

    <tdml:document />
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_substring9>12345</e_substring9>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: substring_10
       Schema: Functions.dfdl.xsd
         Root: e_substring10
      Purpose: This test demonstrates the use of the substring function to return a portion of a string.
-->

  <tdml:parserTestCase name="substring_10" root="e_substring10"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:substring - DFDL-23-100R">

    <tdml:document />
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_substring10/>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: substring_11
       Schema: Functions.dfdl.xsd
         Root: e_substring11
      Purpose: This test demonstrates the use of the substring function to return a portion of a string.
-->

  <tdml:parserTestCase name="substring_11" root="e_substring11"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:substring - DFDL-23-100R">

    <tdml:document />
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_substring11>1</e_substring11>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: stringlength_01
       Schema: Functions.dfdl.xsd
         Root: e_stringlength1
      Purpose: This test demonstrates the use of the string-length function to return the length of the argument as an integer.
-->

  <tdml:parserTestCase name="stringlength_01" root="e_stringlength1"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:string-length - DFDL-23-101R">

    <tdml:document />
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_stringlength1>6</e_stringlength1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: stringlength_02
       Schema: Functions.dfdl.xsd
         Root: e_stringlength2
      Purpose: This test demonstrates the use of the string-length function to return the length of the argument as an integer.
-->

  <tdml:parserTestCase name="stringlength_02" root="e_stringlength2"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:string-length - DFDL-23-101R">

    <tdml:document />
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>fn:string-length</tdml:error>
      <tdml:error>requires 1 argument</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
    Test Name: stringlength_03
       Schema: Functions.dfdl.xsd
         Root: e_stringlength3
      Purpose: This test demonstrates the use of the string-length function to return the length of the argument as an integer.
-->

  <tdml:parserTestCase name="stringlength_03" root="e_stringlength3"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:string-length - DFDL-23-101R">

    <tdml:document />
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_stringlength3>0</e_stringlength3>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: stringlength_04
       Schema: Functions.dfdl.xsd
         Root: e_stringlength4
      Purpose: This test demonstrates the use of the string-length function to return the length of the argument as an integer.
-->

  <tdml:parserTestCase name="stringlength_04" root="e_stringlength4"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:string-length - DFDL-23-101R">

    <tdml:document>test string</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_stringlength4>
          <one>test string</one>
          <length>11</length>
        </e_stringlength4>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: uppercase_01
       Schema: Functions.dfdl.xsd
         Root: e_uppercase1
      Purpose: This test demonstrates the use of the upper-case function to return the upper case value of the argument.
-->

  <tdml:parserTestCase name="uppercase_01" root="e_uppercase1"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:upper-case - DFDL-23-102R">

    <tdml:document />
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_uppercase1>TEST UPPER</e_uppercase1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: uppercase_02
       Schema: Functions.dfdl.xsd
         Root: e_uppercase2
      Purpose: This test demonstrates the use of the upper-case function to return the upper case value of the argument.
-->

  <tdml:parserTestCase name="uppercase_02" root="e_uppercase2"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:upper-case - DFDL-23-102R">

    <tdml:document />
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_uppercase2>TEST UPPER</e_uppercase2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: uppercase_03
       Schema: Functions.dfdl.xsd
         Root: e_uppercase3
      Purpose: This test demonstrates the use of the upper-case function to return the upper case value of the argument.
-->

  <tdml:parserTestCase name="uppercase_03" root="e_uppercase3"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:upper-case - DFDL-23-102R">

    <tdml:document />
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_uppercase3/>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>


<!--
    Test Name: lowercase_01
       Schema: Functions.dfdl.xsd
         Root: e_lowercase1
      Purpose: This test demonstrates the use of the lower-case function to return the lower case value of the argument.
-->

  <tdml:parserTestCase name="lowercase_01" root="e_lowercase1"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:lower-case - DFDL-23-103R">

    <tdml:document />
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_lowercase1>test lower</e_lowercase1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: lowercase_02
       Schema: Functions.dfdl.xsd
         Root: e_lowercase2
      Purpose: This test demonstrates the use of the lower-case function to return the lower case value of the argument.
-->

  <tdml:parserTestCase name="lowercase_02" root="e_lowercase2"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:lower-case - DFDL-23-103R">

    <tdml:document />
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_lowercase2>test lower</e_lowercase2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: lowercase_03
       Schema: Functions.dfdl.xsd
         Root: e_lowercase3
      Purpose: This test demonstrates the use of the lower-case function to return the lower case value of the argument.
-->

  <tdml:parserTestCase name="lowercase_03" root="e_lowercase3"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:lower-case - DFDL-23-103R">

    <tdml:document />
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_lowercase3/>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>


<!--
    Test Name: contains_01
       Schema: Functions.dfdl.xsd
         Root: e_contains1
      Purpose: This test demonstrates the use of the contains function to indicate whether one string contains another.
-->

  <tdml:parserTestCase name="contains_01" root="e_contains1"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:contains - DFDL-23-104R">

    <tdml:document/>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_contains1>true</e_contains1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: contains_02
       Schema: Functions.dfdl.xsd
         Root: e_contains2
      Purpose: This test demonstrates the use of the contains function to indicate whether one string contains another.
-->

  <tdml:parserTestCase name="contains_02" root="e_contains2"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:contains - DFDL-23-104R">

    <tdml:document/>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_contains2>false</e_contains2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: contains_03
       Schema: Functions.dfdl.xsd
         Root: e_contains3
      Purpose: This test demonstrates the use of the contains function to indicate whether one string contains another.
-->

  <tdml:parserTestCase name="contains_03" root="e_contains3"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:contains - DFDL-23-104R">

    <tdml:document/>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_contains3>true</e_contains3>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: contains_04
       Schema: Functions.dfdl.xsd
         Root: e_contains4
      Purpose: This test demonstrates the use of the contains function to indicate whether one string contains another.
-->

  <tdml:parserTestCase name="contains_04" root="e_contains4"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:contains - DFDL-23-104R">

    <tdml:document/>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_contains4>false</e_contains4>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: contains_05
       Schema: Functions.dfdl.xsd
         Root: e_contains5
      Purpose: This test demonstrates the use of the contains function to indicate whether one string contains another.
-->

  <tdml:parserTestCase name="contains_05" root="e_contains5"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:contains - DFDL-23-104R">

    <tdml:document>The quick brown fox.,The quick brown fox.</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_contains5>
          <one>The quick brown fox.</one>
          <two>The quick brown fox.</two>
          <contains>true</contains>
        </e_contains5>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: contains_06
       Schema: Functions.dfdl.xsd
         Root: e_contains5
      Purpose: This test demonstrates the use of the contains function to indicate whether one string contains another.
-->

  <tdml:parserTestCase name="contains_06" root="e_contains5"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:contains - DFDL-23-104R">

    <tdml:document>The quick brown fox.,The quick BROWN fox.</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_contains5>
          <one>The quick brown fox.</one>
          <two>The quick BROWN fox.</two>
          <contains>false</contains>
        </e_contains5>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: contains_07
       Schema: Functions.dfdl.xsd
         Root: e_contains6
      Purpose: This test demonstrates the use of the contains function to indicate whether one string contains another.
-->

  <tdml:parserTestCase name="contains_07" root="e_contains6"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:contains - DFDL-23-104R">

    <tdml:document/>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>fn:contains</tdml:error>
      <tdml:error>requires 2 argument(s)</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
    Test Name: startswith_01
       Schema: Functions.dfdl.xsd
         Root: e_startswith1
      Purpose: This test demonstrates the use of the starts-with function to indicate whether one string starts with another.
-->

  <tdml:parserTestCase name="startswith_01" root="e_startswith1"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:starts-with - DFDL-23-105R">

    <tdml:document/>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_startswith1>true</e_startswith1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: startswith_02
       Schema: Functions.dfdl.xsd
         Root: e_startswith2
      Purpose: This test demonstrates the use of the starts-with function to indicate whether one string starts with another.
-->

  <tdml:parserTestCase name="startswith_02" root="e_startswith2"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:starts-with - DFDL-23-105R">

    <tdml:document/>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_startswith2>false</e_startswith2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: startswith_03
       Schema: Functions.dfdl.xsd
         Root: e_startswith3
      Purpose: This test demonstrates the use of the starts-with function to indicate whether one string starts with another.
-->

  <tdml:parserTestCase name="startswith_03" root="e_startswith3"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:starts-with - DFDL-23-105R">

    <tdml:document/>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_startswith3>true</e_startswith3>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: startswith_04
       Schema: Functions.dfdl.xsd
         Root: e_startswith4
      Purpose: This test demonstrates the use of the starts-with function to indicate whether one string starts with another.
-->

  <tdml:parserTestCase name="startswith_04" root="e_startswith4"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:starts-with - DFDL-23-105R">

    <tdml:document/>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_startswith4>false</e_startswith4>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: startswith_05
       Schema: Functions.dfdl.xsd
         Root: e_startswith5
      Purpose: This test demonstrates the use of the starts-with function to indicate whether one string starts with another.
-->

  <tdml:parserTestCase name="startswith_05" root="e_startswith5"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:starts-with - DFDL-23-105R">

    <tdml:document>The quick brown fox.,The quick brown fox.</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_startswith5>
          <one>The quick brown fox.</one>
          <two>The quick brown fox.</two>
          <starts>true</starts>
        </e_startswith5>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: startswith_06
       Schema: Functions.dfdl.xsd
         Root: e_startswith5
      Purpose: This test demonstrates the use of the starts-with function to indicate whether one string starts with another.
-->

  <tdml:parserTestCase name="startswith_06" root="e_startswith5"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:starts-with - DFDL-23-105R">

    <tdml:document>The quick brown fox.,the</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_startswith5>
          <one>The quick brown fox.</one>
          <two>the</two>
          <starts>false</starts>
        </e_startswith5>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: startswith_07
       Schema: Functions.dfdl.xsd
         Root: e_startswith6
      Purpose: This test demonstrates the use of the starts-with function to indicate whether one string starts with another.
-->

  <tdml:parserTestCase name="startswith_07" root="e_startswith6"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:starts-with - DFDL-23-105R">

    <tdml:document/>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>fn:starts-with</tdml:error>
      <tdml:error>requires 2 argument(s)</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
    Test Name: endswith_01
       Schema: Functions.dfdl.xsd
         Root: e_endswith1
      Purpose: This test demonstrates the use of the ends-with function to indicate whether one string ends with another.
-->

  <tdml:parserTestCase name="endswith_01" root="e_endswith1"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:ends-with - DFDL-23-106R">

    <tdml:document/>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_endswith1>true</e_endswith1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: endswith_02
       Schema: Functions.dfdl.xsd
         Root: e_endswith2
      Purpose: This test demonstrates the use of the ends-with function to indicate whether one string ends with another.
-->

  <tdml:parserTestCase name="endswith_02" root="e_endswith2"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:ends-with - DFDL-23-106R">

    <tdml:document/>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_endswith2>false</e_endswith2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: endswith_03
       Schema: Functions.dfdl.xsd
         Root: e_endswith3
      Purpose: This test demonstrates the use of the ends-with function to indicate whether one string ends with another.
-->

  <tdml:parserTestCase name="endswith_03" root="e_endswith3"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:ends-with - DFDL-23-106R">

    <tdml:document/>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_endswith3>true</e_endswith3>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: endswith_04
       Schema: Functions.dfdl.xsd
         Root: e_endswith4
      Purpose: This test demonstrates the use of the ends-with function to indicate whether one string ends with another.
-->

  <tdml:parserTestCase name="endswith_04" root="e_endswith4"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:ends-with - DFDL-23-106R">

    <tdml:document/>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_endswith4>false</e_endswith4>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: endswith_05
       Schema: Functions.dfdl.xsd
         Root: e_endswith5
      Purpose: This test demonstrates the use of the ends-with function to indicate whether one string ends with another.
-->

  <tdml:parserTestCase name="endswith_05" root="e_endswith5"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:ends-with - DFDL-23-106R">

    <tdml:document>The quick brown fox.,The quick brown fox.</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_endswith5>
          <one>The quick brown fox.</one>
          <two>The quick brown fox.</two>
          <ends>true</ends>
        </e_endswith5>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: endswith_06
       Schema: Functions.dfdl.xsd
         Root: e_endswith5
      Purpose: This test demonstrates the use of the ends-with function to indicate whether one string ends with another.
-->

  <tdml:parserTestCase name="endswith_06" root="e_endswith5"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:ends-with - DFDL-23-106R">

    <tdml:document>The quick brown fox.,The quick BROWN fox.</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_endswith5>
          <one>The quick brown fox.</one>
          <two>The quick BROWN fox.</two>
          <ends>false</ends>
        </e_endswith5>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: endswith_07
       Schema: Functions.dfdl.xsd
         Root: e_endswith6
      Purpose: This test demonstrates the use of the ends-with function to indicate whether one string ends with another.
-->

  <tdml:parserTestCase name="endswith_07" root="e_endswith6"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:ends-with - DFDL-23-106R">

    <tdml:document/>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>fn:ends-with</tdml:error>
      <tdml:error>requires 2 argument(s)</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
    Test Name: substringbefore_01
       Schema: Functions.dfdl.xsd
         Root: e_substringbefore1
      Purpose: This test demonstrates the use of the substring-before function which returns the substring from the first argument that precedes the substring contained in the second argument.
-->

  <tdml:parserTestCase name="substringbefore_01" root="e_substringbefore1"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:substring-before - DFDL-23-107R">

    <tdml:document/>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_substringbefore1>The </e_substringbefore1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: substringbefore_02
       Schema: Functions.dfdl.xsd
         Root: e_substringbefore2
      Purpose: This test demonstrates the use of the substring-before function which returns the substring from the first argument that precedes the substring contained in the second argument.
-->

  <tdml:parserTestCase name="substringbefore_02" root="e_substringbefore2"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:substring-before - DFDL-23-107R">

    <tdml:document/>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_substringbefore2/>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: substringbefore_03
       Schema: Functions.dfdl.xsd
         Root: e_substringbefore3
      Purpose: This test demonstrates the use of the substring-before function which returns the substring from the first argument that precedes the substring contained in the second argument.
-->

  <tdml:parserTestCase name="substringbefore_03" root="e_substringbefore3"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:substring-before - DFDL-23-107R">

    <tdml:document/>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_substringbefore3/>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: substringbefore_04
       Schema: Functions.dfdl.xsd
         Root: e_substringbefore4
      Purpose: This test demonstrates the use of the substring-before function which returns the substring from the first argument that precedes the substring contained in the second argument.
-->

  <tdml:parserTestCase name="substringbefore_04" root="e_substringbefore4"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:substring-before - DFDL-23-107R">

    <tdml:document>test,test</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_substringbefore4>
          <one>test</one>
          <two>test</two>
          <before/>
        </e_substringbefore4>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: substringbefore_05
       Schema: Functions.dfdl.xsd
         Root: e_substringbefore4
      Purpose: This test demonstrates the use of the substring-before function which returns the substring from the first argument that precedes the substring contained in the second argument.
-->

  <tdml:parserTestCase name="substringbefore_05" root="e_substringbefore4"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:substring-before - DFDL-23-107R">

    <tdml:document>something,else</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_substringbefore4>
          <one>something</one>
          <two>else</two>
          <before/>
        </e_substringbefore4>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: substringbefore_06
       Schema: Functions.dfdl.xsd
         Root: e_substringbefore4
      Purpose: This test demonstrates the use of the substring-before function which returns the substring from the first argument that precedes the substring contained in the second argument.
-->

  <tdml:parserTestCase name="substringbefore_06" root="e_substringbefore4"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:substring-before - DFDL-23-107R">

    <tdml:document>something,t</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_substringbefore4>
          <one>something</one>
          <two>t</two>
          <before>some</before>
        </e_substringbefore4>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: substringbefore_07
       Schema: Functions.dfdl.xsd
         Root: e_substringbefore5
      Purpose: This test demonstrates the use of the substring-before function which returns the substring from the first argument that precedes the substring contained in the second argument.
-->

  <tdml:parserTestCase name="substringbefore_07" root="e_substringbefore5"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:substring-before - DFDL-23-107R">

    <tdml:document/>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>fn:substring-before</tdml:error>
      <tdml:error>requires 2 argument(s)</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
    Test Name: substringbefore_09
       Schema: Functions.dfdl.xsd
         Root: e_substringbefore6
      Purpose: This test demonstrates the use of the substring-before function which returns the substring from the first argument that precedes the substring contained in the second argument.
-->

  <tdml:parserTestCase name="substringbefore_09" root="e_substringbefore8"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:substring-before - DFDL-23-107R">

    <tdml:document/>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>fn:substring-before</tdml:error>
      <tdml:error>requires 2 argument(s)</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
    Test Name: substringafter_01
       Schema: Functions.dfdl.xsd
         Root: e_substringafter1
      Purpose: This test demonstrates the use of the substring-after function which returns the substring from the first argument that comes after the substring contained in the second argument.
-->

  <tdml:parserTestCase name="substringafter_01" root="e_substringafter1"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:substring-after - DFDL-23-108R">

    <tdml:document/>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_substringafter1> fox.</e_substringafter1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: substringafter_02
       Schema: Functions.dfdl.xsd
         Root: e_substringafter2
      Purpose: This test demonstrates the use of the substring-after function which returns the substring from the first argument that comes after the substring contained in the second argument.
-->

  <tdml:parserTestCase name="substringafter_02" root="e_substringafter2"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:substring-after - DFDL-23-108R">

    <tdml:document/>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_substringafter2/>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: substringafter_03
       Schema: Functions.dfdl.xsd
         Root: e_substringafter3
      Purpose: This test demonstrates the use of the substring-after function which returns the substring from the first argument that comes after the substring contained in the second argument.
-->

  <tdml:parserTestCase name="substringafter_03" root="e_substringafter3"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:substring-after - DFDL-23-108R">

    <tdml:document/>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_substringafter3>The quick brown fox.</e_substringafter3>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: substringafter_04
       Schema: Functions.dfdl.xsd
         Root: e_substringafter4
      Purpose: This test demonstrates the use of the substring-after function which returns the substring from the first argument that comes after the substring contained in the second argument.
-->

  <tdml:parserTestCase name="substringafter_04" root="e_substringafter4"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:substring-after - DFDL-23-108R">

    <tdml:document>test,test</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_substringafter4>
          <one>test</one>
          <two>test</two>
          <after/>
        </e_substringafter4>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: substringafter_05
       Schema: Functions.dfdl.xsd
         Root: e_substringafter4
      Purpose: This test demonstrates the use of the substring-after function which returns the substring from the first argument that comes after the substring contained in the second argument.
-->

  <tdml:parserTestCase name="substringafter_05" root="e_substringafter4"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:substring-after - DFDL-23-108R">

    <tdml:document>something,else</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_substringafter4>
          <one>something</one>
          <two>else</two>
          <after/>
        </e_substringafter4>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: substringafter_06
       Schema: Functions.dfdl.xsd
         Root: e_substringafter4
      Purpose: This test demonstrates the use of the substring-after function which returns the substring from the first argument that comes after the substring contained in the second argument.
-->

  <tdml:parserTestCase name="substringafter_06" root="e_substringafter4"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:substring-after - DFDL-23-108R">

    <tdml:document>something,t</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_substringafter4>
          <one>something</one>
          <two>t</two>
          <after>hing</after>
        </e_substringafter4>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: substringafter_07
       Schema: Functions.dfdl.xsd
         Root: e_substringafter5
      Purpose: This test demonstrates the use of the substring-after function which returns the substring from the first argument that comes after the substring contained in the second argument.
-->

  <tdml:parserTestCase name="substringafter_07" root="e_substringafter5"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:substring-after - DFDL-23-108R">

    <tdml:document/>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>fn:substring-after</tdml:error>
      <tdml:error>requires 2 argument(s)</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
    Test Name: yearfromdatetime_01
       Schema: Functions.dfdl.xsd
         Root: e_yearfromdatetime1
      Purpose: This test demonstrates the use of the year-from-dateTime function to return the year as an xs:integer from an xs:dateTime.
-->

  <tdml:parserTestCase name="yearfromdatetime_01" root="e_yearfromdatetime1"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:year-from-dateTime - DFDL-23-109R">

    <tdml:document/>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_yearfromdatetime1>1999</e_yearfromdatetime1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: yearfromdatetime_02
       Schema: Functions.dfdl.xsd
         Root: e_yearfromdatetime2
      Purpose: This test demonstrates the use of the year-from-dateTime function to return the year as an xs:integer from an xs:dateTime.
-->

  <tdml:parserTestCase name="yearfromdatetime_02" root="e_yearfromdatetime2"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:year-from-dateTime - DFDL-23-109R">

    <tdml:document>2034-12-31T23:00:00</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_yearfromdatetime2>
          <date>2034-12-31T23:00:00</date>
          <year>2034</year>
        </e_yearfromdatetime2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: yearfromdatetime_03
       Schema: Functions.dfdl.xsd
         Root: e_yearfromdatetime2
      Purpose: This test demonstrates the use of the year-from-dateTime function to return the year as an xs:integer from an xs:dateTime.
-->

  <tdml:parserTestCase name="yearfromdatetime_03" root="e_yearfromdatetime2"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:year-from-dateTime - DFDL-23-109R">

    <tdml:document>0000-01-01T23:00:00</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_yearfromdatetime2>
          <date>0000-01-01T23:00:00</date>
          <year>0</year>
        </e_yearfromdatetime2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: monthfromdatetime_01
       Schema: Functions.dfdl.xsd
         Root: e_monthfromdatetime1
      Purpose: This test demonstrates the use of the month-from-dateTime function to return the month as an xs:integer from an xs:dateTime.
-->

  <tdml:parserTestCase name="monthfromdatetime_01" root="e_monthfromdatetime1"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:month-from-dateTime - DFDL-23-110R">

    <tdml:document/>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_monthfromdatetime1>5</e_monthfromdatetime1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: monthfromdatetime_02
       Schema: Functions.dfdl.xsd
         Root: e_monthfromdatetime2
      Purpose: This test demonstrates the use of the month-from-dateTime function to return the month as an xs:integer from an xs:dateTime.
-->

  <tdml:parserTestCase name="monthfromdatetime_02" root="e_monthfromdatetime2"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:month-from-dateTime - DFDL-23-110R">

    <tdml:document>2034-12-31T23:00:00</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_monthfromdatetime2>
          <date>2034-12-31T23:00:00</date>
          <month>12</month>
        </e_monthfromdatetime2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: dayfromdatetime_01
       Schema: Functions.dfdl.xsd
         Root: e_dayfromdatetime1
      Purpose: This test demonstrates the use of the day-from-dateTime function to return the day as an xs:integer from an xs:dateTime.
-->

  <tdml:parserTestCase name="dayfromdatetime_01" root="e_dayfromdatetime1"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:day-from-dateTime - DFDL-23-111R">

    <tdml:document/>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_dayfromdatetime1>31</e_dayfromdatetime1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: dayfromdatetime_02
       Schema: Functions.dfdl.xsd
         Root: e_dayfromdatetime2
      Purpose: This test demonstrates the use of the day-from-dateTime function to return the day as an xs:integer from an xs:dateTime.
-->

  <tdml:parserTestCase name="dayfromdatetime_02" root="e_dayfromdatetime2"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:day-from-dateTime - DFDL-23-111R">

    <tdml:document>2034-12-31T23:00:00</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_dayfromdatetime2>
          <date>2034-12-31T23:00:00</date>
          <day>31</day>
        </e_dayfromdatetime2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: hoursfromdatetime_01
       Schema: Functions.dfdl.xsd
         Root: e_hoursfromdatetime1
      Purpose: This test demonstrates the use of the hours-from-dateTime function to return the hours as an xs:integer from an xs:dateTime.
-->

  <tdml:parserTestCase name="hoursfromdatetime_01" root="e_hoursfromdatetime1"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:hours-from-dateTime - DFDL-23-112R">

    <tdml:document/>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_hoursfromdatetime1>13</e_hoursfromdatetime1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: hoursfromdatetime_02
       Schema: Functions.dfdl.xsd
         Root: e_hoursfromdatetime2
      Purpose: This test demonstrates the use of the hours-from-dateTime function to return the hours as an xs:integer from an xs:dateTime.
-->

  <tdml:parserTestCase name="hoursfromdatetime_02" root="e_hoursfromdatetime2"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:hours-from-dateTime - DFDL-23-112R">

    <tdml:document>2034-12-31T23:00:00</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_hoursfromdatetime2>
          <date>2034-12-31T23:00:00</date>
          <hours>23</hours>
        </e_hoursfromdatetime2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: minutesfromdatetime_01
       Schema: Functions.dfdl.xsd
         Root: e_minutesfromdatetime1
      Purpose: This test demonstrates the use of the minutes-from-dateTime function to return the minutes as an xs:integer from an xs:dateTime.
-->

  <tdml:parserTestCase name="minutesfromdatetime_01" root="e_minutesfromdatetime1"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:minutes-from-dateTime - DFDL-23-113R">

    <tdml:document/>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_minutesfromdatetime1>20</e_minutesfromdatetime1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: minutesfromdatetime_02
       Schema: Functions.dfdl.xsd
         Root: e_minutesfromdatetime2
      Purpose: This test demonstrates the use of the minutes-from-dateTime function to return the minutes as an xs:integer from an xs:dateTime.
-->

  <tdml:parserTestCase name="minutesfromdatetime_02" root="e_minutesfromdatetime2"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:minutes-from-dateTime - DFDL-23-113R">

    <tdml:document>2034-12-31T23:00:00</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_minutesfromdatetime2>
          <date>2034-12-31T23:00:00</date>
          <minutes>0</minutes>
        </e_minutesfromdatetime2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: secondsfromdatetime_01
       Schema: Functions.dfdl.xsd
         Root: e_secondsfromdatetime1
      Purpose: This test demonstrates the use of the seconds-from-dateTime function to return the seconds as a xs:decimal from an xs:dateTime.
-->

  <tdml:parserTestCase name="secondsfromdatetime_01" root="e_secondsfromdatetime1"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:seconds-from-dateTime - DFDL-23-114R">

    <tdml:document/>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_secondsfromdatetime1>0</e_secondsfromdatetime1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: secondsfromdatetime_02
       Schema: Functions.dfdl.xsd
         Root: e_secondsfromdatetime2
      Purpose: This test demonstrates the use of the seconds-from-dateTime function to return the seconds as a xs:decimal from an xs:dateTime.
-->

  <tdml:parserTestCase name="secondsfromdatetime_02" root="e_secondsfromdatetime2"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:seconds-from-dateTime - DFDL-23-114R">

    <tdml:document>2034-12-31T23:00:00</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_secondsfromdatetime2>
          <date>2034-12-31T23:00:00</date>
          <seconds>0</seconds>
        </e_secondsfromdatetime2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: secondsfromdatetime_03
       Schema: Functions.dfdl.xsd
         Root: e_secondsfromdatetime3
      Purpose: This test demonstrates the use of the seconds-from-dateTime function to return the seconds as a xs:decimal from an xs:dateTime.
-->

  <tdml:parserTestCase name="secondsfromdatetime_03" root="e_secondsfromdatetime3"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:seconds-from-dateTime - DFDL-23-114R">

    <tdml:document>2014-07-19T23:00:05.18</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_secondsfromdatetime3>
          <date>2014-07-19T23:00:05.180000</date>
          <seconds>5.18</seconds>
        </e_secondsfromdatetime3>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: xfromdatetime_01
       Schema: Functions.dfdl.xsd
         Root: e_xfromdatetime1
      Purpose: This test demonstrates the use of the x-from-dateTime functions to return the value as an xs:integer from an xs:dateTime.
-->

  <tdml:parserTestCase name="xfromdatetime_01" root="e_xfromdatetime1"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:year-from-dateTime - DFDL-23-109R, fn:month-from-dateTime - DFDL-23-110R, fn:day-from-dateTime - DFDL-23-111R, fn:hours-from-dateTime - DFDL-23-112R, fn:minutes-from-dateTime - DFDL-23-113R, fn:seconds-from-dateTime - DFDL-23-114R">

    <tdml:document>It is 11:53:06 on the 1st of April, year 2013</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_xfromdatetime1>
          <date>2013-04-01T11:53:06</date>
          <year>2013</year>
          <month>4</month>
          <day>1</day>
          <hours>11</hours>
          <minutes>53</minutes>
          <seconds>6</seconds>
          <timeZone></timeZone>
        </e_xfromdatetime1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: xfromdatetime_02
       Schema: Functions.dfdl.xsd
         Root: e_xfromdatetime2
      Purpose: This test demonstrates the use of the x-from-dateTime functions to return the value as an xs:integer from an xs:dateTime.
-->

  <tdml:parserTestCase name="xfromdatetime_02" root="e_xfromdatetime2"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:year-from-dateTime - DFDL-23-109R, fn:month-from-dateTime - DFDL-23-110R, fn:day-from-dateTime - DFDL-23-111R, fn:hours-from-dateTime - DFDL-23-112R, fn:minutes-from-dateTime - DFDL-23-113R, fn:seconds-from-dateTime - DFDL-23-114R"
    roundTrip="twoPass">

    <tdml:document>2013-12-31T23:62:30</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_xfromdatetime2>
          <date xsi:type="xs:dateTime">2014-01-01T00:02:30+00:00</date>
          <year>2014</year>
          <month>1</month>
          <day>1</day>
          <hours>0</hours>
          <minutes>2</minutes>
          <seconds>30</seconds>
          <timeZone>+00:00</timeZone>
        </e_xfromdatetime2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: xfromdatetime_03
       Schema: Functions.dfdl.xsd
         Root: e_xfromdatetime2
      Purpose: This test demonstrates the use of the x-from-dateTime functions to return the value as an xs:integer from an xs:dateTime.
-->

  <tdml:parserTestCase name="xfromdatetime_03" root="e_xfromdatetime2"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:year-from-dateTime - DFDL-23-109R, fn:month-from-dateTime - DFDL-23-110R, fn:day-from-dateTime - DFDL-23-111R, fn:hours-from-dateTime - DFDL-23-112R, fn:minutes-from-dateTime - DFDL-23-113R, fn:seconds-from-dateTime - DFDL-23-114R"
    roundTrip="twoPass">

    <tdml:document>0100-13-12T24:11:99</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_xfromdatetime2>
          <date xsi:type="xs:dateTime">0101-01-13T00:12:39+00:00</date>
          <year>101</year>
          <month>1</month>
          <day>13</day>
          <hours>0</hours>
          <minutes>12</minutes>
          <seconds>39</seconds>
          <timeZone>+00:00</timeZone>
        </e_xfromdatetime2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: xfromdatetime_04
       Schema: Functions.dfdl.xsd
         Root: e_xfromdatetime3
      Purpose: This test demonstrates the use of the x-from-dateTime functions to return the value as an xs:integer from an xs:dateTime.
-->

  <tdml:parserTestCase name="xfromdatetime_04" root="e_xfromdatetime3"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:year-from-dateTime - DFDL-23-109R, fn:month-from-dateTime - DFDL-23-110R, fn:day-from-dateTime - DFDL-23-111R, fn:hours-from-dateTime - DFDL-23-112R, fn:minutes-from-dateTime - DFDL-23-113R, fn:seconds-from-dateTime - DFDL-23-114R">

    <tdml:document>-1234-01-30T10:01:02</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_xfromdatetime3>
          <date>-1234-01-30T10:01:02-08:00</date>
          <year>-1234</year>
          <month>1</month>
          <day>30</day>
          <hours>10</hours>
          <minutes>1</minutes>
          <seconds>2</seconds>
          <timeZone>-08:00</timeZone>
        </e_xfromdatetime3>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: yearfromdate_01
       Schema: Functions.dfdl.xsd
         Root: e_yearfromdate1
      Purpose: This test demonstrates the use of the year-from-date function to return the year as an xs:integer from an xs:date.
-->

  <tdml:parserTestCase name="yearfromdate_01" root="e_yearfromdate1"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:year-from-date - DFDL-23-115R">

    <tdml:document/>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_yearfromdate1>2014</e_yearfromdate1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: yearfromdate_02
       Schema: Functions.dfdl.xsd
         Root: e_yearfromdate2
      Purpose: This test demonstrates the use of the year-from-date function to return the year as an xs:integer from an xs:date.
-->

  <tdml:parserTestCase name="yearfromdate_02" root="e_yearfromdate2"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:year-from-date - DFDL-23-115R">

    <tdml:document>2034-12-31</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_yearfromdate2>
          <date>2034-12-31</date>
          <year>2034</year>
        </e_yearfromdate2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: yearfromdate_03
       Schema: Functions.dfdl.xsd
         Root: e_yearfromdate2
      Purpose: This test demonstrates the use of the year-from-date function to return the year as an xs:integer from an xs:date.
-->

  <tdml:parserTestCase name="yearfromdate_03" root="e_yearfromdate2"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:year-from-date - DFDL-23-115R">

    <tdml:document>0000-01-01</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_yearfromdate2>
          <date>0000-01-01</date>
          <year>0</year>
        </e_yearfromdate2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: monthfromdate_01
       Schema: Functions.dfdl.xsd
         Root: e_monthfromdate1
      Purpose: This test demonstrates the use of the month-from-date function to return the month as an xs:integer from an xs:date.
-->

  <tdml:parserTestCase name="monthfromdate_01" root="e_monthfromdate1"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:month-from-date - DFDL-23-116R">

    <tdml:document/>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_monthfromdate1>11</e_monthfromdate1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: monthfromdate_02
       Schema: Functions.dfdl.xsd
         Root: e_monthfromdate2
      Purpose: This test demonstrates the use of the month-from-date function to return the month as an xs:integer from an xs:date.
-->

  <tdml:parserTestCase name="monthfromdate_02" root="e_monthfromdate2"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:month-from-date - DFDL-23-116R">

    <tdml:document>2034-12-31</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_monthfromdate2>
          <date>2034-12-31</date>
          <month>12</month>
        </e_monthfromdate2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: dayfromdate_01
       Schema: Functions.dfdl.xsd
         Root: e_dayfromdate1
      Purpose: This test demonstrates the use of the day-from-date function to return the day as an xs:integer from an xs:date.
-->

  <tdml:parserTestCase name="dayfromdate_01" root="e_dayfromdate1"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:day-from-date - DFDL-23-117R">

    <tdml:document/>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_dayfromdate1>3</e_dayfromdate1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: dayfromdate_02
       Schema: Functions.dfdl.xsd
         Root: e_dayfromdate2
      Purpose: This test demonstrates the use of the day-from-date function to return the day as an xs:integer from an xs:date.
-->

  <tdml:parserTestCase name="dayfromdate_02" root="e_dayfromdate2"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:day-from-date - DFDL-23-117R">

    <tdml:document>2034-12-31</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_dayfromdate2>
          <date>2034-12-31</date>
          <day>31</day>
        </e_dayfromdate2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: xfromdate_01
       Schema: Functions.dfdl.xsd
         Root: e_xfromdate1
      Purpose: This test demonstrates the use of the x-from-date functions to return the value as an xs:integer from an xs:date.
               Note that this test does not round trip.
-->

  <tdml:parserTestCase name="xfromdate_01" root="e_xfromdate1"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:year-from-date - DFDL-23-115R, fn:month-from-date - DFDL-23-116R, fn:day-from-date - DFDL-23-117R"
    roundTrip="false">

    <tdml:document>2000-01-366</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_xfromdate1>
          <date>2000-12-31</date>
          <year>2000</year>
          <month>12</month>
          <day>31</day>
          <timeZone></timeZone>
        </e_xfromdate1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: xfromdate_02
       Schema: Functions.dfdl.xsd
         Root: e_xfromdate2
      Purpose: This test demonstrates the use of the x-from-date functions to return the value as an xs:integer from an xs:date.
-->

  <tdml:parserTestCase name="xfromdate_02" root="e_xfromdate2"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:year-from-date - DFDL-23-115R, fn:month-from-date - DFDL-23-116R, fn:day-from-date - DFDL-23-117R"
    roundTrip="twoPass">

    <tdml:document>2008-09-31</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_xfromdate2>
          <date>2008-10-01+01:00</date>
          <year>2008</year>
          <month>10</month>
          <day>1</day>
          <timeZone>+01:00</timeZone>
        </e_xfromdate2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: xfromdate_03
       Schema: Functions.dfdl.xsd
         Root: e_xfromdate1
      Purpose: This test demonstrates the use of the x-from-date functions to return the value as an xs:integer from an xs:date.
-->

  <tdml:parserTestCase name="xfromdate_03" root="e_xfromdate1"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:year-from-date - DFDL-23-115R, fn:month-from-date - DFDL-23-116R, fn:day-from-date - DFDL-23-117R"
    roundTrip="twoPass">

    <tdml:document>-0020-01-99</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_xfromdate1>
          <date>-0020-04-08</date>
          <year>-20</year>
          <month>4</month>
          <day>8</day>
          <timeZone></timeZone>
        </e_xfromdate1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: hoursfromtime_01
       Schema: Functions.dfdl.xsd
         Root: e_hoursfromtime1
      Purpose: This test demonstrates the use of the hours-from-time function to return the hours as an xs:integer from an xs:time.
-->

  <tdml:parserTestCase name="hoursfromtime_01" root="e_hoursfromtime1"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:hours-from-time - DFDL-23-118R">

    <tdml:document/>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_hoursfromtime1>13</e_hoursfromtime1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: hoursfromtime_02
       Schema: Functions.dfdl.xsd
         Root: e_hoursfromtime2
      Purpose: This test demonstrates the use of the hours-from-time function to return the hours as an xs:integer from an xs:time.
-->

  <tdml:parserTestCase name="hoursfromtime_02" root="e_hoursfromtime2"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:hours-from-time - DFDL-23-118R"
    roundTrip="twoPass">

    <tdml:document>23:00:00+00:00</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_hoursfromtime2>
          <time>23:00:00+00:00</time>
          <hours>23</hours>
        </e_hoursfromtime2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: minutesfromtime_01
       Schema: Functions.dfdl.xsd
         Root: e_minutesfromtime1
      Purpose: This test demonstrates the use of the minutes-from-time function to return the minutes as an xs:integer from an xs:time.
-->

  <tdml:parserTestCase name="minutesfromtime_01" root="e_minutesfromtime1"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:minutes-from-time - DFDL-23-119R">

    <tdml:document/>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_minutesfromtime1>25</e_minutesfromtime1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: minutesfromtime_02
       Schema: Functions.dfdl.xsd
         Root: e_minutesfromtime2
      Purpose: This test demonstrates the use of the minutes-from-time function to return the minutes as an xs:integer from an xs:time.
-->

  <tdml:parserTestCase name="minutesfromtime_02" root="e_minutesfromtime2"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:minutes-from-time - DFDL-23-119R"
    roundTrip="twoPass">

    <tdml:document>23:59:00+00:00</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_minutesfromtime2>
          <time>23:59:00+00:00</time>
          <minutes>59</minutes>
        </e_minutesfromtime2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: secondsfromtime_01
       Schema: Functions.dfdl.xsd
         Root: e_secondsfromtime1
      Purpose: This test demonstrates the use of the seconds-from-time function to return the seconds as a xs:decimal from an xs:time.
-->

  <tdml:parserTestCase name="secondsfromtime_01" root="e_secondsfromtime1"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:seconds-from-time - DFDL-23-120R">

    <tdml:document/>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_secondsfromtime1>14</e_secondsfromtime1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: secondsfromtime_02
       Schema: Functions.dfdl.xsd
         Root: e_secondsfromtime2
      Purpose: This test demonstrates the use of the seconds-from-time function to return the seconds as a xs:decimal from an xs:time.
-->

  <tdml:parserTestCase name="secondsfromtime_02" root="e_secondsfromtime2"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:seconds-from-time - DFDL-23-120R"
    roundTrip="twoPass">

    <tdml:document>23:00:48+00:00</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_secondsfromtime2>
          <time>23:00:48+00:00</time>
          <seconds>48</seconds>
        </e_secondsfromtime2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: xfromtime_01
       Schema: Functions.dfdl.xsd
         Root: e_xfromtime1
      Purpose: This test demonstrates the use of the x-from-time function to return the value as an xs:integer from an xs:time.
-->

  <tdml:parserTestCase name="xfromtime_01" root="e_xfromtime1"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:hours-from-time - DFDL-23-118R, fn:minutes-from-time - DFDL-23-119R, fn:seconds-from-time - DFDL-23-120R"
    roundTrip="twoPass">

    <tdml:document>24:00:00+00:00</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_xfromtime1>
          <time>00:00:00+00:00</time>
          <hours>0</hours>
          <minutes>0</minutes>
          <seconds>0</seconds>
          <timeZone>+00:00</timeZone>
        </e_xfromtime1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: xfromtime_02
       Schema: Functions.dfdl.xsd
         Root: e_xfromtime2
      Purpose: This test demonstrates the use of the x-from-time function to return the value as an xs:integer from an xs:time.
-->

  <tdml:parserTestCase name="xfromtime_02" root="e_xfromtime2"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:hours-from-time - DFDL-23-118R, fn:minutes-from-time - DFDL-23-119R, fn:seconds-from-time - DFDL-23-120R"
    roundTrip="twoPass">

    <tdml:document>01:75:18.743-04:00</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_xfromtime2>
          <time>02:15:18.743000-04:00</time>
          <hours>2</hours>
          <minutes>15</minutes>
          <seconds>18.743</seconds>
          <timeZone>-04:00</timeZone>
        </e_xfromtime2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: xfromtime_03
       Schema: Functions.dfdl.xsd
         Root: e_xfromtime1
      Purpose: This test demonstrates the use of the x-from-time function to return the value as an xs:integer from an xs:time.
-->

  <tdml:parserTestCase name="xfromtime_03" root="e_xfromtime1"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - fn:hours-from-time - DFDL-23-118R, fn:minutes-from-time - DFDL-23-119R, fn:seconds-from-time - DFDL-23-120R"
    roundTrip="twoPass">

    <tdml:document>12:13:14+00:00</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_xfromtime1>
          <time>12:13:14+00:00</time>
          <hours>12</hours>
          <minutes>13</minutes>
          <seconds>14</seconds>
          <timeZone>+00:00</timeZone>
        </e_xfromtime1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: fn_text_01
       Schema: Functions.dfdl.xsd
         Root: e_text1
      Purpose: This test demonstrates the text function is not supported by DPath.
-->

  <tdml:parserTestCase name="fn_text_01" root="e_text1"
    model="Functions.dfdl.xsd" description="Section 23 - Functions">

    <tdml:document>text</tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Use of text() is unsupported</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
    Test Name: fn_text_02
       Schema: Functions.dfdl.xsd
         Root: e_text2
      Purpose: This test demonstrates the text function is not supported by DPath.
-->

  <tdml:parserTestCase name="fn_text_02" root="e_text2"
    model="Functions.dfdl.xsd" description="Section 23 - Functions">

    <tdml:document>text</tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Use of text() is unsupported</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
    Test Name: testBit_0
       Schema: Functions.dfdl.xsd
         Root: testBit
      Purpose: This test demonstrates the use of the testBit function to turn bits into boolean values
-->

  <tdml:parserTestCase name="testBit_0" root="testBit"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - dfdl:testBit - DFDL-23-130R">

    <tdml:document>
      <tdml:documentPart type="bits">00000001
      </tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>dfdl:testBit</tdml:error>
      <tdml:error>$bitPos must be between 1 and 8 (inclusive)</tdml:error>
      <tdml:error>Was 0</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
    Test Name: testBit_1
       Schema: Functions.dfdl.xsd
         Root: testBit1
      Purpose: This test demonstrates the use of the testBit function to turn bits into boolean values
-->

  <tdml:parserTestCase name="testBit_1" root="testBit1"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - dfdl:testBit - DFDL-23-130R">

    <tdml:document>
      <tdml:documentPart type="bits">00000111</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
        <testBit1>
          <byte>7</byte>
          <bit1>true</bit1>
          <bit2>true</bit2>
        </testBit1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: testBit_2
       Schema: Functions.dfdl.xsd
         Root: testBit2
      Purpose: This test demonstrates the use of the testBit function to turn bits into boolean values
-->

  <tdml:parserTestCase name="testBit_2" root="testBit2"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - dfdl:testBit - DFDL-23-130R">

    <tdml:document>
      <tdml:documentPart type="bits">00000000 00000000 00000101 00010101</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Error</tdml:error>
      <tdml:error>1301</tdml:error>
      <tdml:error>range</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
    Test Name: testBit_3
       Schema: Functions.dfdl.xsd
         Root: testBit3
      Purpose: This test demonstrates running the testBit function with not enough arguments
-->

  <tdml:parserTestCase name="testBit_3" root="testBit3"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - dfdl:testBit - DFDL-23-130R">

    <tdml:document>
      <tdml:documentPart type="bits">00000001</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>dfdl:testBit</tdml:error>
      <tdml:error>requires 2 argument</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
    Test Name: testBit_4
       Schema: Functions.dfdl.xsd
         Root: testBit1
      Purpose: This test demonstrates the use of the testBit function to turn bits into boolean values
-->

  <tdml:parserTestCase name="testBit_4" root="testBit1"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - dfdl:testBit - DFDL-23-130R">

    <tdml:document>
      <tdml:documentPart type="bits">00000101</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
        <testBit1>
          <byte>5</byte>
          <bit1>true</bit1>
          <bit2>false</bit2>
        </testBit1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: testBit_5
       Schema: Functions.dfdl.xsd
         Root: testBit4
      Purpose: This test demonstrates running the testBit function with too many arguments
-->

  <tdml:parserTestCase name="testBit_5" root="testBit4"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - dfdl:testBit - DFDL-23-130R">

    <tdml:document>
      <tdml:documentPart type="bits">00000001</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>dfdl:testBit</tdml:error>
      <tdml:error>requires 2 argument</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
    Test Name: setBits_0
       Schema: Functions.dfdl.xsd
         Root: setBits
      Purpose: This test demonstrates the use of the setBits function to set the bits of a byte
-->

  <tdml:parserTestCase name="setBits_0" root="setBits"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - dfdl:setBits - DFDL-23-131R">

    <tdml:document>
      <tdml:documentPart type="bits">00000000
      </tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
        <setBits>
          <e>0</e>
          <e0>1</e0>
          <e1>2</e1>
          <e2>4</e2>
          <e3>8</e3>
          <e4>16</e4>
          <e5>32</e5>
          <e6>64</e6>
          <e7>128</e7>
          <e8>255</e8>
        </setBits>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: setBits_1
       Schema: Functions.dfdl.xsd
         Root: setBits
      Purpose: This test demonstrates the misuse of the setBits function. The number of arguments is incorrect and the
               test should fail.
-->

  <tdml:parserTestCase name="setBits_1" root="setBits1"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - dfdl:setBits - DFDL-23-131R">

    <tdml:document>
      <tdml:documentPart type="bits">00000000</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>setBits</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
    Test Name: setBits_2
       Schema: Functions.dfdl.xsd
         Root: setBits
      Purpose: This test demonstrates the use of the setBits function to set the bits of a byte
-->

  <tdml:parserTestCase name="setBits_2" root="setBits2"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - dfdl:setBits - DFDL-23-131R">

    <tdml:document>
      <tdml:documentPart type="text">0,0,0,0,1,0,1,1</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
        <setBits2>
          <e0>0</e0>
          <e1>0</e1>
          <e2>0</e2>
          <e3>0</e3>
          <e4>1</e4>
          <e5>0</e5>
          <e6>1</e6>
          <e7>1</e7>
          <e>11</e>
        </setBits2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
<!--
    Test Name: more_count_0
       Schema: Functions.dfdl.xsd
         Root: more_count
      Purpose: This test demonstrates the use of the count function
-->

  <tdml:parserTestCase name="more_count_0" root="more_count"
    model="Functions.dfdl.xsd" description="Section 23 ">

    <tdml:document>
      <tdml:documentPart type="text"><![CDATA[1,2,3]]></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
        <more_count>
          <i1>1</i1>
          <i2>2</i2>
          <i3>3</i3>
        </more_count>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
<!--
    Test Name: more_count_1
       Schema: Functions.dfdl.xsd
         Root: more_count1
      Purpose: This test demonstrates the use of the count function
-->

  <tdml:parserTestCase name="more_count_1" root="more_count1"
    model="Functions.dfdl.xsd" description="Section 23 ">

    <tdml:document>
      <tdml:documentPart type="text"><![CDATA[#:1,#:2,#:3]]></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
        <more_count1>
          <i1>1</i1>
          <i1>2</i1>
          <i1>3</i1>
        </more_count1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
<!--
    Test Name: more_count_1b
       Schema: Functions.dfdl.xsd
         Root: more_count1b
      Purpose: This test demonstrates the use of the count function
-->

  <tdml:parserTestCase name="more_count_1b" root="more_count1b"
    model="Functions.dfdl.xsd" description="Section 23 ">

    <tdml:document>
      <tdml:documentPart type="text"><![CDATA[#:1]]></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
        <more_count1b>
          <i1>1</i1>
        </more_count1b>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: more_count_1b_2
       Schema: Functions.dfdl.xsd
         Root: more_count1b
      Purpose: This test demonstrates the use of the count function and
               that the assertion will fail if the count is greater than 1.
-->

  <tdml:parserTestCase name="more_count_1b_2" root="more_count1b"
    model="Functions.dfdl.xsd" description="Section 23 ">

    <tdml:document>
      <tdml:documentPart type="text"><![CDATA[#:1,#:2]]></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Assertion failed</tdml:error>
      <tdml:error>dfdl:more_count( /ex:more_count ) eq 1</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
    Test Name: more_count_2
       Schema: Functions.dfdl.xsd
         Root: more_count2
      Purpose: This test demonstrates the use of the count function
-->

  <tdml:parserTestCase name="more_count_2" root="more_count2"
    model="Functions.dfdl.xsd" description="Section 23 ">

    <tdml:document>
      <tdml:documentPart type="text"><![CDATA[#:1,#:2,#:3,#:4,#:5]]></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
        <more_count2>
          <array>
            <i1>1</i1>
            <i1>2</i1>
            <i1>3</i1>
            <i1>4</i1>
            <i1>5</i1>
          </array>
          <occurs>5</occurs>
        </more_count2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
<!--
    Test Name: more_count_3
       Schema: Functions.dfdl.xsd
         Root: more_count3
      Purpose: This test demonstrates the use of the count function
-->

  <tdml:parserTestCase name="more_count_3" root="more_count3"
    model="Functions.dfdl.xsd" description="Section 23 ">

    <tdml:document>
      <tdml:documentPart type="text"><![CDATA[#:1,#:2,#:3]]></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
        <more_count3>
          <array>
            <i1>1</i1>
            <i1>2</i1>
            <i1>3</i1>
          </array>
          <occurs>3</occurs>
        </more_count3>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
<!--
    Test Name: more_count_3b
       Schema: Functions.dfdl.xsd
         Root: more_count3
      Purpose: This test demonstrates the use of the count function
               In this case there is only one occurrence.      
-->

  <tdml:parserTestCase name="more_count_3b" root="more_count3"
    model="Functions.dfdl.xsd" description="Section 23 ">

    <tdml:document>
      <tdml:documentPart type="text"><![CDATA[#:1]]></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
        <more_count3>
          <array>
            <i1>1</i1>
          </array>
          <occurs>1</occurs>
        </more_count3>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: more_count_4
       Schema: Functions.dfdl.xsd
         Root: more_count3
      Purpose: This test demonstrates the use .. as the last step in count function.
-->

  <tdml:parserTestCase name="more_count_4" root="more_count4"
    model="Functions.dfdl.xsd" description="Section 23 ">

    <tdml:document>
      <tdml:documentPart type="text"><![CDATA[#:10,#:11,#:12]]></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
        <more_count4>
          <array>
            <i1>10</i1>
            <count>1</count>
          </array>
          <array>
            <i1>11</i1>
            <count>2</count>
          </array>
          <array>
            <i1>12</i1>
            <count>3</count>
          </array>
        </more_count4>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: stringLiteralFromString_obsolete
       Schema: Functions.dfdl.xsd
         Root: stringLiteralFromString
      Purpose: This test demonstrates that the stringLiteralFromString function no longer exists.
               It has been replaced with the encodeDFDLEntities function
-->

  <tdml:parserTestCase name="stringLiteralFromString_obsolete"
    root="stringLiteralFromString" model="Functions.dfdl.xsd" description="Section 23 ">

    <tdml:document>
      <tdml:documentPart type="text"><![CDATA[%This is a test!%]]></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Unsupported function</tdml:error>
      <tdml:error>dfdl:stringLiteralFromString</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
    Test Name: encodeDFDLEntities_0
       Schema: Functions.dfdl.xsd
         Root: encodeDFDLEntities
      Purpose: This test demonstrates the use of the encodeDFDLEntities function
-->

  <tdml:parserTestCase name="encodeDFDLEntities_0"
    root="encodeDFDLEntities" model="Functions.dfdl.xsd" description="Section 23 ">

    <tdml:document>
      <tdml:documentPart type="text"><![CDATA[%This is a test!%]]></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
        <encodeDFDLEntities>
          <str>%This is a test!%</str>
          <literal>%%This%SP;is%SP;a%SP;test!%%</literal>
        </encodeDFDLEntities>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: encodeDFDLEntities_1
       Schema: Functions.dfdl.xsd
         Root: encodeDFDLEntities
      Purpose: This test demonstrates the use of the encodeDFDLEntities function
-->

  <tdml:parserTestCase name="encodeDFDLEntities_1"
    root="encodeDFDLEntities" model="Functions.dfdl.xsd" description="Section 23 ">

    <tdml:document>
      <tdml:documentPart type="byte"><![CDATA[30 04 31 09 32 0a 33 0b 34]]></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
        <encodeDFDLEntities>
          <str>01&#x9;2&#xA;34</str>
          <literal>0%EOT;1%HT;2%LF;3%VT;4</literal>
        </encodeDFDLEntities>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: encodeDFDLEntities_2
       Schema: Functions.dfdl.xsd
         Root: encodeDFDLEntities
      Purpose: This test demonstrates the use of the encodeDFDLEntities function
-->

  <tdml:parserTestCase name="encodeDFDLEntities_2"
    root="encodeDFDLEntities" model="Functions.dfdl.xsd" description="Section 23 ">

    <tdml:document>
      <tdml:documentPart type="byte"><![CDATA[01 07 33 0b 0a 09 08 34]]></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
        <encodeDFDLEntities>
          <str>3&#xA;&#x9;4</str>
          <literal>%SOH;%BEL;3%VT;%LF;%HT;%BS;4</literal>
        </encodeDFDLEntities>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: encodeDFDLEntities_3
       Schema: Functions.dfdl.xsd
         Root: encodeDFDLEntities
      Purpose: This test demonstrates the use of the encodeDFDLEntities function
-->

  <tdml:parserTestCase name="encodeDFDLEntities_3"
    root="encodeDFDLEntities" model="Functions.dfdl.xsd" description="Section 23 ">

    <tdml:document>
      <tdml:documentPart type="text"><![CDATA[ThisIsATest!]]></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
        <encodeDFDLEntities>
          <str>ThisIsATest!</str>
          <literal>ThisIsATest!</literal>
        </encodeDFDLEntities>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: encodeDFDLEntities_4
       Schema: Functions.dfdl.xsd
         Root: encodeDFDLEntities
      Purpose: This test demonstrates the use of the encodeDFDLEntities function
-->

  <tdml:parserTestCase name="encodeDFDLEntities_4"
    root="encodeDFDLEntities" model="Functions.dfdl.xsd" description="Section 23 ">

    <tdml:document>
      <tdml:documentPart type="text"><![CDATA[  %  ]]></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
        <encodeDFDLEntities>
          <str>  %  </str>
          <literal>%SP;%SP;%%%SP;%SP;</literal>
        </encodeDFDLEntities>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: containsEntity_obsolete
       Schema: Functions.dfdl.xsd
         Root: containsEntity
      Purpose: This test demonstrates that the containsEntity function is no longer supported
               It has been replaced by the containsDFDLEntities function
-->

  <tdml:parserTestCase name="containsEntity_obsolete" root="containsEntity"
    model="Functions.dfdl.xsd" description="Section 23 ">

    <tdml:document>
      <tdml:documentPart type="text"><![CDATA[%This is a test!%]]></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Unsupported function</tdml:error>
      <tdml:error>dfdl:containsEntity</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
    Test Name: containsDFDLEntities_0
       Schema: Functions.dfdl.xsd
         Root: containsDFDLEntities
      Purpose: This test demonstrates the use of the containsDFDLEntities function to determine if a string contains an entity
-->

  <tdml:parserTestCase name="containsDFDLEntities_0" root="containsDFDLEntities"
    model="Functions.dfdl.xsd" description="Section 23 ">

    <tdml:document>
      <tdml:documentPart type="text"><![CDATA[%This is a test!%]]></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
        <containsDFDLEntities>
          <str>%This is a test!%</str>
          <hasEntity>true</hasEntity>
        </containsDFDLEntities>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: containsDFDLEntities_1
       Schema: Functions.dfdl.xsd
         Root: containsDFDLEntities1
      Purpose: This test demonstrates the use of the containsDFDLEntities function to determine if a string contains an entity
               In this case the string does not contain an entity
-->

  <tdml:parserTestCase name="containsDFDLEntities_1" root="containsDFDLEntities1"
    model="Functions.dfdl.xsd" description="Section 23 ">

    <tdml:document>
      <tdml:documentPart type="text"><![CDATA[This is a test!]]></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
        <containsDFDLEntities1>
          <str>This is a test!</str>
          <hasEntity>false</hasEntity>
        </containsDFDLEntities1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: containsDFDLEntities_2
       Schema: Functions.dfdl.xsd
         Root: containsDFDLEntities1
      Purpose: This test demonstrates the use of the containsDFDLEntities function to determine if a string contains an entity
               In this case the string contains an entity
-->

  <tdml:parserTestCase name="containsDFDLEntities_2" root="containsDFDLEntities1"
    model="Functions.dfdl.xsd" description="Section 23 ">

    <tdml:document>
      <tdml:documentPart replaceDFDLEntities="false" type="text">%NUL;%SOH;;;%%;</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
        <containsDFDLEntities1>
          <str>%NUL;%SOH;;;%%;</str>
          <hasEntity>true</hasEntity>
        </containsDFDLEntities1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: containsDFDLEntities_3
       Schema: Functions.dfdl.xsd
         Root: containsDFDLEntities1
      Purpose: This test demonstrates the use of the containsDFDLEntities function to determine if a string contains an entity
               In this case the string contains an entity
-->

  <tdml:parserTestCase name="containsDFDLEntities_3" root="containsDFDLEntities1"
    model="Functions.dfdl.xsd" description="Section 23 ">

    <tdml:document>
      <tdml:documentPart replaceDFDLEntities="false" type="text">%NUL;%SP;-</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
        <containsDFDLEntities1>
          <str>%NUL;%SP;-</str>
          <hasEntity>true</hasEntity>
        </containsDFDLEntities1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: containsDFDLEntities_4
       Schema: Functions.dfdl.xsd
         Root: containsDFDLEntities1
      Purpose: This test demonstrates the use of the containsDFDLEntities function to determine if a string contains an entity
               In this case the string contains an entity
-->

  <tdml:parserTestCase name="containsDFDLEntities_4" root="containsDFDLEntities1"
    model="Functions.dfdl.xsd" description="Section 23 ">

    <tdml:document>
      <tdml:documentPart replaceDFDLEntities="false" type="text">%HT;%LF;</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
        <containsDFDLEntities1>
          <str>%HT;%LF;</str>
          <hasEntity>true</hasEntity>
        </containsDFDLEntities1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: valueLength_0
       Schema: Functions.dfdl.xsd
         Root: valueLength
      Purpose: This test demonstrates the valueLength function (formerly unpaddedLength).
-->

  <tdml:parserTestCase name="valueLength_0" root="valueLength"
    model="Functions.dfdl.xsd" description="Section 23 "
    roundTrip="twoPass">

    <tdml:document>
      <tdml:documentPart type="text"><![CDATA[////test////]]></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
        <valueLength>
          <str>test</str>
          <valLen>32</valLen>
        </valueLength>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: valueLength_1
       Schema: Functions.dfdl.xsd
         Root: valueLength2
      Purpose: This test demonstrates the valueLength function (formerly unpaddedLength).
-->

  <tdml:parserTestCase name="valueLength_1" root="valueLength2"
    model="Functions.dfdl.xsd" description="Section 23 "
    roundTrip="twoPass">

    <tdml:document>
      <tdml:documentPart type="text"><![CDATA[////test////]]></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
        <valueLength2>
          <str>test</str>
          <valLen>4</valLen>
        </valueLength2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: valueLength_2
       Schema: Functions.dfdl.xsd
         Root: valueLength3
      Purpose: This test demonstrates the valueLength function with a lengthUnit of 'characters'.
-->

  <tdml:parserTestCase name="valueLength_2" root="valueLength3"
    model="Functions.dfdl.xsd" description="Section 23 ">

    <tdml:document>
      <tdml:documentPart type="text"><![CDATA[////test////]]></tdml:documentPart>
    </tdml:document>
    <!--
    <tdml:infoset>
      <tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
        <valueLength3>
          <str>test</str>
          <valLen>4</valLen>
        </valueLength3>
      </tdml:dfdlInfoset>
    </tdml:infoset>
    -->
    <tdml:errors>
      <tdml:error>not yet supported</tdml:error>
      <tdml:error>characters</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
    Test Name: valueLength_3
       Schema: Functions.dfdl.xsd
         Root: valueLength4
      Purpose: This test demonstrates the valueLength function with escapeCharacters.
-->

  <tdml:parserTestCase name="valueLength_3" root="valueLength4"
    model="Functions.dfdl.xsd" description="Section 23 "
    roundTrip="twoPass">

    <tdml:document>
      <tdml:documentPart type="text"><![CDATA[/te*,st!*;]]></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
        <valueLength4>
          <str>te,st*</str>
          <valLen>6</valLen>
        </valueLength4>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: valueLength_4
       Schema: Functions.dfdl.xsd
         Root: valueLength8
      Purpose: This test demonstrates the valueLength function with a nil element.
-->

  <tdml:parserTestCase name="valueLength_4" root="valueLength8"
    model="Functions.dfdl.xsd" description="Section 23 ">

    <tdml:document>
      <tdml:documentPart type="text"><![CDATA[NIL]]></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
        <valueLength8>
          <str xsi:nil="true"/>
          <valLen>3</valLen>
        </valueLength8>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: valueLength_5
       Schema: Functions.dfdl.xsd
         Root: valueLength10
      Purpose: This test demonstrates the valueLength function with a complex element.
-->

  <tdml:parserTestCase name="valueLength_5" root="valueLength10"
    model="Functions.dfdl.xsd" description="Section 23 ">

    <tdml:document>
      <tdml:documentPart type="text"><![CDATA[1,2,3,4,5,6;]]></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
        <valueLength10>
          <seq>
            <num>1</num>
            <num>2</num>
            <num>3</num>
            <num>4</num>
            <num>5</num>
            <num>6</num>
          </seq>
          <valLen>12</valLen>
        </valueLength10>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: valueLength_sde
       Schema: Functions.dfdl.xsd
         Root: valueLength12
      Purpose: This test demonstrates the valueLength function throws a SDE with an invalid lengthUnit.
-->

  <tdml:parserTestCase name="valueLength_sde" root="valueLength12"
    model="Functions.dfdl.xsd" description="Section 23 ">

    <tdml:document>
      <tdml:documentPart type="text"><![CDATA[test]]></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Unknown value for lengthUnits property</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
    Test Name: valueLength_6
       Schema: Functions.dfdl.xsd
         Root: valueLength13
      Purpose: This test demonstrates the valueLength function throws a SDE when 
-->

  <tdml:parserTestCase name="valueLength_6" root="valueLength13"
    model="Functions.dfdl.xsd" description="Section 23 ">

    <tdml:document>
      <tdml:documentPart type="text"><![CDATA[test]]></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Runtime Schema Definition Error</tdml:error>
      <tdml:error>Value length unknown</tdml:error>
      <tdml:error>{http://example.com}x</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
    Test Name: valueLength_unparse_0
       Schema: Functions.dfdl.xsd
         Root: valueLength5
      Purpose: This test demonstrates the valueLength function with escapeCharacters during unparse.
-->

  <tdml:unparserTestCase name="valueLength_unparse_0" root="valueLength5"
    model="Functions.dfdl.xsd" description="Section 23 " roundTrip="false">

    <tdml:infoset>
      <tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
        <ex:valueLength5>
          <ex:str>te,st*</ex:str>
        </ex:valueLength5>
      </tdml:dfdlInfoset>
    </tdml:infoset>
    <tdml:document>
      <tdml:documentPart type="text"><![CDATA[te*,st!*;,64]]></tdml:documentPart>
    </tdml:document>
  </tdml:unparserTestCase>

<!--
    Test Name: valueLength_unparse_1
       Schema: Functions.dfdl.xsd
         Root: valueLength6
      Purpose: This test demonstrates the valueLength function with a lengthUnit of 'characters' during unparse.
-->

  <tdml:unparserTestCase name="valueLength_unparse_1" root="valueLength6"
    model="Functions.dfdl.xsd" description="Section 23 " roundTrip="false">

    <tdml:infoset>
      <tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
        <ex:valueLength6>
          <ex:str>test</ex:str>
        </ex:valueLength6>
      </tdml:dfdlInfoset>
    </tdml:infoset>
    <!--
    <tdml:document>
      <tdml:documentPart type="text"><![CDATA[test,4]]></tdml:documentPart>
    </tdml:document>
    -->
    <tdml:errors>
      <tdml:error>not yet supported</tdml:error>
      <tdml:error>characters</tdml:error>
    </tdml:errors>
  </tdml:unparserTestCase>

<!--
    Test Name: valueLength_unparse_2
       Schema: Functions.dfdl.xsd
         Root: valueLength7
      Purpose: This test demonstrates the valueLength function with a lengthUnit of 'bytes' during unparse.
-->

  <tdml:unparserTestCase name="valueLength_unparse_2" root="valueLength7"
    model="Functions.dfdl.xsd" description="Section 23 " roundTrip="false">

    <tdml:infoset>
      <tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
        <ex:valueLength7>
          <ex:str>test</ex:str>
        </ex:valueLength7>
      </tdml:dfdlInfoset>
    </tdml:infoset>
    <tdml:document>
      <tdml:documentPart type="text"><![CDATA[test,4]]></tdml:documentPart>
    </tdml:document>
  </tdml:unparserTestCase>

<!--
    Test Name: valueLength_unparse_3
       Schema: Functions.dfdl.xsd
         Root: valueLength9
      Purpose: This test demonstrates the valueLength function with a nil element during unparse.
-->

  <tdml:unparserTestCase name="valueLength_unparse_3" root="valueLength9"
    model="Functions.dfdl.xsd" description="Section 23 " roundTrip="false">

    <tdml:infoset>
      <tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
        <ex:valueLength9>
          <ex:str xsi:nil="true"/>
        </ex:valueLength9>
      </tdml:dfdlInfoset>
    </tdml:infoset>
    <tdml:document>
      <tdml:documentPart type="text"><![CDATA[NIL,3]]></tdml:documentPart>
    </tdml:document>
  </tdml:unparserTestCase>

<!--
    Test Name: valueLength_unparse_4
       Schema: Functions.dfdl.xsd
         Root: valueLength11
      Purpose: This test demonstrates the valueLength function with a complex element during unparse.
-->

  <tdml:unparserTestCase name="valueLength_unparse_4" root="valueLength11"
    model="Functions.dfdl.xsd" description="Section 23 " roundTrip="false">

    <tdml:infoset>
      <tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
        <ex:valueLength11>
          <ex:seq>
            <ex:num>1</ex:num>
            <ex:num>2</ex:num>
            <ex:num>3</ex:num>
            <ex:num>4</ex:num>
            <ex:num>5</ex:num>
            <ex:num>6</ex:num>
          </ex:seq>
        </ex:valueLength11>
      </tdml:dfdlInfoset>
    </tdml:infoset>
    <tdml:document>
      <tdml:documentPart type="text"><![CDATA[1,2,3,4,5,6;/12]]></tdml:documentPart>
    </tdml:document>
  </tdml:unparserTestCase>

<!--
    Test Name: contentLength_0
       Schema: Functions.dfdl.xsd
         Root: contentLength
      Purpose: This test demonstrates the contentLength function (formerly representationLength).
-->

  <tdml:parserTestCase name="contentLength_0" root="contentLength"
    model="Functions.dfdl.xsd" description="Section 23 " roundTrip="false">

    <tdml:document>
      <tdml:documentPart type="text"><![CDATA[////test////]]></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
        <contentLength>
          <str>test</str>
          <conLen>12</conLen>
        </contentLength>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: contentLength_1
       Schema: Functions.dfdl.xsd
         Root: contentLength2
      Purpose: This test demonstrates the contentLength function (formerly representationLength).
-->

  <tdml:parserTestCase name="contentLength_1" root="contentLength2"
    model="Functions.dfdl.xsd" description="Section 23 " roundTrip="false">

    <tdml:document>
      <tdml:documentPart type="text"><![CDATA[////test////]]></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
        <contentLength2>
          <str>test</str>
          <conLen>96</conLen>
        </contentLength2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: contentLength_2
       Schema: Functions.dfdl.xsd
         Root: contentLength3
      Purpose: This test demonstrates the contentLength function (formerly representationLength).
-->

  <tdml:parserTestCase name="contentLength_2" root="contentLength3"
    model="Functions.dfdl.xsd" description="Section 23 " roundTrip="false">

    <tdml:document>
      <tdml:documentPart type="text"><![CDATA[////test////]]></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Runtime Schema Definition Error</tdml:error>
      <tdml:error>Content length unknown</tdml:error>
      <tdml:error>{http://example.com}x</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
    Test Name: valueContentLength1
       Schema: Functions.dfdl.xsd
         Root: valueContentLength1
      Purpose: This test demonstrates the contentLength and valueLength functions
-->

  <tdml:parserTestCase name="valueContentLength1" root="valueContentLength1"
    model="Functions-binary.dfdl.xsd" description="dfdl:valueLength and dfdl:contentLength functions."
    roundTrip="twoPass">

    <tdml:document>
      <tdml:documentPart type="bits">10101000 01010100 110011</tdml:documentPart>
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:valueContentLength1>
          <ex:c1>
            <ex:e1>42</ex:e1>
            <ex:e2>21</ex:e2>
          </ex:c1>
          <ex:e3>51</ex:e3>
          <ex:c1CL>15</ex:c1CL>
          <ex:c1VL>14</ex:c1VL>
          <ex:e1CL>6</ex:e1CL>
          <ex:e1VL>6</ex:e1VL>
          <ex:e2CL>6</ex:e2CL>
          <ex:e2VL>6</ex:e2VL>
          <ex:e3CL>6</ex:e3CL>
          <ex:e3VL>6</ex:e3VL>
        </ex:valueContentLength1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: valueContentLength2
       Schema: Functions.dfdl.xsd
         Root: valueContentLength2
      Purpose: This test demonstrates the contentLength and valueLength functions
-->

  <tdml:parserTestCase name="valueContentLength2" root="valueContentLength2"
    model="Functions-binary.dfdl.xsd" description="dfdl:outputValueCalc and dfdl:valueLength during parse."
    roundTrip="twoPass">

    <tdml:document>
      <tdml:documentPart type="bits">10101000 01010100 110011</tdml:documentPart>
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:valueContentLength2>
          <ex:c1>
            <ex:e1>42</ex:e1>
            <ex:e2>21</ex:e2>
          </ex:c1>
          <ex:e3>51</ex:e3>
          <ex:c1CL>14</ex:c1CL>
          <ex:c1VL>14</ex:c1VL>
          <ex:e1CL>6</ex:e1CL>
          <ex:e1VL>6</ex:e1VL>
          <ex:e2CL>6</ex:e2CL>
          <ex:e2VL>6</ex:e2VL>
          <ex:e3CL>6</ex:e3CL>
          <ex:e3VL>6</ex:e3VL>
        </ex:valueContentLength2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <tdml:defineSchema name="XPathFunctions">
    <xs:include schemaLocation="org/apache/daffodil/xsd/DFDLGeneralFormat.dfdl.xsd"/>
    <dfdl:format ref="ex:GeneralFormat"/>

    <xs:element name="abs" type="xs:int" dfdl:inputValueCalc="{ fn:abs(-9) }"/>

    <xs:element name="abs02">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="val" type="xs:int" dfdl:lengthKind="delimited"/>
          <xs:element name="absval" type="xs:int" dfdl:inputValueCalc="{ fn:abs(../ex:val) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="abs03">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="val" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="absval" type="xs:int" dfdl:inputValueCalc="{ fn:abs(xs:int(../ex:val)) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="abs04">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="val" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element xmlns:tst="http://www.w3.org/2005/xpath-functions" name="absval" type="xs:int" dfdl:inputValueCalc="{ tst:abs(xs:int(../ex:val)) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="abs05">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="val" type="xs:int" dfdl:lengthKind="delimited"/>
          <xs:element name="absval" type="xs:int" dfdl:inputValueCalc="{ fn:abs(../ex:val) }"/>
          <xs:element name="choice">
            <xs:complexType>
              <xs:choice>
                <xs:sequence>
                  <xs:element name="nonNeg" type="xs:nonNegativeInteger" dfdl:inputValueCalc="{ /ex:abs05/ex:absval }"/>
                </xs:sequence>
                <xs:sequence>
                  <xs:element name="int" type="xs:int" dfdl:inputValueCalc="{ /ex:abs05/ex:absval }"/>
                </xs:sequence>
              </xs:choice>
            </xs:complexType>
          </xs:element> 
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="abs06">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="val" type="xs:float" dfdl:lengthKind="delimited"/>
          <xs:element name="absval" type="xs:float" dfdl:inputValueCalc="{ fn:abs(/ex:abs06/ex:val) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="abs07">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="val" type="xs:hexBinary" dfdl:lengthKind="delimited"/>
          <xs:element name="absval" type="xs:int" dfdl:inputValueCalc="{ fn:abs(/ex:abs07/ex:val) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="abs08">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="one" type="xs:int" dfdl:lengthKind="delimited"/>
          <xs:element name="two" type="xs:float" dfdl:lengthKind="delimited"/>
          <xs:element name="three" type="xs:long" dfdl:lengthKind="delimited" />
          <xs:element name="absval" type="xs:float" dfdl:inputValueCalc="{ fn:abs(../ex:one - ../ex:two - ../ex:three) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="abs09">
      <xs:complexType>
        <xs:sequence dfdl:separator="">
          <xs:element name="one" type="xs:int" dfdl:representation="binary" dfdl:lengthKind="explicit" dfdl:length="1"/>
          <xs:element name="two" type="xs:float"  dfdl:representation="binary" dfdl:lengthKind="explicit" dfdl:length="4"/>
          <xs:element name="three" type="xs:short" dfdl:representation="binary" dfdl:lengthKind="explicit" dfdl:length="2"/>
          <xs:element name="absval" type="xs:float" dfdl:inputValueCalc="{ fn:abs(../ex:one - ../ex:two - ../ex:three) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
 
    <xs:element name="ceil" type="xs:double" dfdl:inputValueCalc="{ fn:ceiling(4.2) }"/>

    <xs:element name="ceil02">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="val" type="xs:float" dfdl:lengthKind="delimited"/>
          <xs:element name="ceilval" type="xs:float" dfdl:inputValueCalc="{ fn:ceiling(../ex:val) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="ceil03">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="val" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="ceilval" type="xs:double" dfdl:inputValueCalc="{ fn:ceiling(xs:double(../ex:val)) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="ceil04">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="val" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element xmlns:tst="http://www.w3.org/2005/xpath-functions" name="ceilval" type="xs:double" dfdl:inputValueCalc="{ tst:ceiling(xs:double(../ex:val)) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="ceil05">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="val" type="xs:hexBinary" dfdl:lengthKind="delimited" dfdl:encoding="ISO-8859-1"/>
          <xs:element name="ceilval" type="xs:double" dfdl:inputValueCalc="{ fn:ceiling(../ex:val) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="ceil06">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="val" type="xs:float" dfdl:lengthKind="delimited"/>
          <xs:element name="ceilval" dfdl:inputValueCalc="{ fn:ceiling(../ex:val) }">
            <xs:simpleType>
              <xs:restriction base="xs:float">
                <xs:maxExclusive value="50"/>
                <xs:minExclusive value="0"/>
              </xs:restriction>
            </xs:simpleType>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="ceil07">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="val" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="ceilval" type="xs:double" dfdl:inputValueCalc="{ fn:ceiling(../ex:val) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="ceil08" type="xs:decimal" dfdl:inputValueCalc="{ fn:ceiling(xs:decimal(0.125)) }"/>

    <xs:element name="floor" type="xs:double" dfdl:inputValueCalc="{ fn:floor(4.2) }"/>

    <xs:element name="floor02">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="val" type="xs:float" dfdl:lengthKind="delimited"/>
          <xs:element name="floorval" type="xs:float" dfdl:inputValueCalc="{ fn:floor(../ex:val) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="floor03">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="val" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="floorval" type="xs:double" dfdl:inputValueCalc="{ fn:floor(xs:double(../ex:val)) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="floor04">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="val" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element xmlns:tst="http://www.w3.org/2005/xpath-functions" name="floorval" type="xs:double" dfdl:inputValueCalc="{ tst:floor(xs:double(../ex:val)) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="floor05">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="val" type="xs:float" dfdl:lengthKind="delimited"/>
          <xs:element name="floorval" dfdl:inputValueCalc="{ fn:floor(../ex:val) }">
            <xs:simpleType>
              <xs:restriction base="xs:float">
                <xs:maxExclusive value="50"/>
                <xs:minExclusive value="0"/>
              </xs:restriction>
            </xs:simpleType>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="floor06">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="val" type="xs:hexBinary" dfdl:lengthKind="delimited" dfdl:encoding="ISO-8859-1"/>
          <xs:element name="floorval" type="xs:int" dfdl:inputValueCalc="{ fn:floor(xs:hexBinary(../ex:val)) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="floor07">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="val" type="xs:float" dfdl:representation="binary" dfdl:lengthKind="explicit" dfdl:length="4"/>
          <xs:element name="floorval" type="xs:float" dfdl:inputValueCalc="{ fn:floor(../ex:val) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="floor08" type="xs:decimal" dfdl:inputValueCalc="{ fn:floor(xs:decimal(0.125)) }"/>

    <xs:element name="round" type="xs:double" dfdl:inputValueCalc="{ fn:round(4.2) }"/>

    <xs:element name="round02">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="val" type="xs:float" dfdl:lengthKind="delimited" dfdl:textStandardInfinityRep="INF" dfdl:textStandardNaNRep="NaN"/>
          <xs:element name="roundval" type="xs:float" dfdl:inputValueCalc="{ fn:round(../ex:val) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="round03">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="val" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="roundval" type="xs:double" dfdl:inputValueCalc="{ fn:round(xs:double(../ex:val)) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="round04">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="val" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element xmlns:tst="http://www.w3.org/2005/xpath-functions" name="roundval" type="xs:double" dfdl:inputValueCalc="{ tst:round(xs:double(../ex:val)) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="round05">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="val" type="xs:float" dfdl:representation="binary" dfdl:lengthKind="explicit" dfdl:length="4"/>
          <xs:element name="roundval" type="xs:float" dfdl:inputValueCalc="{ fn:round(../ex:val) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="round06">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="one" type="xs:float" dfdl:representation="binary" dfdl:lengthKind="explicit" dfdl:length="4"/>
          <xs:element name="two" type="xs:float" dfdl:representation="binary" dfdl:lengthKind="explicit" dfdl:length="4"/>
          <xs:element name="roundval" type="xs:float" dfdl:inputValueCalc="{ fn:round(../ex:one + ../ex:two) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="round07">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="val" type="xs:float" dfdl:lengthKind="delimited" dfdl:textStandardInfinityRep="INFINITY" dfdl:textStandardNaNRep="NaN"/>
          <xs:element name="roundval" type="xs:float" dfdl:inputValueCalc="{ fn:round(../ex:val) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="round08" type="xs:decimal" dfdl:inputValueCalc="{ fn:round(xs:decimal(0.125)) }"/>
    <xs:element name="round09" type="xs:decimal" dfdl:inputValueCalc="{ fn:round(xs:decimal(0.5)) }"/>
    <xs:element name="round10">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="val" type="xs:decimal" dfdl:inputValueCalc="{ xs:decimal(0.5) }"/>
          <xs:element name="roundVal" type="xs:decimal" dfdl:inputValueCalc="{ fn:round(../ex:val) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="round-hte">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="num" type="xs:float" dfdl:lengthKind="delimited" dfdl:textNumberPattern="#.#######"/>
          <xs:element name="precision" type="xs:int" dfdl:lengthKind="delimited"/>
          <xs:element name="roundval" type="xs:float" dfdl:inputValueCalc="{ fn:round-half-to-even(../ex:num,../ex:precision) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="round-hte-2">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="num" type="xs:float" dfdl:lengthKind="delimited" dfdl:textStandardInfinityRep="INF" dfdl:textStandardNaNRep="NaN"/>
          <xs:element name="precision" type="xs:int" dfdl:lengthKind="delimited"/>
          <xs:element name="roundval" type="xs:float" dfdl:inputValueCalc="{ fn:round-half-to-even(../ex:num,../ex:precision) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="round-hte-3">
      <xs:complexType>
        <xs:sequence dfdl:separator="">
          <xs:element name="num" type="xs:float" dfdl:representation="binary" dfdl:lengthKind="explicit" dfdl:length="4"/>
          <xs:element name="precision" type="xs:int" dfdl:representation="binary" dfdl:lengthKind="explicit" dfdl:length="2" />
          <xs:element name="roundval" type="xs:float" dfdl:inputValueCalc="{ fn:round-half-to-even(../ex:num,../ex:precision) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="round-hte-4">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="num" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="precision" type="xs:int" dfdl:lengthKind="delimited" />
          <xs:element name="roundval" type="xs:float" dfdl:inputValueCalc="{ fn:round-half-to-even(../ex:num,../ex:precision) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="round-hte-5">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="num" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="roundval" type="xs:double" dfdl:inputValueCalc="{ fn:round-half-to-even(xs:double(../ex:num)) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="round-hte-6">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="num" dfdl:representation="binary" type="xs:float" dfdl:lengthKind="explicit" dfdl:lengthUnits="bytes" dfdl:length="4"/>
          <xs:element name="roundval" type="xs:double" dfdl:inputValueCalc="{ fn:round-half-to-even(xs:double(../ex:num)) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="round-hte-7">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="num" type="xs:float" dfdl:lengthKind="delimited" dfdl:textNumberPattern="#.#######"/>
          <xs:element name="precision" type="xs:int" dfdl:lengthKind="delimited"/>
          <xs:element name="roundval" type="xs:int" dfdl:inputValueCalc="{ xs:int(fn:round-half-to-even(../ex:num,../ex:precision)) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="round-hte-8">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="num" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="roundval" type="xs:int" dfdl:inputValueCalc="{ xs:int(fn:round-half-to-even(xs:double(../ex:num))) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="empty01">
      <xs:complexType>
        <xs:sequence dfdl:separator="|">
          <xs:element name="seq">
            <xs:complexType>
              <xs:sequence dfdl:separator=",">
                <xs:element name="item" type="xs:string" minOccurs="0" maxOccurs="10" dfdl:lengthKind="delimited"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="empty" type="xs:boolean" dfdl:inputValueCalc="{ fn:empty(../ex:seq/ex:item) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="empty02">
      <xs:complexType>
        <xs:sequence dfdl:separator="|">
          <xs:element name="seq">
            <xs:complexType>
              <xs:sequence dfdl:separator=",">
                <xs:element name="item" type="xs:string" minOccurs="0" maxOccurs="10" dfdl:lengthKind="explicit" dfdl:length="5"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="empty" type="xs:boolean" dfdl:inputValueCalc="{ fn:empty(../ex:seq/ex:item) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="empty03">
      <xs:complexType>
        <xs:sequence dfdl:separator="|">
          <xs:element name="seq">
            <xs:complexType>
              <xs:sequence dfdl:separator=",">
                <xs:element name="item" type="xs:string" minOccurs="0" maxOccurs="3" dfdl:inputValueCalc="{ '123' }"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="empty" type="xs:boolean" dfdl:inputValueCalc="{ fn:empty(../ex:seq/ex:item) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="empty04">
      <xs:complexType>
        <xs:sequence dfdl:separator="|">
          <xs:element name="queue">
            <xs:complexType>
              <xs:sequence dfdl:separator=",">
                <xs:element name="order_num" type="xs:int" minOccurs="0" maxOccurs="3" dfdl:lengthKind="delimited"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="choice">
            <xs:complexType>
              <xs:choice>
                <xs:sequence>
                <xs:element name="empty" type="xs:string" dfdl:inputValueCalc="{ 'There is no one waiting right now' }">
                  <xs:annotation>
                    <xs:appinfo source="http://www.ogf.org/dfdl/">
                      <dfdl:discriminator><![CDATA[{ fn:empty(/ex:empty04/ex:queue/ex:order_num) }]]></dfdl:discriminator>
                    </xs:appinfo>
                  </xs:annotation>
                </xs:element>
                </xs:sequence>
                <xs:element name="orders">
                  <xs:complexType>
                    <xs:sequence dfdl:separator=",">
                      <xs:element name="order" type="xs:string" minOccurs="1" maxOccurs="3" dfdl:lengthKind="delimited"/>
                    </xs:sequence>
                  </xs:complexType>
                </xs:element>
              </xs:choice>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="empty05" type="xs:boolean" dfdl:inputValueCalc="{ fn:empty() }"/>

    <xs:element name="empty06" type="xs:boolean" dfdl:inputValueCalc="{ fn:empty(/ex:IDONOTEXIST) }"/>

    <xs:element name="exists01">
      <xs:complexType>
        <xs:sequence dfdl:separator="|">
          <xs:element name="seq">
            <xs:complexType>
              <xs:sequence dfdl:separator=",">
                <xs:element name="item" type="xs:string" minOccurs="0" maxOccurs="10" dfdl:lengthKind="delimited"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="exists" type="xs:boolean" dfdl:inputValueCalc="{ fn:exists(../ex:seq/ex:item) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="exists02">
      <xs:complexType>
        <xs:sequence dfdl:separator="|">
          <xs:element name="seq">
            <xs:complexType>
              <xs:sequence dfdl:separator=",">
                <xs:element name="item" type="xs:string" minOccurs="0" maxOccurs="10" dfdl:lengthKind="explicit" dfdl:length="5"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="exists" type="xs:boolean" dfdl:inputValueCalc="{ fn:exists(../ex:seq/ex:item) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="exists03">
      <xs:complexType>
        <xs:sequence dfdl:separator="|">
          <xs:element name="seq">
            <xs:complexType>
              <xs:sequence dfdl:separator=",">
                <xs:element name="item" type="xs:string" minOccurs="0" maxOccurs="3" dfdl:inputValueCalc="{ '123' }"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="exists" type="xs:boolean" dfdl:inputValueCalc="{ fn:exists(../ex:seq/ex:item) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="exists04">
      <xs:complexType>
        <xs:sequence dfdl:separator="|">
          <xs:element name="queue">
            <xs:complexType>
              <xs:sequence dfdl:separator=",">
                <xs:element name="order_num" type="xs:int" minOccurs="0" maxOccurs="3" dfdl:lengthKind="delimited"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="choice">
            <xs:complexType>
              <xs:choice>
                <xs:element name="orders">
                  <xs:annotation>
                    <xs:appinfo source="http://www.ogf.org/dfdl/">
                      <dfdl:discriminator><![CDATA[{ fn:exists(/ex:exists04/ex:queue/ex:order_num) }]]></dfdl:discriminator>
                    </xs:appinfo>
                  </xs:annotation>
                  <xs:complexType>
                    <xs:sequence dfdl:separator=",">
                      <xs:element name="order" type="xs:string" minOccurs="1" maxOccurs="3" dfdl:lengthKind="delimited"/>
                    </xs:sequence>
                  </xs:complexType>
                </xs:element>
                <xs:sequence>
                  <xs:element name="exists" type="xs:string" dfdl:inputValueCalc="{ 'There is no one waiting right now' }"/>
                </xs:sequence>
              </xs:choice>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="exists05" type="xs:boolean" dfdl:inputValueCalc="{ fn:exists() }"/>

    <xs:element name="exists06" type="xs:boolean" dfdl:inputValueCalc="{ fn:exists(/ex:IDONOTEXIST) }"/>
    
    <xs:group name="hiddenData">
      <xs:sequence dfdl:separator="|" dfdl:sequenceKind="unordered">
        <xs:element name="password" type="xs:string" dfdl:initiator="pw:" minOccurs="0" maxOccurs="1" dfdl:lengthKind="delimited"/>
        <xs:element name="ssn" type="xs:string" dfdl:initiator="ssn:" minOccurs="0" maxOccurs="1" dfdl:lengthKind="delimited"/>
        <xs:element name="dob" type="xs:string" dfdl:initiator="dob:" minOccurs="0" maxOccurs="1" dfdl:lengthKind="delimited"/>
      </xs:sequence>
    </xs:group>    
    
    <xs:element name="exists07">
      <xs:complexType>
        <xs:sequence dfdl:separator="">
           <xs:element name="info">
              <xs:complexType>
                <xs:sequence dfdl:separator=",">
                  <xs:element name="name" type="xs:string" dfdl:lengthKind="delimited"/>
                  <xs:element name="data">
                    <xs:complexType>
                      <xs:sequence dfdl:hiddenGroupRef="ex:hiddenData"/>
                    </xs:complexType>
                  </xs:element>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name="passwordExists" type="xs:boolean" dfdl:lengthKind="delimited" dfdl:inputValueCalc="{ if (fn:exists(/ex:exists07/ex:info/ex:data/ex:password)) then fn:true() else fn:false() }"/>
            <xs:element name="dobExists" type="xs:boolean" dfdl:lengthKind="delimited" dfdl:inputValueCalc="{ if (fn:exists(/ex:exists07/ex:info/ex:data/ex:dob)) then fn:true() else fn:false() }"/>
            <xs:element name="ssnExists" type="xs:boolean" dfdl:lengthKind="delimited" dfdl:inputValueCalc="{ if (fn:exists(/ex:exists07/ex:info/ex:data/ex:ssn)) then fn:true() else fn:false() }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="exists08">
      <xs:complexType>
        <xs:sequence dfdl:separator="|">
          <xs:element name="seq">
            <xs:complexType>
              <xs:sequence dfdl:separator=",">
                <xs:element name="item" type="xs:string" minOccurs="0" maxOccurs="10" dfdl:lengthKind="delimited"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="exists" type="xs:boolean" dfdl:inputValueCalc="{ fn:exists(../ex:seq/ex:item[10]) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="exactly-one01">
      <xs:complexType>
        <xs:sequence dfdl:separator="|">
          <xs:element name="seq">
            <xs:complexType>
              <xs:sequence dfdl:separator=",">
                <xs:element name="item" type="xs:int" minOccurs="0" maxOccurs="3" dfdl:lengthKind="delimited"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="exactly-one" type="xs:boolean" dfdl:inputValueCalc="{ fn:exactly-one(../ex:seq/ex:item) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="exactly-one02" type="xs:boolean" dfdl:inputValueCalc="{ fn:exactly-one() } "/>

    <xs:element name="exactly-one03">
      <xs:complexType>
        <xs:sequence dfdl:separator="|">
          <xs:element name="seq">
            <xs:complexType>
              <xs:sequence dfdl:separator=",">
                <xs:element name="name" type="xs:string" dfdl:lengthKind="delimited" minOccurs="0" maxOccurs="5" dfdl:initiator="name:"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="choice">
            <xs:complexType>
              <xs:choice>
                <xs:element name="notEnough" type="xs:string" dfdl:inputValueCalc="{ 'not enough info' }">
                  <xs:annotation>
                    <xs:appinfo source="http://www.ogf.org/dfdl/">
                      <dfdl:discriminator><![CDATA[{ fn:exactly-one(/ex:exactly-one03/ex:seq/ex:name) }]]></dfdl:discriminator>
                    </xs:appinfo>
                  </xs:annotation>
                </xs:element>
                <xs:element name="enough" type="xs:string" dfdl:inputValueCalc="{ 'enough' }"/> 
              </xs:choice>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="exactly-one04">
      <xs:complexType>
        <xs:sequence dfdl:separator="|">
          <xs:element name="seq">
            <xs:complexType>
              <xs:sequence dfdl:separator=",">
                <xs:element name="first" type="xs:string" dfdl:lengthKind="delimited" minOccurs="0" maxOccurs="1" dfdl:initiator="first:"/>
                <xs:element name="last" type="xs:string" dfdl:lengthKind="delimited" minOccurs="0" maxOccurs="1" dfdl:initiator="last:"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="exacOne" type="xs:boolean" dfdl:inputValueCalc="{ fn:exactly-one(/ex:exactly-one04/ex:seq) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="count01">
      <xs:complexType>
        <xs:sequence dfdl:separator="|">
          <xs:element name="seq">
            <xs:complexType>
              <xs:sequence dfdl:separator=",">
                <xs:element name="item" type="xs:int" minOccurs="0" maxOccurs="15" dfdl:lengthKind="delimited"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="count" type="xs:int" dfdl:inputValueCalc="{ fn:count(../ex:seq/ex:item) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="count02">
      <xs:complexType>
        <xs:sequence dfdl:separator="|">
          <xs:element name="calced" type="xs:string" dfdl:inputValueCalc="{ 'calculated string' }"/>
          <xs:element name="count" type="xs:int" dfdl:inputValueCalc="{ fn:count(../ex:calced) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="count02b">
      <xs:complexType>
        <xs:sequence dfdl:separator="|">
          <xs:element name="str" type="xs:string" dfdl:inputValueCalc="{ 'calculated string' }"/>
          <xs:element name="calced" type="xs:string" dfdl:inputValueCalc="{ ../ex:str }"/>
          <xs:element name="count" type="xs:int" dfdl:inputValueCalc="{ fn:count(../ex:calced) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="count03">
      <xs:complexType>
        <xs:sequence dfdl:separator="|">
          <xs:element name="scores">
            <xs:complexType>
              <xs:sequence dfdl:separator="," dfdl:sequenceKind="unordered">
                <xs:element name="bobcats" type="xs:int" minOccurs="0" maxOccurs="10" dfdl:initiator="B:" dfdl:lengthKind="delimited"/>
                <xs:element name="pirates" type="xs:int" minOccurs="0" maxOccurs="10" dfdl:initiator="P:" dfdl:lengthKind="delimited"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="bobcatScoreCount" type="xs:int" dfdl:inputValueCalc="{ fn:count(/ex:count03/ex:scores/ex:bobcats) }"/>
          <xs:element name="pirateScoreCount" type="xs:int" dfdl:inputValueCalc="{ fn:count(/ex:count03/ex:scores/ex:pirates) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="count03b">
      <xs:complexType>
        <xs:sequence dfdl:separator="|">
          <xs:element name="scores">
            <xs:complexType>
              <xs:sequence dfdl:separator="," dfdl:sequenceKind="unordered">
                <xs:element name="bobcats" type="xs:int" minOccurs="0" maxOccurs="unbounded" dfdl:initiator="B:" dfdl:lengthKind="delimited"/>
                <xs:element name="pirates" type="xs:int" minOccurs="0" maxOccurs="unbounded" dfdl:initiator="P:" dfdl:lengthKind="delimited"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="bobcatScoreCount" type="xs:int" dfdl:inputValueCalc="{ fn:count(/ex:count03b/ex:scores/ex:bobcats) }"/>
          <xs:element name="pirateScoreCount" type="xs:int" dfdl:inputValueCalc="{ fn:count(/ex:count03b/ex:scores/ex:pirates) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="count03c">
      <xs:complexType>
        <xs:sequence dfdl:separator="|">
          <xs:element name="scores">
            <xs:complexType>
              <xs:sequence dfdl:separator="," dfdl:sequenceKind="ordered">
                <xs:element name="bobcats" type="xs:int" minOccurs="0" maxOccurs="10" dfdl:initiator="B:" dfdl:lengthKind="delimited"/>
                <xs:element name="pirates" type="xs:int" minOccurs="0" maxOccurs="10" dfdl:initiator="P:" dfdl:lengthKind="delimited"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="bobcatScoreCount" type="xs:int" dfdl:inputValueCalc="{ fn:count(/ex:count03c/ex:scores/ex:bobcats) }"/>
          <xs:element name="pirateScoreCount" type="xs:int" dfdl:inputValueCalc="{ fn:count(/ex:count03c/ex:scores/ex:pirates) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="count04" type="xs:int" dfdl:inputValueCalc="{ fn:count() }"/>
    
    <xs:element name="count05">
      <xs:complexType>
        <xs:sequence dfdl:separator="|">
          <xs:element name="ints">
            <xs:complexType>
              <xs:sequence dfdl:separator="," dfdl:sequenceKind="unordered">
                <xs:element name="int" type="xs:int" minOccurs="0" maxOccurs="10" dfdl:lengthKind="delimited"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="numints" type="xs:int" dfdl:inputValueCalc="{ fn:count(/ex:count05/ex:ints/ex:int, /ex:count05/ex:ints/ex:int) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="count05b">
      <xs:complexType>
        <xs:sequence dfdl:separator="|">
          <xs:element name="ints">
            <xs:complexType>
              <xs:sequence dfdl:separator="," dfdl:sequenceKind="ordered">
                <xs:element name="int" type="xs:int" minOccurs="0" maxOccurs="10" dfdl:lengthKind="delimited"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="numints" type="xs:int" dfdl:inputValueCalc="{ fn:count(/ex:count05b/ex:ints/ex:int, /ex:count05b/ex:ints/ex:int) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="local-name01">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="inty" type="xs:int" dfdl:lengthKind="delimited"/>
          <xs:element name="local" type="xs:string" dfdl:inputValueCalc="{ fn:local-name(/ex:local-name01/ex:inty) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="dummy" type="xs:string" dfdl:lengthKind="delimited" dfdl:initiator="dummy:"/>

    <xs:element name="local-name02">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element ref="ex:dummy"/>
          <xs:element name="local" type="xs:string" dfdl:inputValueCalc="{ fn:local-name(/ex:local-name02/ex:dummy) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="local-name03" type="xs:string" dfdl:inputValueCalc="{ fn:local-name() }"/>
    
    <xs:element name="local-name04">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="local" type="xs:string" dfdl:inputValueCalc="{ fn:local-name(..) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="team" type="xs:string" dfdl:inputValueCalc="{ fn:local-name(..) }"/>   
 
    <xs:element name="local-name05">
      <xs:complexType>
        <xs:sequence dfdl:separator="|">
          <xs:element name="entry" minOccurs="0" maxOccurs="10">
            <xs:complexType>
              <xs:choice>
                <xs:element name="blue">
                  <xs:annotation>
                    <xs:appinfo source="http://www.ogf.org/dfdl/">
                      <dfdl:discriminator><![CDATA[{ fn:starts-with(./ex:player, "B") }]]></dfdl:discriminator>
                    </xs:appinfo>
                  </xs:annotation>
                  <xs:complexType>
                    <xs:sequence dfdl:separator=",">
                      <xs:element name="player" type="xs:string" dfdl:lengthKind="delimited"/>
                      <xs:element ref="ex:team"/>
                    </xs:sequence>
                  </xs:complexType>
                </xs:element>
                <xs:element name="red">
                  <xs:annotation>
                    <xs:appinfo source="http://www.ogf.org/dfdl/">
                      <dfdl:discriminator><![CDATA[{ fn:starts-with(./ex:player, "R") }]]></dfdl:discriminator>
                    </xs:appinfo>
                  </xs:annotation>
                  <xs:complexType>
                    <xs:sequence dfdl:separator=",">
                      <xs:element name="player" type="xs:string" dfdl:lengthKind="delimited"/>
                      <xs:element ref="ex:team"/>
                    </xs:sequence>
                  </xs:complexType>
                </xs:element>
              </xs:choice>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="ambig" type="xs:string" dfdl:lengthKind="delimited"/>
    
    <xs:element name="local-name06">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="ambig" type="xs:string" dfdl:lengthKind="delimited" dfdl:initiator="5"/>
          <xs:element ref="ex:ambig"/>
          <xs:element name="ambig" type="xs:string" dfdl:lengthKind="delimited" dfdl:initiator="7"/>
          <xs:element name="which" type="xs:string" dfdl:inputValueCalc="{ fn:local-name(/ex:local-name06/ex:ambig) }"/>
          <xs:element name="which2" type="xs:string" dfdl:inputValueCalc="{ /ex:local-name06/ex:ambig }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="local-name07">
      <xs:complexType>
        <xs:sequence dfdl:separator="^">
           <xs:element name="info">
              <xs:complexType>
                <xs:sequence dfdl:separator=",">
                  <xs:element name="name" type="xs:string" dfdl:lengthKind="delimited"/>
                  <xs:element name="data">
                    <xs:complexType>
                      <xs:sequence dfdl:hiddenGroupRef="ex:hiddenData"/>
                    </xs:complexType>
                  </xs:element>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name="provided1" type="xs:string" dfdl:inputValueCalc="{ fn:local-name(/ex:local-name07/ex:info/ex:data/ex:password) }"/>
            <xs:element name="provided2" type="xs:string" dfdl:inputValueCalc="{ fn:local-name(/ex:local-name07/ex:info/ex:data/ex:dob) }"/>
            <xs:element name="provided3" type="xs:string" dfdl:inputValueCalc="{ fn:local-name(/ex:local-name07/ex:info/ex:data/ex:ssn) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="namespace-uri01">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="inty" type="xs:int" dfdl:lengthKind="delimited"/>
          <xs:element name="local" type="xs:string" dfdl:inputValueCalc="{ fn:namespace-uri(/ex:namespace-uri01/ex:inty) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="namespace-uri02">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="inty" type="xs:int" dfdl:lengthKind="delimited"/>
          <xs:element name="local" type="xs:string" dfdl:inputValueCalc="{ fn:namespace-uri() }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

  </tdml:defineSchema>

<!--
    Test Name: xPathFunc_abs_01
       Schema: XPathFunctions
         Root: abs
      Purpose: This test demonstrates abs (absolute value) function
-->

  <tdml:parserTestCase name="xPathFunc_abs_01" root="abs"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - abs - DFDL-23-094R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <abs>9</abs>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
<!--
    Test Name: xPathFunc_abs_02
       Schema: XPathFunctions
         Root: abs02
      Purpose: This test demonstrates abs (absolute value) function
-->

  <tdml:parserTestCase name="xPathFunc_abs_02" root="abs02"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - abs - DFDL-23-094R">

    <tdml:document>
      <tdml:documentPart type="text">-30</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <abs02>
          <val>-30</val>
          <absval>30</absval>
        </abs02>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
<!--
    Test Name: xPathFunc_abs_03
       Schema: XPathFunctions
         Root: abs03
      Purpose: This test demonstrates abs (absolute value) function
-->

  <tdml:parserTestCase name="xPathFunc_abs_03" root="abs03"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - abs - DFDL-23-094R">

    <tdml:document>
      <tdml:documentPart type="text">string</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>convert</tdml:error>
      <tdml:error>string</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
<!--
    Test Name: xPathFunc_abs_04
       Schema: XPathFunctions
         Root: abs04
      Purpose: This test demonstrates abs (absolute value) function
-->

  <tdml:parserTestCase name="xPathFunc_abs_04" root="abs04"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - abs - DFDL-23-094R">

    <tdml:document>
      <tdml:documentPart type="text">-30</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <abs04>
          <val>-30</val>
          <absval>30</absval>
        </abs04>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: abs_05
       Schema: XPathFunctions
         Root: abs05
      Purpose: This test demonstrates the absolute value function
-->

  <tdml:parserTestCase name="abs_05" root="abs05"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - abs - DFDL-23-094R">

    <tdml:document>
      <tdml:documentPart type="text">-30</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <abs05>
          <val>-30</val>
          <absval>30</absval>
          <choice>
            <nonNeg>30</nonNeg>
          </choice>
        </abs05>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: abs_06
       Schema: XPathFunctions
         Root: abs06
      Purpose: This test demonstrates the absolute value function when passed a float
-->

  <tdml:parserTestCase name="abs_06" root="abs06"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - abs - DFDL-23-094R">

    <tdml:document>
      <tdml:documentPart type="text">-4.563</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <abs06>
          <val>-4.563</val>
          <absval>4.563</absval>
        </abs06>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: abs_07
       Schema: XPathFunctions
         Root: abs07
      Purpose: This test demonstrates the absolute value function when passed hexBinary
-->

  <tdml:parserTestCase name="abs_07" root="abs07"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - abs - DFDL-23-094R">

    <tdml:document>
      <tdml:documentPart type="text">11</tdml:documentPart>
    </tdml:document>
      <tdml:errors>
        <tdml:error>Schema Definition Error</tdml:error>
      </tdml:errors>
  </tdml:parserTestCase>

<!--
    Test Name: abs_08
       Schema: XPathFunctions
         Root: abs08
      Purpose: This test demonstrates the absolute value function when passed an arithmetic operation using previoulsly-parsed values
-->

  <tdml:parserTestCase name="abs_08" root="abs08"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - abs - DFDL-23-094R">

    <tdml:document>
      <tdml:documentPart type="text">100,200,500</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <abs08>
          <one>100</one>
          <two>200.0</two>
          <three>500</three>
          <absval>600.0</absval>
        </abs08>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: abs_09
       Schema: XPathFunctions
         Root: abs09
      Purpose: This test demonstrates the absolute value function when passed an arithmetic operation using previoulsly-parsed values (binary)
-->

  <tdml:parserTestCase name="abs_09" root="abs09"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - abs - DFDL-23-094R">

    <tdml:document>
      <tdml:documentPart type="byte">64 43480000 01F4 </tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <abs09>
          <one>100</one>
          <two>200.0</two>
          <three>500</three>
          <absval>600.0</absval>
        </abs09>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>


<!--
    Test Name: xPathFunc_ceil_01
       Schema: XPathFunctions
         Root: ceil
      Purpose: This test demonstrates the ceiling function
-->

  <tdml:parserTestCase name="xPathFunc_ceil_01" root="ceil"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - ceiling - DFDL-23-095R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ceil>5.0</ceil>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
<!--
    Test Name: xPathFunc_ceil_02
       Schema: XPathFunctions
         Root: ceil02
      Purpose: This test demonstrates the ceiling function
-->

  <tdml:parserTestCase name="xPathFunc_ceil_02" root="ceil02"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - ceiling - DFDL-23-095R">

    <tdml:document>
      <tdml:documentPart type="text">6.1</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ceil02>
          <val>6.1</val>
          <ceilval>7.0</ceilval>
        </ceil02>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
<!--
    Test Name: xPathFunc_ceil_03
       Schema: XPathFunctions
         Root: ceil03
      Purpose: This test demonstrates the ceiling function
-->

  <tdml:parserTestCase name="xPathFunc_ceil_03" root="ceil03"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - ceiling - DFDL-23-095R">

    <tdml:document>
      <tdml:documentPart type="text">string</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>convert</tdml:error>
      <tdml:error>string</tdml:error>
      <tdml:error>"string"</tdml:error>
      <tdml:error>double</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
<!--
    Test Name: xPathFunc_ceil_04
       Schema: XPathFunctions
         Root: ceil04
      Purpose: This test demonstrates the ceiling function
-->

  <tdml:parserTestCase name="xPathFunc_ceil_04" root="ceil04"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - ceiling - DFDL-23-095R">

    <tdml:document>
      <tdml:documentPart type="text">4.2</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ceil04>
          <val>4.2</val>
          <ceilval>5.0</ceilval>
        </ceil04>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
<!--
    Test Name: xPathFunc_ceil_05
       Schema: XPathFunctions
         Root: ceil04
      Purpose: This test demonstrates the ceiling function
-->

  <tdml:parserTestCase name="xPathFunc_ceil_05" root="ceil04"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - ceiling - DFDL-23-095R">

    <tdml:document>
      <tdml:documentPart type="text">-3.4</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ceil04>
          <val>-3.4</val>
          <ceilval>-3.0</ceilval>
        </ceil04>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: ceil_06
       Schema: XPathFunctions
         Root: ceil05
      Purpose: This test demonstrates the ceiling function, and how it handles an invalid argument
-->

  <tdml:parserTestCase name="ceil_06" root="ceil05"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - ceiling - DFDL-23-095R">

    <tdml:document>
      <tdml:documentPart type="byte">AB123</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Argument must be of numeric type but was HexBinary</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
    Test Name: ceil_07
       Schema: XPathFunctions
         Root: ceil06
-->

  <tdml:parserTestCase name="ceil_07" root="ceil06"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - ceiling - DFDL-23-095R" validation="on">

    <tdml:document>
      <tdml:documentPart type="text">49.2</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:ceil06>
          <val>49.2</val>
          <ceilval>50.0</ceilval>
        </ex:ceil06>
      </tdml:dfdlInfoset>
    </tdml:infoset>
    <tdml:validationErrors>
      <tdml:error>'50.0'</tdml:error>
      <tdml:error>not facet-valid</tdml:error>
      <tdml:error>maxExclusive</tdml:error>
    </tdml:validationErrors>
  </tdml:parserTestCase>

<!--
    Test Name: ceil_08
       Schema: XPathFunctions
         Root: ceil07
      Purpose: This test demonstrates the ceiling function, and how it handles an invalid argument
-->

  <tdml:parserTestCase name="ceil_08" root="ceil07"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - ceiling - DFDL-23-095R">

    <tdml:document>
      <tdml:documentPart type="text">forty-nine point two</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Argument must be of numeric type but was String.</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
    Test Name: ceil_09
       Schema: XPathFunctions
         Root: ceil08
      Purpose: This test demonstrates the ceiling function with xs:decimal
-->

  <tdml:parserTestCase name="ceil_09" root="ceil08"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - ceiling - DFDL-23-095R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ceil08>1</ceil08>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: xPathFunc_floor_01
       Schema: XPathFunctions
         Root: floor
      Purpose: This test demonstrates the floor function
-->

  <tdml:parserTestCase name="xPathFunc_floor_01" root="floor"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - floor - DFDL-23-096R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <floor>4.0</floor>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
<!--
    Test Name: xPathFunc_floor_02
       Schema: XPathFunctions
         Root: floor02
      Purpose: This test demonstrates the floor function
-->

  <tdml:parserTestCase name="xPathFunc_floor_02" root="floor02"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - floor - DFDL-23-096R">

    <tdml:document>
      <tdml:documentPart type="text">6.1</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <floor02>
          <val>6.1</val>
          <floorval>6.0</floorval>
        </floor02>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
<!--
    Test Name: xPathFunc_floor_03
       Schema: XPathFunctions
         Root: floor03
      Purpose: This test demonstrates the floor function
-->

  <tdml:parserTestCase name="xPathFunc_floor_03" root="floor03"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - floor - DFDL-23-096R">

    <tdml:document>
      <tdml:documentPart type="text">string</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>convert</tdml:error>
      <tdml:error>string</tdml:error>
      <tdml:error>"string"</tdml:error>
      <tdml:error>double</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
<!--
    Test Name: xPathFunc_floor_04
       Schema: XPathFunctions
         Root: floor04
      Purpose: This test demonstrates the floor function
-->

  <tdml:parserTestCase name="xPathFunc_floor_04" root="floor04"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - floor - DFDL-23-096R">

    <tdml:document>
      <tdml:documentPart type="text">4.2</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <floor04>
          <val>4.2</val>
          <floorval>4.0</floorval>
        </floor04>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
<!--
    Test Name: xPathFunc_floor_05
       Schema: XPathFunctions
         Root: floor04
      Purpose: This test demonstrates the floor function
-->

  <tdml:parserTestCase name="xPathFunc_floor_05" root="floor04"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - floor - DFDL-23-096R">

    <tdml:document>
      <tdml:documentPart type="text">-3.4</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <floor04>
          <val>-3.4</val>
          <floorval>-4.0</floorval>
        </floor04>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: floor_06
       Schema: XPathFunctions
         Root: floor05
      Purpose: This test demonstrates the floor function
-->

  <tdml:parserTestCase name="floor_06" root="floor05"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - floor - DFDL-23-096R" validation="on">
    <tdml:document>
      <tdml:documentPart type="text">0.8</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <floor05>
          <val>0.8</val>
          <floorval>0.0</floorval>
        </floor05>
      </tdml:dfdlInfoset>
    </tdml:infoset>
    <tdml:validationErrors>
      <tdml:error>'0.0'</tdml:error>
      <tdml:error>not facet-valid</tdml:error>
      <tdml:error>minExclusive</tdml:error>
    </tdml:validationErrors>
  </tdml:parserTestCase>

<!--
    Test Name: floor_07
       Schema: XPathFunctions
         Root: floor06
      Purpose: This test demonstrates the floor function when passed in an invalid value (hexBinary)
-->

  <tdml:parserTestCase name="floor_07" root="floor06"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - floor - DFDL-23-096R">
    <tdml:document>
      <tdml:documentPart type="byte">ABCD</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Error</tdml:error>
      <tdml:error>numeric</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
    Test Name: floor_08
       Schema: XPathFunctions
         Root: floor07
      Purpose: This test demonstrates the floor function when passed binary values
-->

  <tdml:parserTestCase name="floor_08" root="floor07"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - floor - DFDL-23-096R">
    <tdml:document>
      <tdml:documentPart type="byte">42 28 00 00</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <floor07>
          <val>42.0</val>
          <floorval>42.0</floorval>
        </floor07>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
<!--
    Test Name: floor_09
       Schema: XPathFunctions
         Root: floor08
      Purpose: This test demonstrates the floor function with xs:decimal
-->

  <tdml:parserTestCase name="floor_09" root="floor08"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - floor - DFDL-23-095R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <floor08>0</floor08>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: xPathFunc_round_01
       Schema: XPathFunctions
         Root: round
      Purpose: This test demonstrates the round function
-->

  <tdml:parserTestCase name="xPathFunc_round_01" root="round"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - round - DFDL-23-097R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <round>4.0</round>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
<!--
    Test Name: xPathFunc_round_02
       Schema: XPathFunctions
         Root: round02
      Purpose: This test demonstrates the round function
-->

  <tdml:parserTestCase name="xPathFunc_round_02" root="round02"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - round - DFDL-23-097R">

    <tdml:document>
      <tdml:documentPart type="text">6.1</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <round02>
          <val>6.1</val>
          <roundval>6.0</roundval>
        </round02>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
<!--
    Test Name: xPathFunc_round_03
       Schema: XPathFunctions
         Root: round03
      Purpose: This test demonstrates the round function
-->

  <tdml:parserTestCase name="xPathFunc_round_03" root="round03"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - round - DFDL-23-097R">

    <tdml:document>
      <tdml:documentPart type="text">string</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>convert</tdml:error>
      <tdml:error>string</tdml:error>
      <tdml:error>"string"</tdml:error>
      <tdml:error>double</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
<!--
    Test Name: xPathFunc_round_04
       Schema: XPathFunctions
         Root: round04
      Purpose: This test demonstrates the round function
-->

  <tdml:parserTestCase name="xPathFunc_round_04" root="round04"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - round - DFDL-23-097R">

    <tdml:document>
      <tdml:documentPart type="text">4.2</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <round04>
          <val>4.2</val>
          <roundval>4.0</roundval>
        </round04>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
<!--
    Test Name: xPathFunc_round_05
       Schema: XPathFunctions
         Root: round04
      Purpose: This test demonstrates the round function
-->

  <tdml:parserTestCase name="xPathFunc_round_05" root="round04"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - round - DFDL-23-097R">

    <tdml:document>
      <tdml:documentPart type="text">-3.4</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <round04>
          <val>-3.4</val>
          <roundval>-3.0</roundval>
        </round04>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
<!--
    Test Name: xPathFunc_round_06
       Schema: XPathFunctions
         Root: round04
      Purpose: This test demonstrates the round function
-->

  <tdml:parserTestCase name="xPathFunc_round_06" root="round04"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - round - DFDL-23-097R">

    <tdml:document>
      <tdml:documentPart type="text">.5</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <round04>
          <val>.5</val>
          <roundval>1.0</roundval>
        </round04>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: round_07
       Schema: XPathFunctions
         Root: round07
      Purpose: This test demonstrates the round function when applied to NaN
-->

  <tdml:parserTestCase name="round_07" root="round07"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - round - DFDL-23-097R">

    <tdml:document>
      <tdml:documentPart type="text">NaN</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>NaN</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
    Test Name: round_08
       Schema: XPathFunctions
         Root: round05
      Purpose: This test demonstrates the round function when applied to a binary representation of a float
-->

  <tdml:parserTestCase name="round_08" root="round05"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - round - DFDL-23-097R">

    <tdml:document>
      <tdml:documentPart type="byte">42 21 33 33</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <round05>
          <val>40.3</val>
          <roundval>40.0</roundval>
        </round05>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: round_09
       Schema: XPathFunctions
         Root: round05
      Purpose: This test demonstrates the round function when applied to a binary representation of a float
-->

  <tdml:parserTestCase name="round_09" root="round05"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - round - DFDL-23-097R">

    <tdml:document>
      <tdml:documentPart type="byte">42 22 00 00</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <round05>
          <val>40.5</val>
          <roundval>41.0</roundval>
        </round05>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: round_10
       Schema: XPathFunctions
         Root: round06
      Purpose: This test demonstrates the round function when applied to a binary representation of a float
-->

  <tdml:parserTestCase name="round_10" root="round06"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - round - DFDL-23-097R">

    <tdml:document>
      <tdml:documentPart type="byte">4124CCCD 41266666</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <round06>
          <one>10.3</one>
          <two>10.4</two>
          <roundval>21.0</roundval>
        </round06>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: round_11
       Schema: XPathFunctions
         Root: round06
      Purpose: This test demonstrates the round function when applied to a binary representation of a float
-->

  <tdml:parserTestCase name="round_11" root="round06"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - round - DFDL-23-097R">

    <tdml:document>
      <tdml:documentPart type="byte">4124CCCD 4121999A</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <round06>
          <one>10.3</one>
          <two>10.1</two>
          <roundval>20.0</roundval>
        </round06>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: round_12
       Schema: XPathFunctions
         Root: round02
      Purpose: This test demonstrates the round function when applied to infinity
-->

  <tdml:parserTestCase name="round_12" root="round02"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - round - DFDL-23-097R">

    <tdml:document>
      <tdml:documentPart type="text">INF</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <round02>
          <val>INF</val>
          <roundval>INF</roundval>
        </round02>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: round_13
       Schema: XPathFunctions
         Root: round07
      Purpose: This test demonstrates the round function when applied to infinity
-->

  <tdml:parserTestCase name="round_13" root="round07"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - round - DFDL-23-097R">

    <tdml:document>
      <tdml:documentPart type="text">INFINITY</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
    	<tdml:dfdlInfoset>
    		<round07>
    			<val>INF</val>
    			<roundval>INF</roundval>
    		</round07>
    	</tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test Name: xPathFunc_round_14
       Schema: XPathFunctions
         Root: round04
      Purpose: This test demonstrates the round function
-->

  <tdml:parserTestCase name="xPathFunc_round_14" root="round04"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - round - DFDL-23-097R">

    <tdml:document>
      <tdml:documentPart type="text">-0.5</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <round04>
          <val>-0.5</val>
          <roundval>0.0</roundval>
        </round04>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test Name: xPathFunc_round_15
       Schema: XPathFunctions
         Root: round04
      Purpose: This test demonstrates the round function
-->

  <tdml:parserTestCase name="xPathFunc_round_15" root="round04"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - round - DFDL-23-097R">

    <tdml:document>
      <tdml:documentPart type="text">-0.0</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <round04>
          <val>-0.0</val>
          <roundval>0.0</roundval>
        </round04>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test Name: xPathFunc_round_16
       Schema: XPathFunctions
         Root: round07
      Purpose: This test demonstrates the round function when applied to negative infinity
-->

  <tdml:parserTestCase name="xPathFunc_round_16" root="round07"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - round - DFDL-23-097R">

    <tdml:document>
      <tdml:documentPart type="text">-INFINITY</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <round07>
          <val>-INF</val>
          <roundval>-INF</roundval>
        </round07>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: round_17
       Schema: XPathFunctions
         Root: round08
      Purpose: This test demonstrates the round function with xs:decimal
-->

  <tdml:parserTestCase name="round_17" root="round08"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - round - DFDL-23-095R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <round08>0</round08>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: round_18
       Schema: XPathFunctions
         Root: round09
      Purpose: This test demonstrates the round function with xs:decimal
-->

  <tdml:parserTestCase name="round_18" root="round09"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - round - DFDL-23-095R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <round09>1</round09>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: round_19
       Schema: XPathFunctions
         Root: round10
      Purpose: This test demonstrates the round function with xs:decimal produces no side effects
-->

  <tdml:parserTestCase name="round_19" root="round10"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - round - DFDL-23-095R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <round10>
          <val>0.5</val>
          <roundVal>1</roundVal>
        </round10>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: xPathFunc_round_hte_01
       Schema: XPathFunctions
         Root: round-hte
      Purpose: This test demonstrates the round-half-to-even function
-->

  <tdml:parserTestCase name="xPathFunc_round_hte_01" root="round-hte"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - round-half-to-even - DFDL-23-098R">

    <tdml:document>
      <tdml:documentPart type="text">3.45,0</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <round-hte>
          <num>3.45</num>
          <precision>0</precision>
          <roundval>3.0</roundval>
        </round-hte>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
<!--
    Test Name: xPathFunc_round_hte_02
       Schema: XPathFunctions
         Root: round-hte
      Purpose: This test demonstrates the round-half-to-even function. Our data is 3.455 and we're rounding to the hundredths place.
               Since our determining value is a 5, we round the digit in the hundredths place to the even value - 6 in this case. 
-->

  <tdml:parserTestCase name="xPathFunc_round_hte_02" root="round-hte"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - round-half-to-even - DFDL-23-098R"
    roundTrip="twoPass">

    <tdml:document>
      <tdml:documentPart type="text">3.455,2</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <round-hte>
          <num>3.455</num>
          <precision>2</precision>
          <roundval>3.46</roundval>
        </round-hte>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
<!--
    Test Name: xPathFunc_round_hte_03
       Schema: XPathFunctions
         Root: round-hte
      Purpose: This test demonstrates the round-half-to-even function. Our data is 3.00865 and we're rounding to the 4th digit.
               Since our determining value is a 5, we round the 4th digit to the even value - 6 in this case. 
               Note: This input number was selected specifically because it converts between base 2 and base 10 without loss of information
-->

  <tdml:parserTestCase name="xPathFunc_round_hte_03" root="round-hte"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - round-half-to-even - DFDL-23-098R"
    roundTrip="twoPass">

    <tdml:document>
      <tdml:documentPart type="text">3.00865,4</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <round-hte>
          <num>3.00865</num>
          <precision>4</precision>
          <roundval>3.0086</roundval>
        </round-hte>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
<!--
    Test Name: xPathFunc_round_hte_04
       Schema: XPathFunctions
         Root: round-hte
      Purpose: This test demonstrates the round-half-to-even function. Our data is 3.000065 and we're rounding to the 4th digit.
               Since our determining value is a 5, we round the 4th digit to the even value - 6 in this case. 
-->

  <tdml:parserTestCase name="xPathFunc_round_hte_04" root="round-hte"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - round-half-to-even - DFDL-23-098R"
    roundTrip="twoPass">

    <tdml:document>
      <tdml:documentPart type="text">3.00065,4</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <round-hte>
          <num>3.00065</num>
          <precision>4</precision>
          <roundval>3.0006</roundval>
        </round-hte>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
<!--
    Test Name: xPathFunc_round_hte_05
       Schema: XPathFunctions
         Root: round-hte
      Purpose: This test demonstrates the round-half-to-even function. Our data is 3.000065 and we're rounding to the 5th digit.
               Since our determining value is a 5, we round the 5th digit to the even value - 6 in this case. 
-->

  <tdml:parserTestCase name="xPathFunc_round_hte_05" root="round-hte"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - round-half-to-even - DFDL-23-098R"
    roundTrip="twoPass">

    <tdml:document>
      <tdml:documentPart type="text">3.000065,5</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <round-hte>
          <num>3.000065</num>
          <precision>5</precision>
          <roundval>3.00006</roundval>
        </round-hte>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
<!--
    Test Name: xPathFunc_round_hte_06
       Schema: XPathFunctions
         Root: round-hte
      Purpose: This test demonstrates the round-half-to-even function. Our data is 3.0000064 and we're rounding to the 6th digit.
-->

  <tdml:parserTestCase name="xPathFunc_round_hte_06" root="round-hte"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - round-half-to-even - DFDL-23-098R">

    <tdml:document>
      <tdml:documentPart type="text">3.0000064,6</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <round-hte>
          <num>3.0000064</num>
          <precision>6</precision>
          <roundval>3.000006</roundval>
        </round-hte>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
<!--
    Test Name: xPathFunc_round_hte_07
       Schema: XPathFunctions
         Root: round-hte
      Purpose: This test demonstrates the round-half-to-even function. Our data is 3.125 and we're rounding to the 2nd digit.
               Because the fractional part is exactly half, the result is the number whose lease significant digit is even.
               Note: 3.125 was selected specifically because it converts between base 2 and base 10 without loss of information
  -->

  <tdml:parserTestCase name="xPathFunc_round_hte_07" root="round-hte"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - round-half-to-even - DFDL-23-098R">

    <tdml:document>
      <tdml:documentPart type="text">3.125,2</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <round-hte>
          <num>3.125</num>
          <precision>2</precision>
          <roundval>3.12</roundval>
        </round-hte>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
<!--
    Test Name: xPathFunc_round_hte_08
       Schema: XPathFunctions
         Root: round-hte
      Purpose: This test demonstrates the round-half-to-even function. Our data is 3.000035 and we're rounding to the 5th digit.
               Because the fractional part is exactly half, the result is the number whose lease significant digit is even.
               Note: This input number was selected specifically because it converts between base 2 and base 10 without loss of information
-->

  <tdml:parserTestCase name="xPathFunc_round_hte_08" root="round-hte"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - round-half-to-even - DFDL-23-098R">

    <tdml:document>
      <tdml:documentPart type="text">3.000035,5</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <round-hte>
          <num>3.000035</num>
          <precision>5</precision>
          <roundval>3.00004</roundval>
        </round-hte>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: round_hte_09
       Schema: XPathFunctions
         Root: round-hte-2
      Purpose: This test demonstrates the round-half-to-even function when passing in NaN
-->

  <tdml:parserTestCase name="round_hte_09" root="round-hte-2"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - round-half-to-even - DFDL-23-098R">

    <tdml:document>
      <tdml:documentPart type="text">NaN,1</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
    	<tdml:dfdlInfoset>
    		<round-hte-2>
    			<num>NaN</num>
    			<precision>1</precision>
    			<roundval>NaN</roundval>
    		</round-hte-2>
    	</tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: round_hte_10
       Schema: XPathFunctions
         Root: round-hte-2
      Purpose: This test demonstrates the round-half-to-even function when passing in INF
-->

  <tdml:parserTestCase name="round_hte_10" root="round-hte-2"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - round-half-to-even - DFDL-23-098R">

    <tdml:document>
      <tdml:documentPart type="text">INF,1</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
    	<tdml:dfdlInfoset>
    		<round-hte-2>
    			<num>INF</num>
    			<precision>1</precision>
    			<roundval>INF</roundval>
    		</round-hte-2>
    	</tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: round_hte_11
       Schema: XPathFunctions
         Root: round-hte-3
      Purpose: This test demonstrates the round-half-to-even function when passing in data that was originally binary
-->

  <tdml:parserTestCase name="round_hte_11" root="round-hte-3"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - round-half-to-even - DFDL-23-098R">

    <tdml:document>
      <tdml:documentPart type="byte">40480000 0002</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <round-hte-3>
          <num>3.125</num>
          <precision>2</precision>
          <roundval>3.12</roundval>
        </round-hte-3>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: round_hte_12
       Schema: XPathFunctions
         Root: round-hte-4
      Purpose: This test demonstrates the round-half-to-even function when passing in invalid data
-->

  <tdml:parserTestCase name="round_hte_12" root="round-hte-4"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - round-half-to-even - DFDL-23-098R">

    <tdml:document>
      <tdml:documentPart type="text">three point two,5</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>First argument must be of numeric type but was String</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
    Test Name: round_hte_13
       Schema: XPathFunctions
         Root: round-hte-5
      Purpose: This test demonstrates the round-half-to-even function when a precision is not provided
-->

  <tdml:parserTestCase name="round_hte_13" root="round-hte-5"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - round-half-to-even - DFDL-23-098R">

    <tdml:document>
      <tdml:documentPart type="text">3.5</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <round-hte-5>
          <num>3.5</num>
          <roundval>4.0</roundval>
        </round-hte-5>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: round_hte_14
       Schema: XPathFunctions
         Root: round-hte-5
      Purpose: This test demonstrates the round-half-to-even function when a precision is not provided
-->

  <tdml:parserTestCase name="round_hte_14" root="round-hte-5"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - round-half-to-even - DFDL-23-098R">

    <tdml:document>
      <tdml:documentPart type="text">3.45</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <round-hte-5>
          <num>3.45</num>
          <roundval>3.0</roundval>
        </round-hte-5>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: round_hte_15
       Schema: XPathFunctions
         Root: round-hte-6
      Purpose: This test demonstrates the round-half-to-even function when the original input
               was binary, and the fractional part is half
-->

  <tdml:parserTestCase name="round_hte_15" root="round-hte-6"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - round-half-to-even - DFDL-23-098R">

    <tdml:document>
      <tdml:documentPart type="byte">40900000</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <round-hte-6>
          <num>4.5</num>
          <roundval>4.0</roundval>
        </round-hte-6>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: round_hte_16
       Schema: XPathFunctions
         Root: round-hte-6
      Purpose: This test demonstrates the round-half-to-even function when the original input
               was binary, and the fractional part is half
-->

  <tdml:parserTestCase name="round_hte_16" root="round-hte-6"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - round-half-to-even - DFDL-23-098R">

    <tdml:document>
      <tdml:documentPart type="byte">40B00000</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <round-hte-6>
          <num>5.5</num>
          <roundval>6.0</roundval>
        </round-hte-6>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: round_hte_17
       Schema: XPathFunctions
         Root: round-hte
      Purpose: This test demonstrates the round-half-to-even function, converted to an xs:int
-->

  <tdml:parserTestCase name="round_hte_17" root="round-hte-7"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - round-half-to-even - DFDL-23-098R">

    <tdml:document>
      <tdml:documentPart type="text">3.45,0</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <round-hte-7>
          <num>3.45</num>
          <precision>0</precision>
          <roundval>3</roundval>
        </round-hte-7>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: round_hte_18
       Schema: XPathFunctions
         Root: round-hte-8
      Purpose: This test demonstrates the round-half-to-even function, converted to an xs:int
-->

  <tdml:parserTestCase name="round_hte_18" root="round-hte-8"
    model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - round-half-to-even - DFDL-23-098R">

    <tdml:document>
      <tdml:documentPart type="text">3.5</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <round-hte-8>
          <num>3.5</num>
          <roundval>4</roundval>
        </round-hte-8>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  
  <tdml:defineSchema name="constructorSchema">
    <xs:include schemaLocation="org/apache/daffodil/xsd/DFDLGeneralFormat.dfdl.xsd"/>
    <dfdl:format ref="ex:GeneralFormat" />

    <xs:element name="integer01" type="xs:integer" dfdl:inputValueCalc="{ xs:integer(45.4) }"/>
    <xs:element name="integer02">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="string" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="intified" type="xs:integer" dfdl:inputValueCalc="{ xs:integer(../ex:string) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    <xs:element name="integer03">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="float" type="xs:float" dfdl:lengthKind="delimited"/>
          <xs:element name="intified" type="xs:integer" dfdl:inputValueCalc="{ xs:integer(../ex:float) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    <xs:element name="integer04" type="xs:integer" dfdl:inputValueCalc="{ xs:integer(xs:float(45.4)) }"/>
    
    <xs:element name="dateTime01">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="date" type="xs:date" dfdl:lengthKind="delimited" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="MM-dd-yyyy"/>
          <xs:element name="time" type="xs:time" dfdl:lengthKind="delimited" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="hh:mm:ss"/>
          <xs:element name="dateTime" type="xs:dateTime" dfdl:inputValueCalc="{ fn:dateTime(../ex:date, ../ex:time) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    <xs:element name="dateTime02">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="date" type="xs:date" dfdl:lengthKind="delimited" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="MMMM-dd-yy"/>
          <xs:element name="time" type="xs:time" dfdl:lengthKind="delimited" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="hh:mm:ssZ"/>
          <xs:element name="dateTime" type="xs:dateTime" dfdl:inputValueCalc="{ fn:dateTime(fn:adjust-date-to-timezone(../ex:date, fn:timezone-from-time(../ex:time)), ../ex:time) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    <xs:element name="dateTime03">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="date" type="xs:date" dfdl:lengthKind="delimited" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="MMMM-dd-yyZ"/>
          <xs:element name="time" type="xs:time" dfdl:lengthKind="delimited" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="hh:mm:ssZ"/>
          <xs:element name="dateTime" type="xs:dateTime" dfdl:inputValueCalc="{ fn:dateTime(../ex:date, ../ex:time) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    <xs:element name="dateTime04">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="dateTime" type="xs:dateTime" dfdl:inputValueCalc="{ xs:dateTime(../ex:string) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    <xs:element name="dateTime05">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="dateTime" type="xs:string" dfdl:inputValueCalc="{ xs:string(xs:dateTime(../ex:string)) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    <xs:element name="dateTime06" type="xs:dateTime" dfdl:inputValueCalc="{ xs:dateTime(xs:time('04:55:30')) }"/> <!-- invalid cast -->
    <xs:element name="dateTime07" type="xs:dateTime" dfdl:inputValueCalc="{ xs:dateTime(xs:date('2014-10-23')) }"/> <!-- valid cast -->
    <xs:element name="dateTime08" type="xs:dateTime" dfdl:inputValueCalc="{ xs:dateTime(xs:dateTime('2014-10-23T04:55:30')) }"/> <!-- valid cast -->
    <xs:element name="dateTime09" type="xs:dateTime" dfdl:inputValueCalc="{ xs:dateTime(1) }"/> <!-- invalid cast -->
    <xs:element name="dateTime10"><!-- No Time Zone -->
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="date" type="xs:date" dfdl:lengthKind="delimited" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="MM-dd-yyyy" dfdl:calendarTimeZone=""/>
          <xs:element name="time" type="xs:time" dfdl:lengthKind="delimited" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="hh:mm:ss" dfdl:calendarTimeZone=""/>
          <xs:element name="dateTime" type="xs:dateTime" dfdl:inputValueCalc="{ fn:dateTime(../ex:date, ../ex:time) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    <xs:element name="dateTime11"><!-- EST Time Zone -->
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="date" type="xs:date" dfdl:lengthKind="delimited" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="MM-dd-yyyy" dfdl:calendarTimeZone="UTC-05:00"/>
          <xs:element name="time" type="xs:time" dfdl:lengthKind="delimited" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="hh:mm:ss" dfdl:calendarTimeZone="UTC-05:00"/>
          <xs:element name="dateTime" type="xs:dateTime" dfdl:inputValueCalc="{ fn:dateTime(../ex:date, ../ex:time) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    <xs:element name="dateTime12">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="date" type="xs:date" dfdl:lengthKind="delimited" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="MM-dd-yyyy" dfdl:calendarTimeZone="UTC-09:00"/>
          <xs:element name="time" type="xs:time" dfdl:lengthKind="delimited" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="hh:mm:ss" dfdl:calendarTimeZone="UTC-09:00"/>
          <xs:element name="dateTime" type="xs:dateTime" dfdl:inputValueCalc="{ fn:dateTime(../ex:date, ../ex:time) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    <xs:element name="dateTime13">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="date" type="xs:date" dfdl:lengthKind="delimited" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="MM-dd-yyyy" dfdl:calendarTimeZone="UTC+11:00"/>
          <xs:element name="time" type="xs:time" dfdl:lengthKind="delimited" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="hh:mm:ss" dfdl:calendarTimeZone="UTC+11:00"/>
          <xs:element name="dateTime" type="xs:dateTime" dfdl:inputValueCalc="{ fn:dateTime(../ex:date, ../ex:time) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    <xs:element name="dateTime14">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="date" type="xs:date" dfdl:lengthKind="delimited" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="MM-dd-yyyy" dfdl:calendarTimeZone="UTC-09:00"/>
          <xs:element name="time" type="xs:time" dfdl:lengthKind="delimited" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="hh:mm:ss" dfdl:calendarTimeZone="UTC+11:00"/>
          <xs:element name="dateTime" type="xs:dateTime" dfdl:inputValueCalc="{ fn:dateTime(../ex:date, ../ex:time) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="time01">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="time" type="xs:time" dfdl:inputValueCalc="{ xs:time(../ex:string) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="time02">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="time" type="xs:string" dfdl:inputValueCalc="{ xs:string(xs:time(../ex:string)) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    <xs:element name="time03" type="xs:time" dfdl:inputValueCalc="{ xs:time(xs:date('2014-10-23')) }"/> <!-- invalid cast -->
    <xs:element name="time04" type="xs:time" dfdl:inputValueCalc="{ xs:time(xs:time('08:00:00')) }"/> <!-- valid cast -->
    <xs:element name="time05" type="xs:time" dfdl:inputValueCalc="{ xs:time(xs:dateTime('2014-10-23T08:00:00')) }"/> <!-- valid cast -->
    
    <xs:element name="time06" type="xs:time" dfdl:lengthKind="delimited" dfdl:calendarPatternKind="explicit"
      dfdl:calendarPattern="hh:mm:ss" dfdl:calendarTimeZone="UTC-05:00" />
 
    <xs:element name="date01">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="date" type="xs:date" dfdl:inputValueCalc="{ xs:date(../ex:string) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="date02">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="date" type="xs:string" dfdl:inputValueCalc="{ xs:string(xs:date(../ex:string)) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="date03" type="xs:date" dfdl:inputValueCalc="{ xs:date(xs:time('08:00:00')) }"/> <!-- invalid cast -->
    <xs:element name="date04" type="xs:date" dfdl:inputValueCalc="{ xs:date(xs:date('2014-10-23')) }"/> <!-- valid cast -->
    <xs:element name="date05" type="xs:date" dfdl:inputValueCalc="{ xs:date(xs:dateTime('2014-10-23T08:00:00-05:00')) }"/> <!-- valid cast -->
    
    <xs:element name="hexBinary01">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="hexBinary" type="xs:hexBinary" dfdl:inputValueCalc="{ xs:hexBinary(../ex:string) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="dfdlHexBinary01" type="xs:hexBinary" dfdl:inputValueCalc="{ dfdl:hexBinary(xs:short(208)) }"/>
    <xs:element name="dfdlHexBinary02" type="xs:hexBinary" dfdl:inputValueCalc="{ dfdl:hexBinary('208') }"/>
    <xs:element name="dfdlHexBinary03" type="xs:hexBinary" dfdl:inputValueCalc="{ dfdl:hexBinary(-2084) }"/>
    <xs:element name="dfdlHexBinary04" type="xs:hexBinary" dfdl:inputValueCalc="{ dfdl:hexBinary(200000000000000000000) }"/>
    <xs:element name="dfdlHexBinary05" type="xs:hexBinary" dfdl:inputValueCalc="{ dfdl:hexBinary(xs:integer(32768)) }"/>
    
    <xs:element name="dfdlByte01" type="xs:byte" dfdl:inputValueCalc="{ dfdl:byte(127) }"/> <!-- valid -->
    <xs:element name="dfdlByte02" type="xs:byte" dfdl:inputValueCalc="{ dfdl:byte(208) }"/> <!-- invalid -->
    <xs:element name="dfdlByte03" type="xs:byte" dfdl:inputValueCalc="{ dfdl:byte('127') }"/> <!-- valid -->
    <xs:element name="dfdlByte04" type="xs:byte" dfdl:inputValueCalc="{ dfdl:byte('208') }"/> <!-- invalid -->
    <xs:element name="dfdlByte05" type="xs:byte" dfdl:inputValueCalc="{ dfdl:byte('x7F') }"/> <!-- valid -->
    <xs:element name="dfdlByte06" type="xs:byte" dfdl:inputValueCalc="{ dfdl:byte('xD0') }"/> <!-- invalid -->
    <xs:element name="dfdlByte07" type="xs:byte" dfdl:inputValueCalc="{ dfdl:byte('xDG') }"/> <!-- invalid -->
    <xs:element name="dfdlByte08" type="xs:byte" dfdl:inputValueCalc="{ dfdl:byte(xs:short(127)) }"/> <!-- valid -->
    <xs:element name="dfdlByte09" type="xs:byte" dfdl:inputValueCalc="{ dfdl:byte(xs:short(208)) }"/> <!-- invalid -->
    <xs:element name="dfdlByte10" type="xs:byte" dfdl:inputValueCalc="{ dfdl:byte(dfdl:hexBinary(127)) }"/> <!-- invalid -->
    
    <xs:element name="dfdlUByte01" type="xs:unsignedByte" dfdl:inputValueCalc="{ dfdl:unsignedByte(208) }"/> <!-- valid -->
    <xs:element name="dfdlUByte02" type="xs:unsignedByte" dfdl:inputValueCalc="{ dfdl:unsignedByte(256) }"/> <!-- invalid -->
    <xs:element name="dfdlUByte03" type="xs:unsignedByte" dfdl:inputValueCalc="{ dfdl:unsignedByte('208') }"/> <!-- valid -->
    <xs:element name="dfdlUByte04" type="xs:unsignedByte" dfdl:inputValueCalc="{ dfdl:unsignedByte('256') }"/> <!-- invalid -->
    <xs:element name="dfdlUByte05" type="xs:unsignedByte" dfdl:inputValueCalc="{ dfdl:unsignedByte('xD0') }"/> <!-- valid -->
    <xs:element name="dfdlUByte06" type="xs:unsignedByte" dfdl:inputValueCalc="{ dfdl:unsignedByte('x100') }"/> <!-- invalid -->
    <xs:element name="dfdlUByte07" type="xs:unsignedByte" dfdl:inputValueCalc="{ dfdl:unsignedByte(xs:short(208)) }"/> <!-- valid -->
    <xs:element name="dfdlUByte08" type="xs:unsignedByte" dfdl:inputValueCalc="{ dfdl:unsignedByte(xs:short(256)) }"/> <!-- invalid -->
    <xs:element name="dfdlUByte09" type="xs:unsignedByte" dfdl:inputValueCalc="{ dfdl:unsignedByte(dfdl:hexBinary(208)) }"/> <!-- valid -->
    <xs:element name="dfdlUByte11" type="xs:unsignedByte" dfdl:inputValueCalc="{ dfdl:unsignedByte('xDG') }"/> <!-- invalid -->
    
    <xs:element name="dfdlShort01" type="xs:short" dfdl:inputValueCalc="{ dfdl:short(32767) }"/> <!-- valid -->
    <xs:element name="dfdlShort02" type="xs:short" dfdl:inputValueCalc="{ dfdl:short(32768) }"/> <!-- invalid -->
    <xs:element name="dfdlShort03" type="xs:short" dfdl:inputValueCalc="{ dfdl:short('32767') }"/> <!-- valid -->
    <xs:element name="dfdlShort04" type="xs:short" dfdl:inputValueCalc="{ dfdl:short('32768') }"/> <!-- invalid -->
    <xs:element name="dfdlShort05" type="xs:short" dfdl:inputValueCalc="{ dfdl:short('x7FFF') }"/> <!-- valid -->
    <xs:element name="dfdlShort06" type="xs:short" dfdl:inputValueCalc="{ dfdl:short('x8000') }"/> <!-- invalid -->
    <xs:element name="dfdlShort07" type="xs:short" dfdl:inputValueCalc="{ dfdl:short(xs:long(32767)) }"/> <!-- valid -->
    <xs:element name="dfdlShort08" type="xs:short" dfdl:inputValueCalc="{ dfdl:short(xs:long(32768)) }"/> <!-- invalid -->
    <xs:element name="dfdlShort09" type="xs:short" dfdl:inputValueCalc="{ dfdl:short(dfdl:hexBinary(32767)) }"/> <!-- valid -->
    <xs:element name="dfdlShort11" type="xs:short" dfdl:inputValueCalc="{ dfdl:short('x7FFG') }"/> <!-- invalid -->
    
    <xs:element name="dfdlUShort01" type="xs:unsignedShort" dfdl:inputValueCalc="{ dfdl:unsignedShort(65535) }"/> <!-- valid -->
    <xs:element name="dfdlUShort02" type="xs:unsignedShort" dfdl:inputValueCalc="{ dfdl:unsignedShort(65536) }"/> <!-- invalid -->
    <xs:element name="dfdlUShort03" type="xs:unsignedShort" dfdl:inputValueCalc="{ dfdl:unsignedShort('65535') }"/> <!-- valid -->
    <xs:element name="dfdlUShort04" type="xs:unsignedShort" dfdl:inputValueCalc="{ dfdl:unsignedShort('65536') }"/> <!-- invalid -->
    <xs:element name="dfdlUShort05" type="xs:unsignedShort" dfdl:inputValueCalc="{ dfdl:unsignedShort('xFFFF') }"/> <!-- valid -->
    <xs:element name="dfdlUShort06" type="xs:unsignedShort" dfdl:inputValueCalc="{ dfdl:unsignedShort('x10000') }"/> <!-- invalid -->
    <xs:element name="dfdlUShort07" type="xs:unsignedShort" dfdl:inputValueCalc="{ dfdl:unsignedShort(xs:long(65535)) }"/> <!-- valid -->
    <xs:element name="dfdlUShort08" type="xs:unsignedShort" dfdl:inputValueCalc="{ dfdl:unsignedShort(xs:long(65536)) }"/> <!-- invalid -->
    <xs:element name="dfdlUShort09" type="xs:unsignedShort" dfdl:inputValueCalc="{ dfdl:unsignedShort(dfdl:hexBinary(65535)) }"/> <!-- valid -->
    <xs:element name="dfdlUShort11" type="xs:unsignedShort" dfdl:inputValueCalc="{ dfdl:unsignedShort('xFFFG') }"/> <!-- invalid -->
    
    <xs:element name="dfdlInt01" type="xs:integer" dfdl:inputValueCalc="{ dfdl:int(2147483647) }"/> <!-- valid -->
    <xs:element name="dfdlInt02" type="xs:integer" dfdl:inputValueCalc="{ dfdl:int(2147483648) }"/> <!-- invalid -->
    <xs:element name="dfdlInt03" type="xs:integer" dfdl:inputValueCalc="{ dfdl:int('2147483647') }"/> <!-- valid -->
    <xs:element name="dfdlInt04" type="xs:integer" dfdl:inputValueCalc="{ dfdl:int('2147483648') }"/> <!-- invalid -->
    <xs:element name="dfdlInt05" type="xs:integer" dfdl:inputValueCalc="{ dfdl:int('x7FFFFFFF') }"/> <!-- valid -->
    <xs:element name="dfdlInt06" type="xs:integer" dfdl:inputValueCalc="{ dfdl:int('x80000000') }"/> <!-- invalid -->
    <xs:element name="dfdlInt07" type="xs:integer" dfdl:inputValueCalc="{ dfdl:int(xs:long(2147483647)) }"/> <!-- valid -->
    <xs:element name="dfdlInt08" type="xs:integer" dfdl:inputValueCalc="{ dfdl:int(xs:long(2147483648)) }"/> <!-- invalid -->
    <xs:element name="dfdlInt09" type="xs:integer" dfdl:inputValueCalc="{ dfdl:int(dfdl:hexBinary(2147483647)) }"/> <!-- valid -->
    <xs:element name="dfdlInt11" type="xs:integer" dfdl:inputValueCalc="{ dfdl:int('x7FFFFFFG') }"/> <!-- invalid -->
    <xs:element name="dfdlInt12" type="xs:integer" dfdl:inputValueCalc="{ dfdl:int(-2147483648) }"/> <!-- valid -->
    <xs:element name="dfdlInt13" type="xs:integer" dfdl:inputValueCalc="{ dfdl:int(dfdl:hexBinary(dfdl:int(127))) }"/> <!-- invalid -->
    <xs:element name="dfdlInt14" type="xs:integer" dfdl:inputValueCalc="{ dfdl:int(fn:concat('x', xs:string(dfdl:hexBinary(dfdl:int(125))))) }"/> <!-- valid -->
    
    <xs:element name="dfdlUInt01" type="xs:unsignedInt" dfdl:inputValueCalc="{ dfdl:unsignedInt(4294967295) }"/> <!-- valid -->
    <xs:element name="dfdlUInt02" type="xs:unsignedInt" dfdl:inputValueCalc="{ dfdl:unsignedInt(4294967296) }"/> <!-- invalid -->
    <xs:element name="dfdlUInt03" type="xs:unsignedInt" dfdl:inputValueCalc="{ dfdl:unsignedInt('4294967295') }"/> <!-- valid -->
    <xs:element name="dfdlUInt04" type="xs:unsignedInt" dfdl:inputValueCalc="{ dfdl:unsignedInt('4294967296') }"/> <!-- invalid -->
    <xs:element name="dfdlUInt05" type="xs:unsignedInt" dfdl:inputValueCalc="{ dfdl:unsignedInt('xFFFFFFFF') }"/> <!-- valid -->
    <xs:element name="dfdlUInt06" type="xs:unsignedInt" dfdl:inputValueCalc="{ dfdl:unsignedInt('x100000000') }"/> <!-- invalid -->
    <xs:element name="dfdlUInt07" type="xs:unsignedInt" dfdl:inputValueCalc="{ dfdl:unsignedInt(xs:long(4294967295)) }"/> <!-- valid -->
    <xs:element name="dfdlUInt08" type="xs:unsignedInt" dfdl:inputValueCalc="{ dfdl:unsignedInt(xs:long(4294967296)) }"/> <!-- invalid -->
    <xs:element name="dfdlUInt09" type="xs:unsignedInt" dfdl:inputValueCalc="{ dfdl:unsignedInt(dfdl:hexBinary(4294967295)) }"/> <!-- valid -->
    <xs:element name="dfdlUInt11" type="xs:unsignedInt" dfdl:inputValueCalc="{ dfdl:unsignedInt('xFFFFFFFG') }"/> <!-- invalid -->
    <xs:element name="dfdlUInt12" type="xs:unsignedInt" dfdl:inputValueCalc="{ dfdl:unsignedInt(-1) }"/> <!-- invalid -->
    
    <xs:element name="dfdlLong01" type="xs:long" dfdl:inputValueCalc="{ dfdl:long(9223372036854775807) }"/> <!-- valid -->
    <xs:element name="dfdlLong02" type="xs:long" dfdl:inputValueCalc="{ dfdl:long(9223372036854775808) }"/> <!-- invalid -->
    <xs:element name="dfdlLong03" type="xs:long" dfdl:inputValueCalc="{ dfdl:long('9223372036854775807') }"/> <!-- valid -->
    <xs:element name="dfdlLong04" type="xs:long" dfdl:inputValueCalc="{ dfdl:long('9223372036854775808') }"/> <!-- invalid -->
    <xs:element name="dfdlLong05" type="xs:long" dfdl:inputValueCalc="{ dfdl:long('x7FFFFFFFFFFFFFFF') }"/> <!-- valid -->
    <xs:element name="dfdlLong06" type="xs:long" dfdl:inputValueCalc="{ dfdl:long('x8000000000000000') }"/> <!-- invalid -->
    <xs:element name="dfdlLong07" type="xs:long" dfdl:inputValueCalc="{ dfdl:long(xs:integer(9223372036854775807)) }"/> <!-- valid -->
    <xs:element name="dfdlLong08" type="xs:long" dfdl:inputValueCalc="{ dfdl:long(xs:integer(9223372036854775808)) }"/> <!-- invalid -->
    <xs:element name="dfdlLong09" type="xs:long" dfdl:inputValueCalc="{ dfdl:long(dfdl:hexBinary(9223372036854775807)) }"/> <!-- valid -->
    <xs:element name="dfdlLong11" type="xs:long" dfdl:inputValueCalc="{ dfdl:long('x7FFFFFFFFFFFFFFG') }"/> <!-- invalid -->
    <xs:element name="dfdlLong12" type="xs:long" dfdl:inputValueCalc="{ dfdl:long(-9223372036854775808) }"/> <!-- valid -->
    
    <xs:element name="dfdlULong01" type="xs:unsignedLong" dfdl:inputValueCalc="{ dfdl:unsignedLong(18446744073709551615) }"/> <!-- valid -->
    <xs:element name="dfdlULong02" type="xs:unsignedLong" dfdl:inputValueCalc="{ dfdl:unsignedLong(18446744073709551616) }"/> <!-- invalid -->
    <xs:element name="dfdlULong03" type="xs:unsignedLong" dfdl:inputValueCalc="{ dfdl:unsignedLong('18446744073709551615') }"/> <!-- valid -->
    <xs:element name="dfdlULong04" type="xs:unsignedLong" dfdl:inputValueCalc="{ dfdl:unsignedLong('18446744073709551616') }"/> <!-- invalid -->
    <xs:element name="dfdlULong05" type="xs:unsignedLong" dfdl:inputValueCalc="{ dfdl:unsignedLong('xFFFFFFFFFFFFFFFF') }"/> <!-- valid -->
    <xs:element name="dfdlULong06" type="xs:unsignedLong" dfdl:inputValueCalc="{ dfdl:unsignedLong('x10000000000000000') }"/> <!-- invalid -->
    <xs:element name="dfdlULong07" type="xs:unsignedLong" dfdl:inputValueCalc="{ dfdl:unsignedLong(xs:integer(18446744073709551615)) }"/> <!-- valid -->
    <xs:element name="dfdlULong08" type="xs:unsignedLong" dfdl:inputValueCalc="{ dfdl:unsignedLong(xs:integer(18446744073709551616)) }"/> <!-- invalid -->
    <xs:element name="dfdlULong09" type="xs:unsignedLong" dfdl:inputValueCalc="{ dfdl:unsignedLong(dfdl:hexBinary(9223372036854775807)) }"/> <!-- valid -->
    <xs:element name="dfdlULong11" type="xs:unsignedLong" dfdl:inputValueCalc="{ dfdl:unsignedLong('xFFFFFFFFFFFFFFFG') }"/> <!-- invalid -->
    <xs:element name="dfdlULong12" type="xs:unsignedLong" dfdl:inputValueCalc="{ dfdl:unsignedLong(-1) }"/> <!-- invalid -->
    
    <xs:element name="byte01">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="byte" type="xs:byte" dfdl:inputValueCalc="{ xs:byte(../ex:string) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="int01" type="xs:int" dfdl:inputValueCalc="{ xs:int(45.2) }"/>
    <xs:element name="int02" type="xs:int" dfdl:inputValueCalc="{ xs:int(60) }"/>
    <xs:element name="int03">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="string" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="intified" type="xs:int" dfdl:inputValueCalc="{ xs:int(../ex:string) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    <xs:element name="int04" type="xs:int" dfdl:inputValueCalc="{ xs:int(-60) }"/>
    
    <xs:element name="long01" type="xs:long" dfdl:inputValueCalc="{ xs:long(-50) }"/>
    <xs:element name="long02" type="xs:long" dfdl:inputValueCalc="{ xs:long(12345678987654321) }"/>
    <xs:element name="long03">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="string" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="longified" type="xs:long" dfdl:inputValueCalc="{ xs:long(../ex:string) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="ulong01" type="xs:unsignedLong" dfdl:inputValueCalc="{ xs:unsignedLong(-50) }"/>
    <xs:element name="ulong02" type="xs:unsignedLong" dfdl:inputValueCalc="{ xs:unsignedLong(12345678987654321) }"/>
    <xs:element name="ulong03">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="string" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="ulongified" type="xs:unsignedLong" dfdl:inputValueCalc="{ xs:unsignedLong(../ex:string) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="ushort01" type="xs:unsignedShort" dfdl:inputValueCalc="{ xs:unsignedShort(-50) }"/>
    <xs:element name="ushort02" type="xs:unsignedShort" dfdl:inputValueCalc="{ xs:unsignedShort(12345678987654321) }"/>
    <xs:element name="ushort03">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="string" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="ushortified" type="xs:unsignedShort" dfdl:inputValueCalc="{ xs:unsignedShort(../ex:string) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="short01" type="xs:short" dfdl:inputValueCalc="{ xs:short(-50) }"/>
    <xs:element name="short02" type="xs:short" dfdl:inputValueCalc="{ xs:short(12345678987654321) }"/>
    <xs:element name="short03">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="string" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="shortified" type="xs:short" dfdl:inputValueCalc="{ xs:short(../ex:string) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    <xs:element name="short04">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="string" type="xs:string" dfdl:representation="binary" dfdl:lengthKind="delimited"/>
          <xs:element name="shortified" type="xs:short" dfdl:inputValueCalc="{ xs:short(../ex:string) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="decimal01" type="xs:decimal" dfdl:inputValueCalc="{ xs:decimal(45.2) }"/>
    <xs:element name="decimal02" type="xs:decimal" dfdl:inputValueCalc="{ xs:decimal(60) }"/>
    <xs:element name="decimal03">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="string" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="decified" type="xs:decimal" dfdl:inputValueCalc="{ xs:decimal(../ex:string) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    <xs:element name="decimal04" type="xs:decimal" dfdl:inputValueCalc="{ xs:decimal(-60) }"/>
    
    <xs:element name="float01">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="string" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="floatified" type="xs:float" dfdl:inputValueCalc="{ xs:float(../ex:string) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    <xs:element name="float02">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="string2" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="floatified" type="xs:float" dfdl:inputValueCalc="{ xs:float(../ex:string) + xs:float(../ex:string2) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="double01">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="string" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="doublified" type="xs:double" dfdl:inputValueCalc="{ xs:double(../ex:string) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    <xs:element name="double02">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="string2" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="doublified" type="xs:double" dfdl:inputValueCalc="{ xs:double(../ex:string) + xs:double(../ex:string2) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="nonNeg01">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="string2" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="nonNeg" type="xs:integer" dfdl:inputValueCalc="{ xs:nonNegativeInteger(xs:string(xs:int(../ex:string) + xs:int(../ex:string2))) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="nonNeg02">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="nonNeg" type="xs:integer" dfdl:inputValueCalc="{ xs:nonNegativeInteger(../ex:string) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="uint01">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="string" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="uintified" type="xs:unsignedLong" dfdl:inputValueCalc="{ xs:unsignedInt(../ex:string) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="ubyte01">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string" type="xs:string" dfdl:lengthKind="delimited"/>
          <!-- Note that I keep this type as unsigned long on purpose - it shows that the constructor is responsible for the conversion to unsignedByte, not the type specification -->
          <xs:element name="ubyte" type="xs:unsignedLong" dfdl:inputValueCalc="{ xs:unsignedByte(../ex:string) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

  </tdml:defineSchema>
  
  <!--
    Test name: integer_constructor_01
       Schema: constructorSchema
         Root: integer01
      Purpose: This tests demonstrates the use of the xs:integer constructor function and its ability to
               convert a fractional number to an integer
  -->

  <tdml:parserTestCase name="integer_constructor_01" root="integer01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:integer()  - DFDL-23-078R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <integer01>45</integer01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: integer_constructor_02
       Schema: constructorSchema
         Root: integer02
      Purpose: This tests demonstrates the use of the xs:integer constructor function to convert a string representation
               of an integer to an integer type
  -->

  <tdml:parserTestCase name="integer_constructor_02" root="integer02" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:integer()  - DFDL-23-078R">

    <tdml:document>
      <tdml:documentPart type="text">184</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <integer02>
          <string>184</string>
          <intified>184</intified>
        </integer02>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: integer_constructor_03
       Schema: constructorSchema
         Root: integer02
      Purpose: This tests demonstrates the use of the xs:integer constructor function to convert a string representation
               of an integer to an integer type. In this case the string cannot be converted to an integer and an error should occur.
  -->

  <tdml:parserTestCase name="integer_constructor_03" root="integer02" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:integer()  - DFDL-23-078R">

    <tdml:document>
      <tdml:documentPart type="text">forty-eight</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>Cannot convert</tdml:error>
      <tdml:error>forty-eight</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: integer_constructor_04
       Schema: constructorSchema
         Root: integer02
      Purpose: This tests demonstrates the use of the xs:integer constructor function to convert a string representation
               of an integer to an integer type
  -->

  <tdml:parserTestCase name="integer_constructor_04" root="integer02" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:integer()  - DFDL-23-078R">

    <tdml:document>
      <tdml:documentPart type="text">-184</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <integer02>
          <string>-184</string>
          <intified>-184</intified>
        </integer02>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: integer_constructor_05
       Schema: constructorSchema
         Root: integer02
      Purpose: This tests demonstrates the use of the xs:integer constructor function to convert a string representation
               of a fractional number to an integer type
  -->

  <tdml:parserTestCase name="integer_constructor_05" root="integer02" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:integer()  - DFDL-23-078R">

    <tdml:document>
      <tdml:documentPart type="text">-184.7</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <integer02>
          <string>-184.7</string>
          <intified>-184</intified>
        </integer02>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: integer_constructor_06
       Schema: constructorSchema
         Root: integer03
      Purpose: This tests demonstrates the use of the xs:integer constructor function to convert a string representation
               of a fractional number to an integer type
  -->

  <tdml:parserTestCase name="integer_constructor_06" root="integer03" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:integer()  - DFDL-23-078R">

    <tdml:document>
      <tdml:documentPart type="text">45.4</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <integer03>
          <float>45.4</float>
          <intified>45</intified>
        </integer03>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: integer_constructor_07
       Schema: constructorSchema
         Root: integer04
      Purpose: This tests demonstrates the use of the xs:integer constructor function to convert a float representation
               of a fractional number to an integer type
  -->

  <tdml:parserTestCase name="integer_constructor_07" root="integer04" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:integer()  - DFDL-23-078R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <integer04>45</integer04>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: fnDateTime_constructor_01
       Schema: constructorSchema
         Root: dateTime01
      Purpose: This test demonstrates the use of the fn:dateTime constructor function to convert an xs:date and an 
               xs:time into an xs:dateTime
  -->

  <tdml:parserTestCase name="fnDateTime_constructor_01" root="dateTime01" model="constructorSchema"
    description="Section 23 - Constructor Functions - fn:dateTime()  - DFDL-23-089R">

    <tdml:document>
      <tdml:documentPart type="text">03-31-1996,04:55:30</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <dateTime01>
          <date>1996-03-31</date>
          <time>04:55:30</time>
          <dateTime>1996-03-31T04:55:30</dateTime>
        </dateTime01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: fnDateTime_constructor_02
       Schema: constructorSchema
         Root: dateTime01
      Purpose: This test demonstrates the use of the fn:dateTime constructor function to convert an xs:date and an 
               xs:time into an xs:dateTime
  -->

  <tdml:parserTestCase name="fnDateTime_constructor_02" root="dateTime01" model="constructorSchema"
    description="Section 23 - Constructor Functions - fn:dateTime()  - DFDL-23-089R">

    <tdml:document>
      <tdml:documentPart type="text">01-31-1996,04:55:30</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <dateTime01>
          <date>1996-01-31</date>
          <time>04:55:30</time>
          <dateTime>1996-01-31T04:55:30</dateTime>
        </dateTime01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: fnDateTime_constructor_03
       Schema: constructorSchema
         Root: dateTime02
      Purpose: This test demonstrates that the fn:adjust-date-to-timezone is unsupported.
  -->

  <tdml:parserTestCase name="fnDateTime_constructor_03" root="dateTime02" model="constructorSchema"
    description="Section 23 - Constructor Functions - fn:dateTime()  - DFDL-23-089R">

    <tdml:document>
      <tdml:documentPart type="text">March-31-96,04:55:30-0800</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Unsupported function: fn:adjust-date-to-timezone</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: fnDateTime_constructor_04
       Schema: constructorSchema
         Root: dateTime03
      Purpose: This test demonstrates the use of the fn:dateTime constructor function to convert an xs:date and an 
               xs:time into an xs:dateTime
  -->

  <tdml:parserTestCase name="fnDateTime_constructor_04" root="dateTime03" model="constructorSchema"
    description="Section 23 - Constructor Functions - fn:dateTime()  - DFDL-23-089R">

    <tdml:document>
      <tdml:documentPart type="text">March-31-96-0800,04:55:30-0800</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
          <dateTime03>
            <date>1996-03-31-08:00</date>
            <time>04:55:30-08:00</time>
            <dateTime>1996-03-31T04:55:30-08:00</dateTime>
          </dateTime03>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!-- 
    Test name: fnDateTime_constructor_05
       Schema: constructorSchema
         Root: dateTime03
      Purpose: This test demonstrates the use of the fn:dateTime function's timezone
               checking ability.
               The timezone of the result is computed as follows:

                If neither argument has a timezone, the result has no timezone.
                If exactly one of the arguments has a timezone, or if both arguments 
                  have the same timezone, the result has this timezone.
                If the two arguments have different timezones, 
                  an error is raised:[err:FORG0008]
-->

  <tdml:parserTestCase name="fnDateTime_constructor_05" root="dateTime03" model="constructorSchema"
    description="Section 23 - Constructor Functions - fn:dateTime()  - DFDL-23-089R">

    <tdml:document>
      <tdml:documentPart type="text">March-31-96-0700,04:55:30-0800</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Runtime Schema Definition Error</tdml:error>
      <tdml:error>The two arguments to fn:dateTime have inconsistent timezones</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: fnDateTime_constructor_06
       Schema: constructorSchema
         Root: dateTime10
      Purpose: This test demonstrates the use of the fn:dateTime constructor function to convert an xs:date and an 
               xs:time into an xs:dateTime.
               
               calendarTimeZone="", so there should be no time zone in the result
  -->

  <tdml:parserTestCase name="fnDateTime_constructor_06" root="dateTime10" model="constructorSchema"
    description="Section 23 - Constructor Functions - fn:dateTime()  - DFDL-23-089R"
    implementations="daffodil">

    <tdml:document>
      <tdml:documentPart type="text">03-31-1996,04:55:30</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <dateTime10>
          <date>1996-03-31</date>
          <time>04:55:30</time>
          <dateTime>1996-03-31T04:55:30</dateTime>
        </dateTime10>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: fnDateTime_constructor_07
       Schema: constructorSchema
         Root: dateTime11
      Purpose: This test demonstrates the use of the fn:dateTime constructor function to convert an xs:date and an 
               xs:time into an xs:dateTime.
               
               calendarTimeZone="UTC-05:00", the time zone in the result should be -05:00
  -->

  <tdml:parserTestCase name="fnDateTime_constructor_07" root="dateTime11" model="constructorSchema"
    description="Section 23 - Constructor Functions - fn:dateTime()  - DFDL-23-089R">

    <tdml:document>
      <tdml:documentPart type="text">03-31-1996,04:55:30</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <dateTime11>
          <date>1996-03-31-05:00</date>
          <time>04:55:30-05:00</time>
          <dateTime>1996-03-31T04:55:30-05:00</dateTime>
        </dateTime11>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: fnDateTime_constructor_08
       Schema: constructorSchema
         Root: dateTime12
      Purpose: This test demonstrates the use of the fn:dateTime constructor function to convert an xs:date and an 
               xs:time into an xs:dateTime.
               
               calendarTimeZone="UTC-09:00", the time zone in the result should be -09:00
  -->

  <tdml:parserTestCase name="fnDateTime_constructor_08" root="dateTime12" model="constructorSchema"
    description="Section 23 - Constructor Functions - fn:dateTime()  - DFDL-23-089R">

    <tdml:document>
      <tdml:documentPart type="text">03-31-1996,04:55:30</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <dateTime12>
          <date>1996-03-31-09:00</date>
          <time>04:55:30-09:00</time>
          <dateTime>1996-03-31T04:55:30-09:00</dateTime>
        </dateTime12>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
    Test name: fnDateTime_constructor_09
       Schema: constructorSchema
         Root: dateTime13
      Purpose: This test demonstrates the use of the fn:dateTime constructor function to convert an xs:date and an 
               xs:time into an xs:dateTime.
               
               calendarTimeZone="UTC+11:00", the time zone in the result should be +11:00
  -->

  <tdml:parserTestCase name="fnDateTime_constructor_09" root="dateTime13" model="constructorSchema"
    description="Section 23 - Constructor Functions - fn:dateTime()  - DFDL-23-089R">

    <tdml:document>
      <tdml:documentPart type="text">03-31-1996,04:55:30</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <dateTime13>
          <date>1996-03-31+11:00</date>
          <time>04:55:30+11:00</time>
          <dateTime>1996-03-31T04:55:30+11:00</dateTime>
        </dateTime13>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
    Test name: fnDateTime_constructor_10
       Schema: constructorSchema
         Root: dateTime14
      Purpose: This test demonstrates the use of the fn:dateTime constructor function to convert an xs:date and an 
               xs:time into an xs:dateTime.
               
               calendarTimeZones do not match and will result in an error
  -->

  <tdml:parserTestCase name="fnDateTime_constructor_10" root="dateTime14" model="constructorSchema"
    description="Section 23 - Constructor Functions - fn:dateTime()  - DFDL-23-089R">

    <tdml:document>
      <tdml:documentPart type="text">03-31-1996,04:55:30</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Runtime Schema Definition Error</tdml:error>
      <tdml:error>The two arguments to fn:dateTime have inconsistent timezones</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <!--
    Test name: int_constructor_01
       Schema: constructorSchema
         Root: int01
      Purpose: This test demonstrates the use of the xs:int constructor function and its ability to
               convert a fractional number to an int
  -->

  <tdml:parserTestCase name="int_constructor_01" root="int01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:int()  - DFDL-23-080R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <int01>45</int01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: int_constructor_02
       Schema: constructorSchema
         Root: int02
      Purpose: This test demonstrates the use of the xs:int constructor function and its ability to
               convert a value to an int type
  -->

  <tdml:parserTestCase name="int_constructor_02" root="int02" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:int()  - DFDL-23-080R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <int02>60</int02>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: int_constructor_03
       Schema: constructorSchema
         Root: int03
      Purpose: This test demonstrates the use of the xs:int constructor function and its ability to
               convert a parsed value into an int
  -->

  <tdml:parserTestCase name="int_constructor_03" root="int03" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:int()  - DFDL-23-080R">

    <tdml:document>
      <tdml:documentPart type="text">44444444</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <int03>
          <string>44444444</string>
          <intified>44444444</intified>
        </int03>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: int_constructor_04
       Schema: constructorSchema
         Root: int03
      Purpose: This test demonstrates the use of the xs:int constructor function and its ability to
               convert a parsed value into an int. In this case the data is invalid and an error should occur.
  -->

  <tdml:parserTestCase name="int_constructor_04" root="int03" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:int()  - DFDL-23-080R">

    <tdml:document>
      <tdml:documentPart type="text">not an int!</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>expression evaluation error</tdml:error>
      <tdml:error>Cannot convert</tdml:error>
      <tdml:error>not an int</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: long_constructor_01
       Schema: constructorSchema
         Root: long01
      Purpose: This test demonstrates the use of the xs:long constructor function and its ability to
               convert a number to a long
  -->

  <tdml:parserTestCase name="long_constructor_01" root="long01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:long()  - DFDL-23-079R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <long01>-50</long01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: long_constructor_02
       Schema: constructorSchema
         Root: long02
      Purpose: This test demonstrates the use of the xs:long constructor function and its ability to
               convert a number to a long
  -->

  <tdml:parserTestCase name="long_constructor_02" root="long02" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:long()  - DFDL-23-079R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <long02>12345678987654321</long02>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: long_constructor_03
       Schema: constructorSchema
         Root: long03
      Purpose: This test demonstrates the use of the xs:long constructor function and its ability to
               convert a string (numeric) to a long
  -->

  <tdml:parserTestCase name="long_constructor_03" root="long03" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:long()  - DFDL-23-079R">

    <tdml:document>
      <tdml:documentPart type="text">123456789</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <long03>
          <string>123456789</string>
          <longified>123456789</longified>
        </long03>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: long_constructor_04
       Schema: constructorSchema
         Root: long04
      Purpose: This test demonstrates that if you provide a non-numeric string to the long constructor you get an appropriate error
  -->

  <tdml:parserTestCase name="long_constructor_04" root="long03" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:long()  - DFDL-23-079R">

    <tdml:document>
      <tdml:documentPart type="text">not longable</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>Cannot convert</tdml:error>
      <tdml:error>not longable</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: ulong_constructor_01
       Schema: constructorSchema
         Root: ulong01
      Purpose: This test demonstrates the use of the xs:unsignedLong constructor function and its ability to
               convert a number to an unsigned long
  -->

  <tdml:parserTestCase name="ulong_constructor_01" root="ulong01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:unsignedLong()  - DFDL-23-084R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>-50</tdml:error>
      <tdml:error>convert</tdml:error>
      <tdml:error>unsignedLong</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: ulong_constructor_02
       Schema: constructorSchema
         Root: ulong02
      Purpose: This test demonstrates the use of the xs:unsignedLong constructor function and its ability to
               convert a number to an unsigned long
  -->

  <tdml:parserTestCase name="ulong_constructor_02" root="ulong02" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:unsignedLong()  - DFDL-23-084R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ulong02>12345678987654321</ulong02>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: ulong_constructor_03
       Schema: constructorSchema
         Root: ulong03
      Purpose: This test demonstrates the use of the xs:unsignedLong constructor function and its ability to
               convert a string (numeric) to an unsigned Long
  -->

  <tdml:parserTestCase name="ulong_constructor_03" root="ulong03" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:unsignedLong()  - DFDL-23-084R">

    <tdml:document>
      <tdml:documentPart type="text">123456789</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ulong03>
          <string>123456789</string>
          <ulongified>123456789</ulongified>
        </ulong03>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: ulong_constructor_04
       Schema: constructorSchema
         Root: ulong04
      Purpose: This test demonstrates that if you provide a non-numeric string to the unsigned long constructor you get an appropriate error
  -->

  <tdml:parserTestCase name="ulong_constructor_04" root="ulong03" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:unsignedLong()  - DFDL-23-084R">

    <tdml:document>
      <tdml:documentPart type="text">not longable</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>Cannot convert</tdml:error>
      <tdml:error>not longable</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: ulong_constructor_05
       Schema: constructorSchema
         Root: ulong03
      Purpose: This test demonstrates the use of the xs:unsignedLong constructor function and its ability to
               convert a string (numeric) to an unsigned Long. The max value for an unsigned long is 18,446,744,073,709,551,615, 
               so this test should fail.
  -->

  <tdml:parserTestCase name="ulong_constructor_05" root="ulong03" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:unsignedLong()  - DFDL-23-084R">

    <tdml:document>
      <tdml:documentPart type="text">18446744073709551616</tdml:documentPart>
    </tdml:document>
      <tdml:errors>
        <tdml:error>Parse Error</tdml:error>
        <tdml:error>out of range</tdml:error>
        <tdml:error>unsignedLong</tdml:error>
      </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: ushort_constructor_01
       Schema: constructorSchema
         Root: ushort01
      Purpose: This test demonstrates the use of the xs:unsignedShort constructor function and its ability to
               convert a number to an unsigned short
  -->

  <tdml:parserTestCase name="ushort_constructor_01" root="ushort01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:unsignedShort()  - DFDL-23-086R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>-50</tdml:error>
      <tdml:error>convert</tdml:error>
      <tdml:error>unsignedShort</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: ushort_constructor_02
       Schema: constructorSchema
         Root: ushort02
      Purpose: This test demonstrates the use of the xs:unsignedShort constructor function and its ability to
               convert a number to an unsigned short
  -->

  <tdml:parserTestCase name="ushort_constructor_02" root="ushort02" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:unsignedShort()  - DFDL-23-086R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>12345678987654321</tdml:error>
      <tdml:error>convert</tdml:error>
      <tdml:error>unsignedShort</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: ushort_constructor_03
       Schema: constructorSchema
         Root: ushort03
      Purpose: This test demonstrates the use of the xs:unsignedShort constructor function and its ability to
               convert a string (numeric) to an unsigned short
  -->

  <tdml:parserTestCase name="ushort_constructor_03" root="ushort03" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:unsignedShort()  - DFDL-23-086R">

    <tdml:document>
      <tdml:documentPart type="text">65535</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ushort03>
          <string>65535</string>
          <ushortified>65535</ushortified>
        </ushort03>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: ushort_constructor_04
       Schema: constructorSchema
         Root: ushort03
      Purpose: This test demonstrates the use of the xs:unsignedShort constructor function and its ability to
               convert a string (numeric) to an unsigned short
  -->

  <tdml:parserTestCase name="ushort_constructor_04" root="ushort03" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:unsignedShort()  - DFDL-23-086R">

    <tdml:document>
      <tdml:documentPart type="text">65536</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
    <tdml:error>out of range</tdml:error>
    <tdml:error>unsignedShort</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: ushort_constructor_05
       Schema: constructorSchema
         Root: ushort04
      Purpose: This test demonstrates that if you provide a non-numeric string to the unsigned short constructor you get an appropriate error
  -->

  <tdml:parserTestCase name="ushort_constructor_05" root="ushort03" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:unsignedShort()  - DFDL-23-086R">

    <tdml:document>
      <tdml:documentPart type="text">not shortable</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>Cannot convert</tdml:error>
      <tdml:error>not shortable</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <!--
    Test name: short_constructor_01
       Schema: constructorSchema
         Root: short01
      Purpose: This test demonstrates the use of the xs:short constructor function and its ability to
               convert a number to an unsigned short
  -->

  <tdml:parserTestCase name="short_constructor_01" root="short01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:short()  - DFDL-23-081R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <short01>-50</short01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: short_constructor_02
       Schema: constructorSchema
         Root: short02
      Purpose: This test demonstrates the use of the xs:short constructor function and its ability to
               convert a number to a short
  -->

  <tdml:parserTestCase name="short_constructor_02" root="short02" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:short()  - DFDL-23-081R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>12345678987654321</tdml:error>
      <tdml:error>convert</tdml:error>
      <tdml:error>short</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: short_constructor_03
       Schema: constructorSchema
         Root: short03
      Purpose: This test demonstrates the use of the xs:short constructor function and its ability to
               convert a string (numeric) to a short
  -->

  <tdml:parserTestCase name="short_constructor_03" root="short03" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:short()  - DFDL-23-081R">

    <tdml:document>
      <tdml:documentPart type="text">-32768</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <short03>
          <string>-32768</string>
          <shortified>-32768</shortified>
        </short03>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: short_constructor_04
       Schema: constructorSchema
         Root: short03
      Purpose: This test demonstrates the use of the xs:short constructor function and its ability to
      convert a string (numeric) to a short. The range for short is -32768 to 32767 so this
      test should fail with a parse error.
  -->

  <tdml:parserTestCase name="short_constructor_04" root="short03" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:short()  - DFDL-23-081R">

    <tdml:document>
      <tdml:documentPart type="text">-32769</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>out of range</tdml:error>
      <tdml:error>short</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: short_constructor_05
       Schema: constructorSchema
         Root: short04
      Purpose: This test demonstrates that if you provide a non-numeric string to the unsigned short constructor you get an appropriate error
  -->

  <tdml:parserTestCase name="short_constructor_05" root="short03" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:short()  - DFDL-23-081R">

    <tdml:document>
      <tdml:documentPart type="text">not shortable</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>Cannot convert</tdml:error>
      <tdml:error>not shortable</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: short_constructor_06
       Schema: constructorSchema
         Root: short04
      Purpose: This test demonstrates the use of the xs:short constructor function and its ability to
               convert a string (numeric - binary rep) to a short
  -->

  <tdml:parserTestCase name="short_constructor_06" root="short04" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:short()  - DFDL-23-081R">

    <tdml:document>
      <tdml:documentPart type="bits">00101101 00110011 00110010 00110111 00110110 00111000</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <short04>
          <string>-32768</string>
          <shortified>-32768</shortified>
        </short04>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: decimal_constructor_01
       Schema: constructorSchema
         Root: decimal01
      Purpose: This test demonstrates the use of the xs:decimal constructor function and its ability to
               convert a number to a decimal
  -->

  <tdml:parserTestCase name="decimal_constructor_01" root="decimal01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:decimal()  - DFDL-23-071R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <decimal01>45.2</decimal01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: decimal_constructor_02
       Schema: constructorSchema
         Root: decimal02
      Purpose: This test demonstrates the use of the xs:decimal constructor function and its ability to
               convert a number to a decimal
  -->

  <tdml:parserTestCase name="decimal_constructor_02" root="decimal02" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:decimal()  - DFDL-23-071R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <decimal02>60</decimal02>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: decimal_constructor_03
       Schema: constructorSchema
         Root: decimal03
      Purpose: This test demonstrates the use of the xs:decimal constructor function and its ability to
               convert a string (numeric) to a decimal
  -->

  <tdml:parserTestCase name="decimal_constructor_03" root="decimal03" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:decimal()  - DFDL-23-071R">

    <tdml:document>
      <tdml:documentPart type="text">0.123456789</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <decimal03>
          <string>0.123456789</string>
          <decified>0.123456789</decified>
        </decimal03>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: decimal_constructor_04
       Schema: constructorSchema
         Root: decimal03
      Purpose: This test demonstrates that if you provide a non-numeric string to the unsigned short constructor you get an appropriate error
  -->

  <tdml:parserTestCase name="decimal_constructor_04" root="decimal03" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:decimal()  - DFDL-23-071R">

    <tdml:document>
      <tdml:documentPart type="text">not decimalable</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>Cannot convert</tdml:error>
      <tdml:error>not decimalable</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: decimal_constructor_05
       Schema: constructorSchema
         Root: decimal04
      Purpose: This test demonstrates that the xs:decimal constructor can handle negative values
  -->

  <tdml:parserTestCase name="decimal_constructor_05" root="decimal04" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:decimal()  - DFDL-23-071R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <decimal04>-60</decimal04>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: decimal_constructor_06
       Schema: constructorSchema
         Root: decimal03
      Purpose: This test demonstrates the use of the xs:decimal constructor function and its ability to
               convert a string (numeric) to a decimal
  -->

  <tdml:parserTestCase name="decimal_constructor_06" root="decimal03" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:decimal()  - DFDL-23-071R">

    <tdml:document>
      <tdml:documentPart type="text">0.1234567898765432123456789</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <decimal03>
          <string>0.1234567898765432123456789</string>
          <decified>0.1234567898765432123456789</decified>
        </decimal03>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: float_constructor_01
       Schema: constructorSchema
         Root: float01
      Purpose: This test demonstrates the use of the xs:float constructor function and its ability to
               convert a number to a float
  -->

  <tdml:parserTestCase name="float_constructor_01" root="float01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:float()  - DFDL-23-072R">

    <tdml:document>
      <tdml:documentPart type="text">4.3</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <float01>
          <string>4.3</string>
          <floatified>4.3</floatified>
        </float01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: float_constructor_02
       Schema: constructorSchema
         Root: float02
      Purpose: This test demonstrates the use of the xs:float constructor function and its ability to
               convert a string (numeric) to a float
  -->

  <tdml:parserTestCase name="float_constructor_02" root="float02" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:float()  - DFDL-23-072R">

    <tdml:document>
      <tdml:documentPart type="text">4.3,1.5</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <float02>
          <string>4.3</string>
          <string2>1.5</string2>
          <floatified>5.8</floatified>
        </float02>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: float_constructor_03
       Schema: constructorSchema
         Root: float02
      Purpose: This test demonstrates the use of the xs:float constructor function and its ability to
      convert a string (numeric) to a float. In this case we are trying to add a non-numeric
      string to a numeric one, which should result in an error.
  -->

  <tdml:parserTestCase name="float_constructor_03" root="float02" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:float()  - DFDL-23-072R">

    <tdml:document>
      <tdml:documentPart type="text">4.3,one</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>convert</tdml:error>
      <tdml:error>string</tdml:error>
      <tdml:error>one</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: float_constructor_04
       Schema: constructorSchema
         Root: float02
      Purpose: This test demonstrates the use of the xs:float constructor function and its ability to
               convert a string (numeric) to a float
  -->

  <tdml:parserTestCase name="float_constructor_04" root="float02" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:float()  - DFDL-23-072R">

    <tdml:document>
      <tdml:documentPart type="text">4.3,1.987654</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <float02>
          <string>4.3</string>
          <string2>1.987654</string2>
          <floatified>6.287654</floatified>
        </float02>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: double_constructor_01
       Schema: constructorSchema
         Root: double01
      Purpose: This test demonstrates the use of the xs:double constructor function and its ability to
               convert a number to a double
  -->

  <tdml:parserTestCase name="double_constructor_01" root="double01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:double()  - DFDL-23-073R">

    <tdml:document>
      <tdml:documentPart type="text">4.3</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <double01>
          <string>4.3</string>
          <doublified>4.3</doublified>
        </double01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: double_constructor_02
       Schema: constructorSchema
         Root: double01
      Purpose: This test demonstrates the use of the xs:double constructor function and its ability to
               convert a number to a double. This test demonstrates that the limit for double is 15 decimal places.
  -->

  <tdml:parserTestCase name="double_constructor_02" root="double01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:double()  - DFDL-23-073R">

    <tdml:document>
      <tdml:documentPart type="text">4.10101010101010101019</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <double01>
          <string>4.10101010101010101019</string>
          <doublified>4.101010101010101</doublified>
        </double01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: double_constructor_03
       Schema: constructorSchema
         Root: double01
      Purpose: This test demonstrates the use of the xs:double constructor function and its ability to
               convert a number to a double. This test demonstrates that the limit for double is 15 decimal places.
  -->

  <tdml:parserTestCase name="double_constructor_03" root="double01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:double()  - DFDL-23-073R">

    <tdml:document>
      <tdml:documentPart type="text">123456789.11111111111111911111</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <double01>
          <string>123456789.11111111111111911111</string>
          <doublified>1.234567891111111E8</doublified>
        </double01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: double_constructor_04
       Schema: constructorSchema
         Root: double02
      Purpose: This test demonstrates the use of the xs:double constructor function and its ability to
               convert a number to a double.
  -->

  <tdml:parserTestCase name="double_constructor_04" root="double02" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:double()  - DFDL-23-073R">

    <tdml:document>
      <tdml:documentPart type="text">10000000000.40,10000000000.30</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <double02>
          <string>10000000000.40</string>
          <string2>10000000000.30</string2>
          <doublified>2.0000000000699997E10</doublified>
        </double02>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: double_constructor_05
       Schema: constructorSchema
         Root: double01
      Purpose: This test demonstrates the use of the xs:double constructor function and its ability to
               convert a number (scientific notation) to a double.
  -->

  <tdml:parserTestCase name="double_constructor_05" root="double01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:double()  - DFDL-23-073R">

    <tdml:document>
      <tdml:documentPart type="text">1.123456789E9</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <double01>
          <string>1.123456789E9</string>
          <doublified>1.123456789E9</doublified>
        </double01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: double_constructor_06
       Schema: constructorSchema
         Root: double01
      Purpose: This test demonstrates the use of the xs:double constructor function and its ability to
               convert a number (scientific notation) to a double.
  -->

  <tdml:parserTestCase name="double_constructor_06" root="double01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:double()  - DFDL-23-073R">

    <tdml:document>
      <tdml:documentPart type="text">1.23E</tdml:documentPart>
    </tdml:document>
      <tdml:errors>
        <tdml:error>Parse Error</tdml:error>
        <tdml:error>convert</tdml:error>
        <tdml:error>string</tdml:error>
        <tdml:error>double</tdml:error>
        <tdml:error>"1.23E"</tdml:error>
      </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: double_constructor_07
       Schema: constructorSchema
         Root: double01
      Purpose: This test demonstrates the use of the xs:double constructor function and its ability to
               convert a number (scientific notation) to a double.
  -->

  <tdml:parserTestCase name="double_constructor_07" root="double01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:double()  - DFDL-23-073R">

    <tdml:document>
      <tdml:documentPart type="text">1.23E-9</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <double01>
          <string>1.23E-9</string>
          <doublified>1.23E-9</doublified>
        </double01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: xsDateTime_constructor_01
       Schema: constructorSchema
         Root: dateTime04
      Purpose: This test demonstrates the use of the xs:dateTime constructor function and its ability to
               convert a string to a dateTime
  -->

  <tdml:parserTestCase name="xsDateTime_constructor_01" root="dateTime04" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:dateTime()  - DFDL-23-074R">

    <tdml:document>
      <tdml:documentPart type="text">1996-02-04T12:30:34</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <dateTime04>
          <string>1996-02-04T12:30:34</string>
          <dateTime>1996-02-04T12:30:34</dateTime>
        </dateTime04>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: xsDateTime_constructor_02
       Schema: constructorSchema
         Root: dateTime04
      Purpose: This test demonstrates the use of the xs:dateTime constructor function and its ability to
               convert a string to a dateTime
  -->

  <tdml:parserTestCase name="xsDateTime_constructor_02" root="dateTime04" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:dateTime()  - DFDL-23-074R">

    <tdml:document>
      <tdml:documentPart type="text">02-03-1998T12:30:34</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>"02-03-1998T12:30:34"</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: xsDateTime_constructor_03
       Schema: constructorSchema
         Root: dateTime04
      Purpose: This test demonstrates the use of the xs:dateTime constructor function and its ability to
               convert a string to a dateTime
  -->

  <tdml:parserTestCase name="xsDateTime_constructor_03" root="dateTime04" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:dateTime()  - DFDL-23-074R">

    <tdml:document>
      <tdml:documentPart type="text">1998-03-04T12:30:34.123456+00:00</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <dateTime04>
          <string>1998-03-04T12:30:34.123456</string>
          <dateTime>1998-03-04T12:30:34.123456</dateTime>
        </dateTime04>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: xsDateTime_constructor_04
       Schema: constructorSchema
         Root: dateTime04
      Purpose: This test demonstrates the use of the xs:dateTime constructor function and its ability to
               convert a string to a dateTime
  -->

  <tdml:parserTestCase name="xsDateTime_constructor_04" root="dateTime04" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:dateTime()  - DFDL-23-074R">

    <tdml:document>
      <tdml:documentPart type="text">1996-03-04T28:30:34</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>1996-03-04T28:30:34</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: xsDateTime_constructor_05
       Schema: constructorSchema
         Root: dateTime04
      Purpose: This test demonstrates the use of the xs:dateTime constructor function and its ability to
               convert a string to a dateTime
  -->

  <tdml:parserTestCase name="xsDateTime_constructor_05" root="dateTime04" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:dateTime()  - DFDL-23-074R">

    <tdml:document>
      <tdml:documentPart type="text">about four-thirty or so, on a Wednesday in June.</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>about four-thirty or so</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: xsDateTime_constructor_06
       Schema: constructorSchema
         Root: dateTime05
      Purpose: This test demonstrates the use of the xs:dateTime constructor function and its ability to
               convert a string to a dateTime
               123000 because of http://www.ogf.org/pipermail/dfdl-wg/2013-April/002434.html
  -->

  <tdml:parserTestCase name="xsDateTime_constructor_06" root="dateTime05" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:dateTime()  - DFDL-23-074R">

    <tdml:document>
      <tdml:documentPart type="text">1998-03-04T12:30:34.123456+00:00</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <dateTime05>
          <string>1998-03-04T12:30:34.123456+00:00</string>
          <dateTime>1998-03-04T12:30:34.123000+00:00</dateTime>
        </dateTime05>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: xsDateTime_constructor_07
       Schema: constructorSchema
         Root: dateTime06
      Purpose: This test demonstrates the use of the xs:dateTime constructor function and its inability to
               cast xs:time to xs:dateTime
               123000 because of http://www.ogf.org/pipermail/dfdl-wg/2013-April/002434.html
  -->

  <tdml:parserTestCase name="xsDateTime_constructor_07" root="dateTime06" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:dateTime()  - DFDL-23-074R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>Casting from xs:time to xs:dateTime can never succeed</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: xsDateTime_constructor_08
       Schema: constructorSchema
         Root: dateTime07
      Purpose: This test demonstrates the use of the xs:dateTime constructor function and its ability to
               convert a xs:date to a xs:dateTime
  -->

  <tdml:parserTestCase name="xsDateTime_constructor_08" root="dateTime07" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:dateTime()  - DFDL-23-074R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
    	<tdml:dfdlInfoset>
    		<dateTime07>2014-10-23T00:00:00</dateTime07>
    	</tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: xsDateTime_constructor_09
       Schema: constructorSchema
         Root: dateTime08
      Purpose: This test demonstrates the use of the xs:dateTime constructor function and its ability to
               convert a xs:dateTime to a xs:dateTime
  -->

  <tdml:parserTestCase name="xsDateTime_constructor_09" root="dateTime08" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:dateTime()  - DFDL-23-074R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
    	<tdml:dfdlInfoset>
    		<dateTime08>2014-10-23T04:55:30</dateTime08>
    	</tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: xsDateTime_constructor_10
       Schema: constructorSchema
         Root: dateTime09
      Purpose: This test demonstrates the use of the xs:dateTime constructor function and its inability to
               convert a xs:integer to a xs:dateTime
  -->

  <tdml:parserTestCase name="xsDateTime_constructor_10" root="dateTime09" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:dateTime()  - DFDL-23-074R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>dateTime</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  
  <!--
    Test name: time_constructor_01
       Schema: constructorSchema
         Root: time01
      Purpose: This test demonstrates the use of the xs:time constructor function and its ability to
               convert a string to a time
  -->

  <tdml:parserTestCase name="time_constructor_01" root="time01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:time()  - DFDL-23-075R">

    <tdml:document>
      <tdml:documentPart type="text">12:49:00</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <time01>
          <string>12:49:00</string>
          <time>12:49:00</time>
        </time01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: time_constructor_02
       Schema: constructorSchema
         Root: time01
      Purpose: This test demonstrates the use of the xs:time constructor function and its ability to
               convert a string to a time. In this case the time is invalid and an error should occur
  -->

  <tdml:parserTestCase name="time_constructor_02" root="time01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:time()  - DFDL-23-075R">

    <tdml:document>
      <tdml:documentPart type="text">03:61:00</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>"03:61:00"</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: time_constructor_03
       Schema: constructorSchema
         Root: time01
      Purpose: This test demonstrates the use of the xs:time constructor function and its ability to
               convert a string to a time. In this case the time is invalid and an error should occur
  -->

  <tdml:parserTestCase name="time_constructor_03" root="time01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:time()  - DFDL-23-075R">

    <tdml:document>
      <tdml:documentPart type="text">03:59:61</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>"03:59:61"</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: time_constructor_04
       Schema: constructorSchema
         Root: time01
      Purpose: This test demonstrates the use of the xs:time constructor function and its ability to
               construct a time from a string. In this case the string is not valid and an error will occur.
  -->

  <tdml:parserTestCase name="time_constructor_04" root="time01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:time()  - DFDL-23-075R">

    <tdml:document>
      <tdml:documentPart type="text">five o'clock</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>"five o'clock"</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: time_constructor_05
       Schema: constructorSchema
         Root: time02
      Purpose: This test demonstrates the use of the xs:time constructor function and its ability to
               convert a string to a time
  -->

  <tdml:parserTestCase name="time_constructor_05" root="time02" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:time()  - DFDL-23-075R">

    <tdml:document>
      <tdml:documentPart type="text">12:49:00</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <time02>
          <string>12:49:00</string>
          <time>12:49:00</time>
        </time02>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: time_constructor_06
       Schema: constructorSchema
         Root: time03
      Purpose: This test demonstrates the use of the xs:time constructor function and its inability to
               cast a xs:date to xs:time
  -->

  <tdml:parserTestCase name="time_constructor_06" root="time03" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:time()  - DFDL-23-075R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>Casting from xs:date to xs:time can never succeed</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: time_constructor_07
       Schema: constructorSchema
         Root: time04
      Purpose: This test demonstrates the use of the xs:time constructor function and its ability to
               cast xs:time to xs:time
  -->

  <tdml:parserTestCase name="time_constructor_07" root="time04" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:time()  - DFDL-23-075R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
    	<tdml:dfdlInfoset>
    		<ex:time04>08:00:00</ex:time04>
    	</tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: time_constructor_08
       Schema: constructorSchema
         Root: time05
      Purpose: This test demonstrates the use of the xs:time constructor function and its ability to
               cast xs:dateTime to xs:time
  -->

  <tdml:parserTestCase name="time_constructor_08" root="time05" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:time()  - DFDL-23-075R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
    	<tdml:dfdlInfoset>
    		<ex:time05>08:00:00</ex:time05>
    	</tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: time_constructor_09
       Schema: constructorSchema
         Root: time06
      Purpose: This test demonstrates the use of the xs:time constructor function and its ability to
               convert a string to a time with a timezone
  -->

  <tdml:parserTestCase name="time_constructor_09" root="time06" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:time()  - DFDL-23-075R">

    <tdml:document>
      <tdml:documentPart type="text">05:37:21</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <time06>05:37:21-05:00</time06>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: date_constructor_01
       Schema: constructorSchema
         Root: date01
      Purpose: This test demonstrates the use of the xs:date constructor function and its ability to
               construct a date from a string. In this case the string is not valid and an error will occur.
  -->

  <tdml:parserTestCase name="date_constructor_01" root="date01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:date()  - DFDL-23-076R">

    <tdml:document>
      <tdml:documentPart type="text">1991-03-4</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>Invalid date "1991-03-4" (Day must be two digits)</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: date_constructor_02
       Schema: constructorSchema
         Root: date01
      Purpose: This test demonstrates the use of the xs:date constructor function and its ability to
               construct a date from a string.
  -->

  <tdml:parserTestCase name="date_constructor_02" root="date01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:date()  - DFDL-23-076R">

    <tdml:document>
      <tdml:documentPart type="text">1991-03-04</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <date01>
          <string>1991-03-04</string>
          <date>1991-03-04</date>
        </date01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: date_constructor_03
       Schema: constructorSchema
         Root: date01
      Purpose: This test demonstrates the use of the xs:date constructor function and its ability to
               construct a date from a string.
  -->

  <tdml:parserTestCase name="date_constructor_03" root="date01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:date()  - DFDL-23-076R">

    <tdml:document>
      <tdml:documentPart type="text">1991-03-045</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: date_constructor_04
       Schema: constructorSchema
         Root: date01
      Purpose: This test demonstrates the use of the xs:date constructor function and its ability to
               construct a date from a string.
  -->

  <tdml:parserTestCase name="date_constructor_04" root="date01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:date()  - DFDL-23-076R">

    <tdml:document>
      <tdml:documentPart type="text">2013-03-04</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <date01>
          <string>2013-03-04</string>
          <date>2013-03-04</date>
        </date01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: hexBinary_constructor_01
       Schema: constructorSchema
         Root: hexBinary01
      Purpose: This test demonstrates the use of the xs:hexBinary constructor function and its ability to
               construct a hexBinary string from a string.
  -->

  <tdml:parserTestCase name="hexBinary_constructor_01" root="hexBinary01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:hexBinary()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text">ABCDEF123456</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <hexBinary01>
          <string>ABCDEF123456</string>
          <hexBinary>ABCDEF123456</hexBinary>
        </hexBinary01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: hexBinary_constructor_02
       Schema: constructorSchema
         Root: hexBinary01
      Purpose: This test demonstrates the use of the xs:hexBinary constructor function and its ability to
      construct a hexBinary string from a string. In this case the length of the hexBinary is not even and 
      an error will occur.
  -->

  <tdml:parserTestCase name="hexBinary_constructor_02" root="hexBinary01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:hexBinary()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text">ABCDEF12345</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>A hexBinary value must contain an even number of characters</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: hexBinary_constructor_04
       Schema: constructorSchema
         Root: hexBinary01
      Purpose: This test demonstrates the use of the xs:hexBinary constructor function and its ability to
      construct a hexBinary string from a string. In this case some characters are invalid and the test
      should result in an error.
  -->

  <tdml:parserTestCase name="hexBinary_constructor_04" root="hexBinary01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:hexBinary()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text">abcdefj12345</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>Invalid hexadecimal digit</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: byte_constructor_01
       Schema: constructorSchema
         Root: byte01
      Purpose: This test demonstrates the use of the xs:byte constructor function and its ability to
      construct a byte from a numeric string. 
  -->

  <tdml:parserTestCase name="byte_constructor_01" root="byte01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:byte()  - DFDL-23-082R">

    <tdml:document>
      <tdml:documentPart type="text">15</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <byte01>
          <string>15</string>
          <byte>15</byte>
        </byte01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: byte_constructor_02
       Schema: constructorSchema
         Root: byte01
      Purpose: This test demonstrates the use of the xs:byte constructor function and its ability to
      construct a byte from a numeric string. 
  -->

  <tdml:parserTestCase name="byte_constructor_02" root="byte01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:byte()  - DFDL-23-082R">

    <tdml:document>
      <tdml:documentPart type="bits">00110001 00110101</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <byte01>
          <string>15</string>
          <byte>15</byte>
        </byte01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: byte_constructor_03
       Schema: constructorSchema
         Root: byte01
      Purpose: This test demonstrates the use of the xs:byte constructor function and its ability to
      construct a byte from a numeric string. The range for a byte is -128 - 127 so this test should err out.
  -->

  <tdml:parserTestCase name="byte_constructor_03" root="byte01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:byte()  - DFDL-23-082R">

    <tdml:document>
      <tdml:documentPart type="byte">31 32 38</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>out of range</tdml:error>
      <tdml:error>byte</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: byte_constructor_04
       Schema: constructorSchema
         Root: byte01
      Purpose: This test demonstrates the use of the xs:byte constructor function and its ability to
      construct a byte from a numeric string. The range for a byte is -128 - 127.
  -->

  <tdml:parserTestCase name="byte_constructor_04" root="byte01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:byte()  - DFDL-23-082R">

    <tdml:document>
      <tdml:documentPart type="byte">31 32 37</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <byte01>
          <string>127</string>
          <byte>127</byte>
        </byte01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: nonNeg_constructor_01
       Schema: constructorSchema
         Root: nonNeg01
      Purpose: This test demonstrates the use of the xs:nonNegativeInteger constructor function and its ability to
      construct a nonNegativeInteger from a numeric string.
  -->

  <tdml:parserTestCase name="nonNeg_constructor_01" root="nonNeg01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:nonNegativeInteger()  - DFDL-23-083R">

    <tdml:document>
      <tdml:documentPart type="text">-50,30</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>nonNegativeInteger</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: nonNeg_constructor_02
       Schema: constructorSchema
         Root: nonNeg01
      Purpose: This test demonstrates the use of the xs:nonNegativeInteger constructor function and its ability to
      construct a nonNegativeInteger from a numeric string.
  -->

  <tdml:parserTestCase name="nonNeg_constructor_02" root="nonNeg01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:nonNegativeInteger()  - DFDL-23-083R">

    <tdml:document>
      <tdml:documentPart type="text">-50,60</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <nonNeg01>
          <string>-50</string>
          <string2>60</string2>
          <nonNeg>10</nonNeg>
        </nonNeg01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: nonNeg_constructor_03
       Schema: constructorSchema
         Root: nonNeg01
      Purpose: This test demonstrates the use of the xs:nonNegativeInteger constructor function and its ability to
      construct a nonNegativeInteger from a numeric string.
  -->

  <tdml:parserTestCase name="nonNeg_constructor_03" root="nonNeg01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:nonNegativeInteger()  - DFDL-23-083R">

    <tdml:document>
      <tdml:documentPart type="text">-50,700</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <nonNeg01>
          <string>-50</string>
          <string2>700</string2>
          <nonNeg>650</nonNeg>
        </nonNeg01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: nonNeg_constructor_04
       Schema: constructorSchema
         Root: nonNeg02
      Purpose: This test demonstrates the use of the xs:nonNegativeInteger constructor function and its ability to
      construct a nonNegativeInteger from a numeric string.
  -->

  <tdml:parserTestCase name="nonNeg_constructor_04" root="nonNeg02" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:nonNegativeInteger()  - DFDL-23-083R">

    <tdml:document>
      <tdml:documentPart type="text">abc</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>Cannot convert</tdml:error>
      <tdml:error>abc</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: uint_constructor_01
       Schema: constructorSchema
         Root: uint01
      Purpose: This test demonstrates the use of the xs:unsignedInt constructor function and its ability to
      construct an unsigned Int from a numeric string.
  -->

  <tdml:parserTestCase name="uint_constructor_01" root="uint01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:unsignedInt()  - DFDL-23-085R">

    <tdml:document>
      <tdml:documentPart type="text">-50</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: uint_constructor_02
       Schema: constructorSchema
         Root: uint01
      Purpose: This test demonstrates the use of the xs:unsignedInt constructor function and its ability to
      construct an unsigned Int from a numeric string. The range for unsignedInt is 0 - 4,294,967,295,
      so this test should cause an error.
  -->

  <tdml:parserTestCase name="uint_constructor_02" root="uint01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:unsignedInt()  - DFDL-23-085R">

    <tdml:document>
      <tdml:documentPart type="text">4294967296</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
    <tdml:error>out of range</tdml:error>
      <tdml:error>unsignedInt</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: uint_constructor_03
       Schema: constructorSchema
         Root: uint01
      Purpose: This test demonstrates the use of the xs:unsignedInt constructor function and its ability to
      construct an unsigned Int from a numeric string. The range for unsignedInt is 0 - 4,294,967,295,
  -->

  <tdml:parserTestCase name="uint_constructor_03" root="uint01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:unsignedInt()  - DFDL-23-085R">

    <tdml:document>
      <tdml:documentPart type="text">4294967295</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <uint01>
          <string>4294967295</string>
          <uintified>4294967295</uintified>
        </uint01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: uint_constructor_04
       Schema: constructorSchema
         Root: uint01
      Purpose: This test demonstrates the use of the xs:unsignedInt constructor function and its ability to
      construct an unsigned Int from a numeric string. The range for unsignedInt is 0 - 4,294,967,295,
  -->

  <tdml:parserTestCase name="uint_constructor_04" root="uint01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:unsignedInt()  - DFDL-23-085R">

    <tdml:document>
      <tdml:documentPart type="byte">34 32 39 34 39 36 37 32 39 35</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <uint01>
          <string>4294967295</string>
          <uintified>4294967295</uintified>
        </uint01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: ubyte_constructor_01
       Schema: constructorSchema
         Root: uint01
      Purpose: This test demonstrates the use of the xs:unsignedByte constructor function and its ability to
      construct an unsigned byte from a numeric string. The range for unsignedByte is 0 - 255
  -->

  <tdml:parserTestCase name="ubyte_constructor_01" root="ubyte01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:unsignedByte()  - DFDL-23-087R">

    <tdml:document>
      <tdml:documentPart type="text">-1</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>unsigned</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: ubyte_constructor_02
       Schema: constructorSchema
         Root: ubyte01
      Purpose: This test demonstrates the use of the xs:unsignedByte constructor function and its ability to
      construct an unsigned byte from a numeric string. The range for unsignedByte is 0 - 255
  -->

  <tdml:parserTestCase name="ubyte_constructor_02" root="ubyte01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:unsignedByte()  - DFDL-23-087R">

    <tdml:document>
      <tdml:documentPart type="text">255</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ubyte01>
          <string>255</string>
          <ubyte>255</ubyte>
        </ubyte01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: ubyte_constructor_03
       Schema: constructorSchema
         Root: ubyte01
      Purpose: This test demonstrates the use of the xs:unsignedByte constructor function and its ability to
      construct an unsigned byte from a numeric string. The range for unsignedByte is 0 - 255
  -->

  <tdml:parserTestCase name="ubyte_constructor_03" root="ubyte01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:unsignedByte()  - DFDL-23-087R">

    <tdml:document>
      <tdml:documentPart type="text">256</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>out of range</tdml:error>
      <tdml:error>unsignedByte</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: ubyte_constructor_04
       Schema: constructorSchema
         Root: ubyte01
      Purpose: This test demonstrates the use of the xs:unsignedByte constructor function and its ability to
      construct an unsigned byte from a numeric string. The range for unsignedByte is 0 - 255
  -->

  <tdml:parserTestCase name="ubyte_constructor_04" root="ubyte01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:unsignedByte()  - DFDL-23-087R">

    <tdml:document>
      <tdml:documentPart type="byte">31 30 30 </tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ubyte01>
          <string>100</string>
          <ubyte>100</ubyte>
        </ubyte01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <tdml:defineSchema name="booleanFunctions">
    <xs:include schemaLocation="org/apache/daffodil/xsd/DFDLGeneralFormat.dfdl.xsd"/>
    <dfdl:format ref="ex:GeneralFormat" initiator=""
      separator="," terminator="" leadingSkip="0" trailingSkip="0"
      textBidi="no" floating="no" byteOrder="bigEndian"
      alignment="1" alignmentUnits="bytes" fillByte="f" occursCountKind="implicit"
      truncateSpecifiedLengthString="no" ignoreCase="no" representation="text"
      lengthKind="delimited" nilValueDelimiterPolicy="both"
      emptyValueDelimiterPolicy="none" documentFinalTerminatorCanBeMissing="yes"
      initiatedContent="no" separatorSuppressionPolicy="anyEmpty" separatorPosition="infix" />

    <xs:element name="choice">
      <xs:complexType>
        <xs:choice>
          <xs:element name="string" type="xs:string" dfdl:lengthKind="delimited">
            <xs:annotation>
              <xs:appinfo source="http://www.ogf.org/dfdl/">
                <dfdl:discriminator><![CDATA[{ fn:true() }]]></dfdl:discriminator>
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element name="int" type="xs:int" dfdl:lengthKind="explicit" dfdl:length="3"/>
        </xs:choice>
      </xs:complexType>
    </xs:element>
  
    <xs:element name="root1">
      <xs:complexType>
        <xs:sequence dfdl:separator="|">
          <xs:element name="dataType" type="xs:string"/>
          <xs:element name="choice">
              <xs:complexType>
                <xs:choice>
                  <xs:element name="string" type="xs:string" dfdl:lengthKind="delimited">
                    <xs:annotation>
                      <xs:appinfo source="http://www.ogf.org/dfdl/">
                        <dfdl:discriminator><![CDATA[{ if (fn:lower-case(/ex:root1/ex:dataType) eq 'string') then fn:true() else fn:false() }]]></dfdl:discriminator>
                      </xs:appinfo>
                    </xs:annotation>
                  </xs:element>
                  <xs:element name="int" type="xs:int" dfdl:lengthKind="explicit" dfdl:length="3"/>
                </xs:choice>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

  <xs:element name="flags01">
    <xs:complexType>
      <xs:sequence dfdl:separator="|">
        <xs:element name="income" type="xs:int"/>
        <xs:element name="spending" type="xs:int"/>
        <xs:element name="areYouInDebt" type="xs:boolean" dfdl:inputValueCalc="{ if ( /ex:flags01/ex:income - /ex:flags01/ex:spending gt 0) then fn:false() else fn:true() }"/>
        <xs:element name="shouldYouBuyABoat" type="xs:boolean" dfdl:inputValueCalc="{ if ( /ex:flags01/ex:income - /ex:flags01/ex:spending gt 0) then fn:true() else fn:false() } "/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  
  <xs:element name="flags02">
    <xs:complexType>
      <xs:sequence dfdl:separator="">
        <xs:element name="password" type="xs:string"/>
        <xs:element name="passwordLen" type="xs:int" dfdl:inputValueCalc="{ fn:string-length(/ex:flags02/ex:password) }"/>
        <xs:element name="moreThan8Chars" type="xs:boolean" dfdl:inputValueCalc="{ if (xs:int(/ex:flags02/ex:passwordLen) gt 8) then fn:true() else fn:false() }"/>
        <xs:element name="lessThan16Chars" type="xs:boolean" dfdl:inputValueCalc="{ if (xs:int(/ex:flags02/ex:passwordLen) lt 16) then fn:true() else fn:false() }"/>
        <xs:element name="containsNumbers" type="xs:boolean" dfdl:inputValueCalc="{ if (fn:contains(/ex:flags02/ex:password, '0') or fn:contains(/ex:flags02/ex:password, '1') or fn:contains(/ex:flags02/ex:password, '2') or fn:contains(/ex:flags02/ex:password, '3') or fn:contains(/ex:flags02/ex:password, '4') or fn:contains(/ex:flags02/ex:password, '5') or fn:contains(/ex:flags02/ex:password, '6') or fn:contains(/ex:flags02/ex:password, '7') or fn:contains(/ex:flags02/ex:password, '8') or fn:contains(/ex:flags02/ex:password, '9')) then fn:true() else fn:false() }"/>
        <xs:element name="containsSpecial" type="xs:boolean" dfdl:inputValueCalc="{ if (fn:contains(/ex:flags02/ex:password, '!') or fn:contains(/ex:flags02/ex:password, '#') or fn:contains(/ex:flags02/ex:password, '$') or fn:contains(/ex:flags02/ex:password, '%') or fn:contains(/ex:flags02/ex:password, '&amp;') or fn:contains(/ex:flags02/ex:password, '&quot;') or fn:contains(/ex:flags02/ex:password, '*')) then fn:true() else fn:false() }"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  
  <xs:element name="not01" type="xs:boolean" dfdl:inputValueCalc="{ fn:not(fn:true()) }"/>                  <!-- !true = false -->
  <xs:element name="not02" type="xs:boolean" dfdl:inputValueCalc="{ fn:not(fn:not(fn:true())) }"/>          <!-- !!true = true -->
  <xs:element name="not03" type="xs:boolean" dfdl:inputValueCalc="{ fn:not(fn:not(fn:not(fn:false()))) }"/> <!-- !!!false = true -->

  <xs:element name="not04">
    <xs:complexType>
      <xs:sequence dfdl:separator="|">
        <xs:element name="nameVal" nillable="true" type="xs:string" dfdl:nilKind="literalValue" dfdl:nilValue="nil"/>
        <xs:element name="nameNotExist" type="xs:boolean" dfdl:inputValueCalc="{ fn:not(/ex:not04/ex:nameVal) }"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  
  <xs:element name="not05">
    <xs:complexType>
      <xs:sequence dfdl:separator="|">
        <xs:element name="seq">
          <xs:complexType>
            <xs:sequence dfdl:separator=",">
              <xs:element name="num" type="xs:int" minOccurs="0" maxOccurs="10"/>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name="seqNotExist" type="xs:boolean" dfdl:inputValueCalc="{ fn:not(/ex:not05/ex:seq/ex:num) }"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <xs:element name="not06">
    <xs:complexType>
      <xs:sequence dfdl:separator="">
        <xs:element name="bool" type="xs:boolean" dfdl:inputValueCalc="{ fn:false() }"/>
        <xs:element name="notBool" type="xs:boolean" dfdl:inputValueCalc="{ fn:not(xs:boolean(/ex:not06/ex:bool)) }"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  
  <xs:element name="not08">
    <xs:complexType>
      <xs:sequence dfdl:separator="|">
        <xs:element name="nameVal" nillable="true" type="xs:string" dfdl:nilKind="literalValue" dfdl:nilValue="nil"/>
        <xs:element name="nameNotExist" type="xs:boolean" dfdl:inputValueCalc="{ fn:not(/ex:not08/ex:nameVal) }"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  
  <xs:element name="not09">
    <xs:complexType>
      <xs:sequence dfdl:separator="|">
        <xs:element name="item" type="xs:string"/>
        <xs:element name="itemNotExist" type="xs:boolean" dfdl:inputValueCalc="{ fn:not(xs:string(/ex:not09/ex:item)) }"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  
  <xs:element name="not10">
    <xs:complexType>
      <xs:sequence dfdl:separator="|">
        <xs:element name="item" type="xs:string"/>
        <xs:element name="itemNotExist" type="xs:boolean" dfdl:inputValueCalc="{ fn:not(xs:string(/ex:not10/ex:item)) }"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  
  <xs:element name="not11">
    <xs:complexType>
      <xs:sequence dfdl:separator="|">
        <xs:element name="num" type="xs:float" dfdl:textStandardNaNRep="NaN"/>
        <xs:element name="numNotExist" type="xs:boolean" dfdl:inputValueCalc="{ fn:not(xs:float(/ex:not11/ex:num)) }"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  
  <xs:element name="not12" type="xs:boolean" dfdl:inputValueCalc="{ fn:not(xs:hexBinary('EFB2')) }" />
  <xs:element name="not13" type="xs:boolean" dfdl:inputValueCalc="{ fn:not() }" />
  
  <xs:element name="not14">
    <xs:complexType>
      <xs:sequence dfdl:separator="|">
        <xs:element name="num" type="xs:float" dfdl:textStandardNaNRep="it%SP;isn't%SP;a%SP;number"/>
        <xs:element name="numNotExist" type="xs:boolean" dfdl:inputValueCalc="{ fn:not(xs:float(../ex:num)) }"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  
    <xs:element name="nilled01">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="a" nillable="true" type="xs:string" dfdl:nilKind="literalValue" dfdl:nilValue="nil"/>
          <xs:element name="nilled" type="xs:boolean" dfdl:inputValueCalc="{ fn:nilled(/ex:nilled01/ex:a) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="nilled02">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="a" type="xs:string" />
          <xs:element name="nilled" type="xs:boolean" dfdl:inputValueCalc="{ fn:nilled(/ex:nilled02/ex:a) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="nilled03">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="item" type="xs:int" minOccurs="0" dfdl:lengthKind="explicit" dfdl:length="1" />
          <xs:element name="nilled" type="xs:boolean" dfdl:inputValueCalc="{ fn:nilled(../ex:item) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
  </tdml:defineSchema>
<!--
    Test Name: boolFunctionChoice_01
       Schema: booleanFunctions
         Root: choice
      Purpose: This test demonstrates the use of fn:true in a discriminator to force a choice branch.
-->

  <tdml:parserTestCase name="boolFunctionChoice_01" root="choice"
    model="booleanFunctions" description="Section 23 - Functions - fn:true - DFDL-23-091R">

    <tdml:document>
      <tdml:documentPart type="text">123</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <choice>
          <string>123</string>
        </choice>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: boolFunctionChoice_02
       Schema: booleanFunctions
         Root: root1
      Purpose: This test demonstrates the use of fn:true in a discriminator to force a choice branch based on previously-parsed data.
-->

  <tdml:parserTestCase name="boolFunctionChoice_02" root="root1"
    model="booleanFunctions" description="Section 23 - Functions - fn:true - DFDL-23-091R">

    <tdml:document>
      <tdml:documentPart type="text">int|123</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <root1>
          <dataType>int</dataType>
          <choice>
            <int>123</int>
          </choice>
        </root1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: boolFunctionChoice_03
       Schema: booleanFunctions
         Root: root1
      Purpose: This test demonstrates the use of fn:true in a discriminator to force a choice branch based on previously-parsed data.
-->

  <tdml:parserTestCase name="boolFunctionChoice_03" root="root1"
    model="booleanFunctions" description="Section 23 - Functions - fn:true - DFDL-23-091R">

    <tdml:document>
      <tdml:documentPart type="text">string|123</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <root1>
          <dataType>string</dataType>
          <choice>
            <string>123</string>
          </choice>
        </root1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: boolFlags_01
       Schema: booleanFunctions
         Root: flags01
      Purpose: This test demonstrates the use of fn:true to set a boolean value based on previously-parsed data.
-->

  <tdml:parserTestCase name="boolFlags_01" root="flags01"
    model="booleanFunctions" description="Section 23 - Functions - fn:true - DFDL-23-091R">

    <tdml:document>
      <tdml:documentPart type="text">40,000|55,000</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
      <flags01>
        <income>40000</income>
        <spending>55000</spending>
        <areYouInDebt>true</areYouInDebt>
        <shouldYouBuyABoat>false</shouldYouBuyABoat>
      </flags01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: boolFlags_02
       Schema: booleanFunctions
         Root: flags01
      Purpose: This test demonstrates the use of fn:true to set a boolean value based on previously-parsed data.
-->

  <tdml:parserTestCase name="boolFlags_02" root="flags01"
    model="booleanFunctions" description="Section 23 - Functions - fn:true - DFDL-23-091R">

    <tdml:document>
      <tdml:documentPart type="text">40,000|38,000</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
      <flags01>
        <income>40000</income>
        <spending>38000</spending>
        <areYouInDebt>false</areYouInDebt>
        <shouldYouBuyABoat>true</shouldYouBuyABoat>
      </flags01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: boolFlags_03
       Schema: booleanFunctions
         Root: flags02
      Purpose: This test demonstrates the use of fn:true to set a boolean value based on previously-parsed data.
-->

  <tdml:parserTestCase name="boolFlags_03" root="flags02"
    model="booleanFunctions" description="Section 23 - Functions - fn:true - DFDL-23-091R">

    <tdml:document>
      <tdml:documentPart type="text">badpassword</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
      <flags02>
        <password>badpassword</password>
        <passwordLen>11</passwordLen>
        <moreThan8Chars>true</moreThan8Chars>
        <lessThan16Chars>true</lessThan16Chars>
        <containsNumbers>false</containsNumbers>
        <containsSpecial>false</containsSpecial>
      </flags02>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: boolFlags_04
       Schema: booleanFunctions
         Root: flags02
      Purpose: This test demonstrates the use of fn:true to set a boolean value based on previously-parsed data.
-->

  <tdml:parserTestCase name="boolFlags_04" root="flags02"
    model="booleanFunctions" description="Section 23 - Functions - fn:true - DFDL-23-091R">

    <tdml:document>
      <tdml:documentPart type="text">Goo!dPa55w0rd*</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
      <flags02>
        <password>Goo!dPa55w0rd*</password>
        <passwordLen>14</passwordLen>
        <moreThan8Chars>true</moreThan8Chars>
        <lessThan16Chars>true</lessThan16Chars>
        <containsNumbers>true</containsNumbers>
        <containsSpecial>true</containsSpecial>
      </flags02>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: boolFlags_05
       Schema: booleanFunctions
         Root: flags02
      Purpose: This test demonstrates the use of fn:true to set a boolean value based on previously-parsed data.
-->

  <tdml:parserTestCase name="boolFlags_05" root="flags02"
    model="booleanFunctions" description="Section 23 - Functions - fn:true - DFDL-23-091R">

    <tdml:document>
      <tdml:documentPart type="text">short!</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
      <flags02>
        <password>short!</password>
        <passwordLen>6</passwordLen>
        <moreThan8Chars>false</moreThan8Chars>
        <lessThan16Chars>true</lessThan16Chars>
        <containsNumbers>false</containsNumbers>
        <containsSpecial>true</containsSpecial>
      </flags02>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: not_01
       Schema: booleanFunctions
         Root: not01
      Purpose: This test demonstrates the use of the fn:not function to invert the xs:boolean value of the argument
-->

  <tdml:parserTestCase name="not_01" root="not01"
    model="booleanFunctions" description="Section 23 - Functions - fn:not - DFDL-23-093R7">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <not01>false</not01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: not_02
       Schema: booleanFunctions
         Root: not02
      Purpose: This test demonstrates the use of the fn:not function to invert the xs:boolean value ofthe argument.
-->

  <tdml:parserTestCase name="not_02" root="not02"
    model="booleanFunctions" description="Section 23 - Functions - fn:not - DFDL-23-093R7">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <not02>true</not02>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: not_03
       Schema: booleanFunctions
         Root: not03
      Purpose: This test demonstrates the use of the fn:not function to invert the xs:boolean value of the argument.
-->

  <tdml:parserTestCase name="not_03" root="not03"
    model="booleanFunctions" description="Section 23 - Functions - fn:not - DFDL-23-093R7">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <not03>true</not03>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: not_04
       Schema: booleanFunctions
         Root: not04
      Purpose: This test demonstrates that the fn:not function returns true if arg is a node with nilled = true
-->

  <tdml:parserTestCase name="not_04" root="not04"
    model="booleanFunctions" description="Section 23 - Functions - fn:not - DFDL-23-093R1">

    <tdml:document>
      <tdml:documentPart type="text">nil</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <not04>
          <nameVal xsi:nil="true"/>
          <nameNotExist>true</nameNotExist>
        </not04>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: not_05
       Schema: booleanFunctions
         Root: not05
      Purpose: This test demonstrates that the fn:not function returns true if arg is an empty sequence
-->

  <tdml:parserTestCase name="not_05" root="not05"
    model="booleanFunctions" description="Section 23 - Functions - fn:not - DFDL-23-093R1">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <not05>
          <seq/>
          <seqNotExist>true</seqNotExist>
        </not05>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: not_06
       Schema: booleanFunctions
         Root: not06
      Purpose: This test demonstrates that if $arg is a value of type xs:boolean, fn:not returns the boolean inverse of $arg.
-->

  <tdml:parserTestCase name="not_06" root="not06"
    model="booleanFunctions" description="Section 23 - Functions - fn:not - DFDL-23-093R3">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <not06>
          <bool>false</bool>
          <notBool>true</notBool>
        </not06>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: not_07
       Schema: booleanFunctions
         Root: not05
      Purpose: This test demonstrates that if $arg is a sequence containing a node with [nilled] false, fn:not returnes false
-->

  <tdml:parserTestCase name="not_07" root="not05"
    model="booleanFunctions" description="Section 23 - Functions - fn:not - DFDL-23-093R2">

    <tdml:document>
      <tdml:documentPart type="text">1,2,3</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <not05>
          <seq>
            <num>1</num>
            <num>2</num>
            <num>3</num>
          </seq>
          <seqNotExist>false</seqNotExist>
        </not05>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: not_08
       Schema: booleanFunctions
         Root: not08
      Purpose: This test demonstrates that if $arg is a sequence containing a node with [nilled] false or [nilled] having no value, fn:not returnes false
-->

  <tdml:parserTestCase name="not_08" root="not08"
    model="booleanFunctions" description="Section 23 - Functions - fn:not - DFDL-23-093R2">

    <tdml:document>
      <tdml:documentPart type="text">Raphael</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <not08>
          <nameVal>Raphael</nameVal>     
          <nameNotExist>false</nameNotExist>
        </not08>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: not_09
       Schema: booleanFunctions
         Root: not09
      Purpose: This test demonstrates that if $arg is a value of type xs:string, fn:not returns true if the operant value has zero length
-->

  <tdml:parserTestCase name="not_09" root="not09"
    model="booleanFunctions" description="Section 23 - Functions - fn:not - DFDL-23-093R4">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <not09>
          <item></item>     
          <itemNotExist>true</itemNotExist>
        </not09>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: not_10
       Schema: booleanFunctions
         Root: not10
      Purpose: This test demonstrates that if $arg is a value of type xs:string, fn:not returns true if the operant value has zero length
-->

  <tdml:parserTestCase name="not_10" root="not10"
    model="booleanFunctions" description="Section 23 - Functions - fn:not - DFDL-23-093R4">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <not10>
          <item></item>     
          <itemNotExist>true</itemNotExist>
        </not10>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: not_11
       Schema: booleanFunctions
         Root: not11
      Purpose: This test demonstrates that if $arg is a value of any numeric type, fn:not returns true if the operand value is NaN.
-->

  <tdml:parserTestCase name="not_11" root="not11"
    model="booleanFunctions" description="Section 23 - Functions - fn:not - DFDL-23-093R5">

    <tdml:document>
      <tdml:documentPart type="text"><![CDATA[NaN]]></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <not11>
          <num>NaN</num>     
          <numNotExist>true</numNotExist>
        </not11>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: not_12
       Schema: booleanFunctions
         Root: not11
      Purpose: This test demonstrates that if $arg is a value of any numeric type, fn:not returns true if the operand value is numerically equal to zero.
-->

  <tdml:parserTestCase name="not_12" root="not11"
    model="booleanFunctions" description="Section 23 - Functions - fn:not - DFDL-23-093R5">

    <tdml:document>
      <tdml:documentPart type="text">0</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <not11>
          <num>0.0</num>     
          <numNotExist>true</numNotExist>
        </not11>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: not_13
       Schema: booleanFunctions
         Root: not11
      Purpose: This test demonstrates that if $arg is a value of any numeric type, fn:not returns false if the operand value is not NaN or numerically equal to zero.
-->

  <tdml:parserTestCase name="not_13" root="not11"
    model="booleanFunctions" description="Section 23 - Functions - fn:not - DFDL-23-093R5">

    <tdml:document>
      <tdml:documentPart type="text">43</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <not11>
          <num>43.0</num>     
          <numNotExist>false</numNotExist>
        </not11>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: not_14
       Schema: booleanFunctions
         Root: not12
      Purpose: This test demonstrates that if none of the previous cases apply, fn:not raises a processing error
-->

  <tdml:parserTestCase name="not_14" root="not12"
    model="booleanFunctions" description="Section 23 - Functions - fn:not - DFDL-23-093R6">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
    Test Name: not_15
       Schema: booleanFunctions
         Root: not13
      Purpose: This test demonstrates that if none of the previous cases apply, fn:not raises a processing error
-->

  <tdml:parserTestCase name="not_15" root="not13"
    model="booleanFunctions" description="Section 23 - Functions - fn:not - DFDL-23-093R6">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>function</tdml:error>
      <tdml:error>not</tdml:error>
      <tdml:error>argument</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
    Test Name: not_16
       Schema: booleanFunctions
         Root: not14
      Purpose: This test demonstrates that if $arg is a value of any numeric type, fn:not returns true if the operand value is NaN.
-->

  <tdml:parserTestCase name="not_16" root="not14"
    model="booleanFunctions" description="Section 23 - Functions - fn:not - DFDL-23-093R5">

    <tdml:document>
      <tdml:documentPart type="text"><![CDATA[it isn't a number]]></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <not14>
          <num>NaN</num>     
          <numNotExist>true</numNotExist>
        </not14>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: empty_01
       Schema: XPathFunctions
         Root: empty01
      Purpose: This test demonstrates the empty() function. In this case the function is referencing a sequence that is
               not empty, and should be set to false.
-->

  <tdml:parserTestCase name="empty_01" root="empty01"
    model="XPathFunctions" description="Section 23 - Functions - fn:empty - DFDL-23-121R">

    <tdml:document>
      <tdml:documentPart type="text">1,2,3,4</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <empty01>
          <seq>
            <item>1</item>
            <item>2</item>
            <item>3</item>
            <item>4</item>
          </seq>
          <empty>false</empty>
        </empty01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: empty_02
       Schema: XPathFunctions
         Root: empty01
      Purpose: This test demonstrates the empty() function. In this case the function is referencing
               a sequence that is empty, and should be true.
-->

  <tdml:parserTestCase name="empty_02" root="empty01"
    model="XPathFunctions" description="Section 23 - Functions - fn:empty - DFDL-23-121R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <empty01>
          <seq/>
          <empty>true</empty>
        </empty01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: empty_03
       Schema: XPathFunctions
         Root: empty02
      Purpose: This test demonstrates the empty() function. In this case the function is referencing a 
               sequence that is not empty, and should be false.
-->

  <tdml:parserTestCase name="empty_03" root="empty02"
    model="XPathFunctions" description="Section 23 - Functions - fn:empty - DFDL-23-121R">

    <tdml:document>
      <tdml:documentPart type="text">12345,12345,12345</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <empty02>
          <seq>
            <item>12345</item>
            <item>12345</item>
            <item>12345</item>
          </seq>
          <empty>false</empty>
        </empty02>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: empty_04
       Schema: XPathFunctions
         Root: empty02
      Purpose: This test demonstrates the empty() function. In this case the function is referencing a
               sequence that is empty, and should be true.
-->

  <tdml:parserTestCase name="empty_04" root="empty02"
    model="XPathFunctions" description="Section 23 - Functions - fn:empty - DFDL-23-121R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <empty02>
          <seq/>
          <empty>true</empty>
        </empty02>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: empty_05
       Schema: XPathFunctions
         Root: empty03
      Purpose: This test demonstrates the empty() function. In this case the function is referencing a
               sequence that is empty, and should be true.
-->

  <tdml:parserTestCase name="empty_05" root="empty03"
    model="XPathFunctions" description="Section 23 - Functions - fn:empty - DFDL-23-121R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>inputValueCalc property can not appear on array elements</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
    Test Name: empty_06
       Schema: XPathFunctions
         Root: empty04
      Purpose: This test demonstrates the empty() function. In this case, the empty function is setting a 
               discriminator to false, which dictates the choice branch selected.
-->

  <tdml:parserTestCase name="empty_06" root="empty04"
    model="XPathFunctions" description="Section 23 - Functions - fn:empty - DFDL-23-121R">

    <tdml:document>
      <tdml:documentPart type="text">600,601,602|Reuben,BLT,Club</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <empty04>
          <queue>
            <order_num>600</order_num>
            <order_num>601</order_num>
            <order_num>602</order_num>
          </queue>
          <choice>
            <orders>
              <order>Reuben</order>
              <order>BLT</order>
              <order>Club</order>
            </orders>
          </choice>
        </empty04>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: empty_07
       Schema: XPathFunctions
         Root: empty04
      Purpose: This test demonstrates the empty() function. In this case, the empty function is setting a 
               discriminator to true, which dictates the choice branch selected.
-->

  <tdml:parserTestCase name="empty_07" root="empty04"
    model="XPathFunctions" description="Section 23 - Functions - fn:empty - DFDL-23-121R">

    <tdml:document>
      <tdml:documentPart type="text">|</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <empty04>
          <queue/>
          <choice>
            <empty>There is no one waiting right now</empty>
          </choice>
        </empty04>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: empty_08
       Schema: XPathFunctions
         Root: empty05
      Purpose: This test demonstrates the empty() function when it is not provided any arguments
-->

  <tdml:parserTestCase name="empty_08" root="empty05"
    model="XPathFunctions" description="Section 23 - Functions - fn:empty - DFDL-23-121R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>empty</tdml:error>
      <tdml:error>function requires 1 argument(s)</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
    Test Name: empty_09
       Schema: XPathFunctions
         Root: empty06
      Purpose: This test demonstrates the empty() function when it is passed an element that does not exist.
-->

  <tdml:parserTestCase name="empty_09" root="empty06"
    model="XPathFunctions" description="Section 23 - Functions - fn:empty - DFDL-23-121R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>No element corresponding to step ex:IDONOTEXIST</tdml:error>
      <tdml:error>found</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
    Test Name: exists_01
       Schema: XPathFunctions
         Root: exists01
      Purpose: This test demonstrates the exists() function. In this case the function is referencing a sequence that
               exists, and should be set to true.
-->

  <tdml:parserTestCase name="exists_01" root="exists01"
    model="XPathFunctions" description="Section 23 - Functions - fn:exists - DFDL-23-122R">

    <tdml:document>
      <tdml:documentPart type="text">1,2,3,4</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <exists01>
          <seq>
            <item>1</item>
            <item>2</item>
            <item>3</item>
            <item>4</item>
          </seq>
          <exists>true</exists>
        </exists01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: exists_02
       Schema: XPathFunctions
         Root: exists01
      Purpose: This test demonstrates the exists() function. In this case the function is referencing
               a sequence that does not exist, and should be false.
-->

  <tdml:parserTestCase name="exists_02" root="exists01"
    model="XPathFunctions" description="Section 23 - Functions - fn:exists - DFDL-23-122R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <exists01>
          <seq/>
          <exists>false</exists>
        </exists01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: exists_03
       Schema: XPathFunctions
         Root: exists02
      Purpose: This test demonstrates the exists() function. In this case the function is referencing a 
               sequence that exists, and should be true.
-->

  <tdml:parserTestCase name="exists_03" root="exists02"
    model="XPathFunctions" description="Section 23 - Functions - fn:exists - DFDL-23-122R">

    <tdml:document>
      <tdml:documentPart type="text">12345,12345,12345</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <exists02>
          <seq>
            <item>12345</item>
            <item>12345</item>
            <item>12345</item>
          </seq>
          <exists>true</exists>
        </exists02>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: exists_04
       Schema: XPathFunctions
         Root: exists02
      Purpose: This test demonstrates the exists() function. In this case the function is referencing a
               sequence that does not exist, and should be false.
-->

  <tdml:parserTestCase name="exists_04" root="exists02"
    model="XPathFunctions" description="Section 23 - Functions - fn:exists - DFDL-23-122R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <exists02>
          <seq/>
          <exists>false</exists>
        </exists02>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: exists_05
       Schema: XPathFunctions
         Root: exists03
      Purpose: This test demonstrates the exists() function. In this case the function is referencing a
               sequence that does not exist, and should be false.
-->

  <tdml:parserTestCase name="exists_05" root="exists03"
    model="XPathFunctions" description="Section 23 - Functions - fn:exists - DFDL-23-122R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>inputValueCalc property can not appear on array elements</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
    Test Name: exists_06
       Schema: XPathFunctions
         Root: exists04
      Purpose: This test demonstrates the exists() function. In this case, the exists function is setting a 
               discriminator to false, which dictates the choice branch selected.
-->

  <tdml:parserTestCase name="exists_06" root="exists04"
    model="XPathFunctions" description="Section 23 - Functions - fn:exists - DFDL-23-122R">

    <tdml:document>
      <tdml:documentPart type="text">600,601,602|Reuben,BLT,Club</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <exists04>
          <queue>
            <order_num>600</order_num>
            <order_num>601</order_num>
            <order_num>602</order_num>
          </queue>
          <choice>
            <orders>
              <order>Reuben</order>
              <order>BLT</order>
              <order>Club</order>
            </orders>
          </choice>
        </exists04>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: exists_07
       Schema: XPathFunctions
         Root: exists04
      Purpose: This test demonstrates the exists() function. In this case, the exists function is setting a 
               discriminator to false, which dictates the choice branch selected.
-->

  <tdml:parserTestCase name="exists_07" root="exists04"
    model="XPathFunctions" description="Section 23 - Functions - fn:exists - DFDL-23-122R">

    <tdml:document>
      <tdml:documentPart type="text">|</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <exists04>
          <queue/>
          <choice>
            <exists>There is no one waiting right now</exists>
          </choice>
        </exists04>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: exists_08
       Schema: XPathFunctions
         Root: exists05
      Purpose: This test demonstrates the exists() function when it is not provided any arguments
-->

  <tdml:parserTestCase name="exists_08" root="exists05"
    model="XPathFunctions" description="Section 23 - Functions - fn:exists - DFDL-23-122R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>exists</tdml:error>
      <tdml:error>argument</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
    Test Name: exists_09
       Schema: XPathFunctions
         Root: exists06
      Purpose: This test demonstrates the exists() function when it is passed an element that does not exist.
-->

  <tdml:parserTestCase name="exists_09" root="exists06"
    model="XPathFunctions" description="Section 23 - Functions - fn:exists - DFDL-23-122R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>No element corresponding to step ex:IDONOTEXIST</tdml:error>
      <tdml:error>found</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
    Test Name: exists_10
       Schema: XPathFunctions
         Root: exists07
      Purpose: This test demonstrates the exists() function when referencing hidden elements
-->

  <tdml:parserTestCase name="exists_10" root="exists07"
    model="XPathFunctions" description="Section 23 - Functions - fn:exists - DFDL-23-122R">

    <tdml:document>
      <tdml:documentPart type="text">Dan,ssn:313-42-1999|dob:04/14/1959</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <exists07>
          <info>
            <name>Dan</name>
            <data/>
          </info>
          <passwordExists>false</passwordExists>
          <dobExists>true</dobExists>
          <ssnExists>true</ssnExists>
        </exists07>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: exists_11
       Schema: XPathFunctions
         Root: exists08
      Purpose: This test demonstrates the exists() function. In this case the function is referencing an array index that
               exists, and should be set to true.
-->

  <tdml:parserTestCase name="exists_11" root="exists08"
    model="XPathFunctions" description="Section 23 - Functions - fn:exists - DFDL-23-122R">

    <tdml:document>
      <tdml:documentPart type="text">1,2,3,4,5,6,7,8,9,10</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <exists08>
          <seq>
            <item>1</item>
            <item>2</item>
            <item>3</item>
            <item>4</item>
            <item>5</item>
            <item>6</item>
            <item>7</item>
            <item>8</item>
            <item>9</item>
            <item>10</item>
          </seq>
          <exists>true</exists>
        </exists08>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: exists_12
       Schema: XPathFunctions
         Root: exists08
      Purpose: This test demonstrates the exists() function. In this case the function is referencing an array index that
               does not exist, and should be set to false.
-->

  <tdml:parserTestCase name="exists_12" root="exists08"
    model="XPathFunctions" description="Section 23 - Functions - fn:exists - DFDL-23-122R">

    <tdml:document>
      <tdml:documentPart type="text">1,2,3,4,5,6,7,8,9</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <exists08>
          <seq>
            <item>1</item>
            <item>2</item>
            <item>3</item>
            <item>4</item>
            <item>5</item>
            <item>6</item>
            <item>7</item>
            <item>8</item>
            <item>9</item>
          </seq>
          <exists>false</exists>
        </exists08>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: exactly_one_01
       Schema: XPathFunctions
         Root: exactly-one01
      Purpose: This test demonstrates the exactly-one() function. In this case there is exactly one item so the function returns true.
-->

  <tdml:parserTestCase name="exactly_one_01" root="exactly-one01"
    model="XPathFunctions" description="Section 23 - Functions - fn:exactly-one - DFDL-23-123R">

    <tdml:document>
      <tdml:documentPart type="text">1</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <exactly-one01>
          <seq>
            <item>1</item>
          </seq>
          <exactly-one>1</exactly-one>
        </exactly-one01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: exactly_one_02
       Schema: XPathFunctions
         Root: exactly-one01
      Purpose: This test demonstrates the exactly-one() function. In this case there is more than one item.
-->

  <tdml:parserTestCase name="exactly_one_02" root="exactly-one01"
    model="XPathFunctions" description="Section 23 - Functions - fn:exactly-one - DFDL-23-123R">

    <tdml:document>
      <tdml:documentPart type="text">1,2,3</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>does not contain</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
    Test Name: exactly_one_03
       Schema: XPathFunctions
         Root: exactly-one01
      Purpose: This test demonstrates the exactly-one() function. In this case there is less than one item.
-->

  <tdml:parserTestCase name="exactly_one_03" root="exactly-one01"
    model="XPathFunctions" description="Section 23 - Functions - fn:exactly-one - DFDL-23-123R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>does not contain</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
    Test Name: exactly_one_04
       Schema: XPathFunctions
         Root: exactly-one02
      Purpose: This test demonstrates the exactly-one() function. In this case we are not providing any arguments.
-->

  <tdml:parserTestCase name="exactly_one_04" root="exactly-one02"
    model="XPathFunctions" description="Section 23 - Functions - fn:exactly-one - DFDL-23-123R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>exactly-one</tdml:error>
      <tdml:error>argument</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
    Test Name: exactly_one_05
       Schema: XPathFunctions
         Root: exactly-one03
      Purpose: This test demonstrates the exactly-one() function.
-->

  <tdml:parserTestCase name="exactly_one_05" root="exactly-one03"
    model="XPathFunctions" description="Section 23 - Functions - fn:exactly-one - DFDL-23-123R">

    <tdml:document>
      <tdml:documentPart type="text">name:Larry|</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <exactly-one03>
          <seq>
            <name>Larry</name>
          </seq>
          <choice>
            <notEnough>not enough info</notEnough>
          </choice>
        </exactly-one03>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: exactly_one_06
       Schema: XPathFunctions
         Root: exactly-one03
      Purpose: This test demonstrates the exactly-one() function.
-->

  <tdml:parserTestCase name="exactly_one_06" root="exactly-one03"
    model="XPathFunctions" description="Section 23 - Functions - fn:exactly-one - DFDL-23-123R">

    <tdml:document>
      <tdml:documentPart type="text">name:Larry,name:Smith|</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <exactly-one03>
          <seq>
            <name>Larry</name>
            <name>Smith</name>
          </seq>
          <choice>
            <enough>enough</enough>
          </choice>
        </exactly-one03>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: exactly_one_07
       Schema: XPathFunctions
         Root: exactly-one04
      Purpose: This test demonstrates the exactly-one() function.
-->

  <tdml:parserTestCase name="exactly_one_07" root="exactly-one04"
    model="XPathFunctions" description="Section 23 - Functions - fn:exactly-one - DFDL-23-123R">

    <tdml:document>
      <tdml:documentPart type="text">first:Larry,last:Smith|</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <exactly-one03>
          <seq>
            <name>Larry</name>
            <name>Smith</name>
          </seq>
          <choice>
            <enough>enough</enough>
          </choice>
        </exactly-one03>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: count_01
       Schema: XPathFunctions
         Root: count01
      Purpose: This test demonstrates the count() function.
-->

  <tdml:parserTestCase name="count_01" root="count01"
    model="XPathFunctions" description="Section 23 - Functions - fn:count - DFDL-23-124R">

    <tdml:document>
      <tdml:documentPart type="text">1,2,3,4,5,6,7,8,9,10,11,12,13,14</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <count01>
          <seq>
            <item>1</item>
            <item>2</item>
            <item>3</item>
            <item>4</item>
            <item>5</item>
            <item>6</item>
            <item>7</item>
            <item>8</item>
            <item>9</item>
            <item>10</item>
            <item>11</item>
            <item>12</item>
            <item>13</item>
            <item>14</item>
          </seq>
          <count>14</count>
        </count01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: count_02
       Schema: XPathFunctions
         Root: count01
      Purpose: This test demonstrates the count() function.
-->

  <tdml:parserTestCase name="count_02" root="count01"
    model="XPathFunctions" description="Section 23 - Functions - fn:count - DFDL-23-124R">

    <tdml:document>
      <tdml:documentPart type="text">15</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <count01>
          <seq>
            <item>15</item>
          </seq>
          <count>1</count>
        </count01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: count_03
       Schema: XPathFunctions
         Root: count02
      Purpose: This test demonstrates the count() function.
-->

  <tdml:parserTestCase name="count_03" root="count02"
    model="XPathFunctions" description="Section 23 - Functions - fn:count - DFDL-23-124R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <count02>
          <calced>calculated string</calced>
          <count>1</count>
        </count02>
      </tdml:dfdlInfoset>
    </tdml:infoset>
    <tdml:warnings>
      <tdml:warning>Runtime Schema Definition Warning</tdml:warning>
      <tdml:warning>fn:exists</tdml:warning>
    </tdml:warnings>
  </tdml:parserTestCase>

<!--
    Test Name: count_03b
       Schema: XPathFunctions
         Root: count02b
      Purpose: This test demonstrates the count() function.
-->

  <tdml:parserTestCase name="count_03b" root="count02b"
    model="XPathFunctions" description="Section 23 - Functions - fn:count - DFDL-23-124R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <count02b>
          <str>calculated string</str>
          <calced>calculated string</calced>
          <count>1</count>
        </count02b>
      </tdml:dfdlInfoset>
    </tdml:infoset>
    <tdml:warnings>
      <tdml:warning>Runtime Schema Definition Warning</tdml:warning>
      <tdml:warning>fn:exists</tdml:warning>
    </tdml:warnings>
  </tdml:parserTestCase>

<!--
    Test Name: count_04
       Schema: XPathFunctions
         Root: count01
      Purpose: This test demonstrates the count() function.
-->

  <tdml:parserTestCase name="count_04" root="count01"
    model="XPathFunctions" description="Section 23 - Functions - fn:count - DFDL-23-124R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <count01>
          <seq/>
          <count>0</count>
        </count01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: count_05
       Schema: XPathFunctions
         Root: count03
      Purpose: This test demonstrates the count() function.
-->

  <tdml:parserTestCase name="count_05" root="count03"
    model="XPathFunctions" description="Section 23 - Functions - fn:count - DFDL-23-124R">

    <tdml:document>
      <tdml:documentPart type="text">B:6,B:1,P:3,B:6,B:2,P:3,P:3</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <count03>
          <scores>
            <bobcats>6</bobcats>
            <bobcats>1</bobcats>
            <bobcats>6</bobcats>
            <bobcats>2</bobcats>
            <pirates>3</pirates>
            <pirates>3</pirates>
            <pirates>3</pirates>
          </scores>
          <bobcatScoreCount>4</bobcatScoreCount>
          <pirateScoreCount>3</pirateScoreCount>
        </count03>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: count_05b
       Schema: XPathFunctions
         Root: count03b
      Purpose: This test demonstrates the count() function.
-->

  <tdml:parserTestCase name="count_05b" root="count03b"
    model="XPathFunctions" description="Section 23 - Functions - fn:count - DFDL-23-124R">

    <tdml:document>
      <tdml:documentPart type="text">B:6,B:1,P:3,B:6,B:2,P:3,P:3</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <count03>
          <scores>
            <bobcats>6</bobcats>
            <bobcats>1</bobcats>
            <bobcats>6</bobcats>
            <bobcats>2</bobcats>
            <pirates>3</pirates>
            <pirates>3</pirates>
            <pirates>3</pirates>
          </scores>
          <bobcatScoreCount>4</bobcatScoreCount>
          <pirateScoreCount>3</pirateScoreCount>
        </count03>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: count_05c
       Schema: XPathFunctions
         Root: count03c
      Purpose: This test demonstrates the count() function.
-->

  <tdml:parserTestCase name="count_05c" root="count03c"
    model="XPathFunctions" description="Section 23 - Functions - fn:count - DFDL-23-124R">

    <tdml:document>
      <tdml:documentPart type="text">B:6,B:1,B:6,B:2,P:3,P:3</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <count03c>
          <scores>
            <bobcats>6</bobcats>
            <bobcats>1</bobcats>
            <bobcats>6</bobcats>
            <bobcats>2</bobcats>
            <pirates>3</pirates>
            <pirates>3</pirates>
          </scores>
          <bobcatScoreCount>4</bobcatScoreCount>
          <pirateScoreCount>2</pirateScoreCount>
        </count03c>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: count_06
       Schema: XPathFunctions
         Root: count03
      Purpose: This test demonstrates the count() function.
-->

  <tdml:parserTestCase name="count_06" root="count03"
    model="XPathFunctions" description="Section 23 - Functions - fn:count - DFDL-23-124R">

    <tdml:document>
      <tdml:documentPart type="text">B:1,B:1,B:2</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <count03>
          <scores>
            <bobcats>1</bobcats>
            <bobcats>1</bobcats>
            <bobcats>2</bobcats>
          </scores>
          <bobcatScoreCount>3</bobcatScoreCount>
          <pirateScoreCount>0</pirateScoreCount>
        </count03>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: count_06b
       Schema: XPathFunctions
         Root: count03c
      Purpose: This test demonstrates the count() function.
-->

  <tdml:parserTestCase name="count_06b" root="count03c"
    model="XPathFunctions" description="Section 23 - Functions - fn:count - DFDL-23-124R">

    <tdml:document>
      <tdml:documentPart type="text">B:1,B:1,B:2</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <count03c>
          <scores>
            <bobcats>1</bobcats>
            <bobcats>1</bobcats>
            <bobcats>2</bobcats>
          </scores>
          <bobcatScoreCount>3</bobcatScoreCount>
          <pirateScoreCount>0</pirateScoreCount>
        </count03c>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: count_07
       Schema: XPathFunctions
         Root: count04
      Purpose: This test demonstrates the count() function, and how it handles no arguments
-->

  <tdml:parserTestCase name="count_07" root="count04"
    model="XPathFunctions" description="Section 23 - Functions - fn:count - DFDL-23-124R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>count</tdml:error>
      <tdml:error>argument</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
    Test Name: count_08
       Schema: XPathFunctions
         Root: count05
      Purpose: This test demonstrates the count() function, and how it handles being passed too many arguments
-->

  <tdml:parserTestCase name="count_08" root="count05"
    model="XPathFunctions" description="Section 23 - Functions - fn:count - DFDL-23-124R">

    <tdml:document>
      <tdml:documentPart type="text">1,2,3</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>count</tdml:error>
      <tdml:error>argument</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
    Test Name: count_08b
       Schema: XPathFunctions
         Root: count05b
      Purpose: This test demonstrates the count() function, and how it handles being passed too many arguments
-->

  <tdml:parserTestCase name="count_08b" root="count05b"
    model="XPathFunctions" description="Section 23 - Functions - fn:count - DFDL-23-124R">

    <tdml:document>
      <tdml:documentPart type="text">1,2,3</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>count</tdml:error>
      <tdml:error>argument</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
    Test Name: local_name_01
       Schema: XPathFunctions
         Root: local-name01
      Purpose: This test demonstrates the local-name() function when provided an argument
-->

  <tdml:parserTestCase name="local_name_01" root="local-name01"
    model="XPathFunctions" description="Section 23 - Functions - fn:local-name - DFDL-23-125R">

    <tdml:document>
      <tdml:documentPart type="text">55</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <local-name01>
          <inty>55</inty>
          <local>inty</local>
        </local-name01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: local_name_02
       Schema: XPathFunctions
         Root: local-name02
      Purpose: This test demonstrates the local-name() function when provided an argument
-->

  <tdml:parserTestCase name="local_name_02" root="local-name02"
    model="XPathFunctions" description="Section 23 - Functions - fn:local-name - DFDL-23-125R">

    <tdml:document>
      <tdml:documentPart type="text">dummy:string</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <local-name02>
          <dummy>string</dummy>
          <local>dummy</local>
        </local-name02>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: local_name_03
       Schema: XPathFunctions
         Root: local-name03
      Purpose: This test demonstrates the local-name() function when provided no argument
-->

  <tdml:parserTestCase name="local_name_03" root="local-name03"
    model="XPathFunctions" description="Section 23 - Functions - fn:local-name - DFDL-23-125R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <local-name03>local-name03</local-name03>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: local_name_04
       Schema: XPathFunctions
         Root: local-name04
      Purpose: This test demonstrates the local-name() function
-->

  <tdml:parserTestCase name="local_name_04" root="local-name04"
    model="XPathFunctions" description="Section 23 - Functions - fn:local-name - DFDL-23-125R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <local-name04>
          <local>local-name04</local>
        </local-name04>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: local_name_05
       Schema: XPathFunctions
         Root: local-name05
      Purpose: This test demonstrates the local-name() function
-->

  <tdml:parserTestCase name="local_name_05" root="local-name05"
    model="XPathFunctions" description="Section 23 - Functions - fn:local-name - DFDL-23-125R">

    <tdml:document>
      <tdml:documentPart type="text">Brandon|Reginald|Barry|Bob|Rory</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <local-name05>
          <entry>
            <blue>
              <player>Brandon</player>
              <team>blue</team>
            </blue>
          </entry>
          <entry>
            <red>
              <player>Reginald</player>
              <team>red</team>
            </red>
          </entry>
          <entry>
            <blue>
              <player>Barry</player>
              <team>blue</team>
            </blue>
          </entry>
          <entry>
            <blue>
            <player>Bob</player>
            <team>blue</team>
            </blue>
          </entry>
          <entry>
            <red>
              <player>Rory</player>
              <team>red</team>
            </red>
          </entry>
        </local-name05>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: local_name_06
       Schema: XPathFunctions
         Root: local-name06
      Purpose: This test demonstrates the local-name() function
-->

  <tdml:parserTestCase name="local_name_06" root="local-name06"
    model="XPathFunctions" description="Section 23 - Functions - fn:local-name - DFDL-23-125R">

    <tdml:document>
      <tdml:documentPart type="text">55,63,77</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Placeholder</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
    Test Name: local_name_07
       Schema: XPathFunctions
         Root: local-name07
      Purpose: This test demonstrates the local-name() function
-->

  <tdml:parserTestCase name="local_name_07" root="local-name07"
    model="XPathFunctions" description="Section 23 - Functions - fn:local-name - DFDL-23-125R">

    <tdml:document>
      <tdml:documentPart type="text">Dan,ssn:313-42-1999|dob:04/14/195|pw:Pa55w0rd</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <local-name07>
          <info>
            <name>Dan</name>
            <data/>
          </info>
          <provided1>password</provided1>
          <provided2>dob</provided2>
          <provided3>ssn</provided3>
        </local-name07>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>

<!--
    Test Name: namespace_uri_01
       Schema: XPathFunctions
         Root: e1
      Purpose: This test demonstrates the namespace-uri() function
-->

  <tdml:parserTestCase name="namespace_uri_01" root="e1"
    model="home_schema.dfdl.xsd" description="Section 23 - Functions - fn:namespace-uri() - DFDL-23-126R">

    <tdml:document>
      <tdml:documentPart type="text">1:123</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e1>
          <two>123</two>
          <uri1>http://home.com</uri1>
          <uri2>http://first.com</uri2>
        </e1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: namespace_uri_02
       Schema: home_schema.dfdl.xsd
         Root: e2
      Purpose: This test demonstrates the namespace-uri() function
-->

  <tdml:parserTestCase name="namespace_uri_02" root="e2"
    model="home_schema.dfdl.xsd" description="Section 23 - Functions - fn:namespace-uri() - DFDL-23-126R">

    <tdml:document>
      <tdml:documentPart type="text">3:data</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e2>
          <e1>
            <three>data</three>
          </e1>
          <uri>http://first.com</uri>
          <uri2>http://second.com</uri2>
        </e2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: namespace_uri_03
       Schema: XPathFunctions
         Root: namespace-uri01
      Purpose: This test demonstrates the namespace-uri() function
-->

  <tdml:parserTestCase name="namespace_uri_03" root="namespace-uri01"
    model="XPathFunctions" description="Section 23 - Functions - fn:namespace-uri() - DFDL-23-126R">

    <tdml:document>
      <tdml:documentPart type="text">123</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <namespace-uri01>
          <inty>123</inty>
          <local>http://example.com</local>
        </namespace-uri01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: namespace_uri_04
       Schema: XPathFunctions
         Root: namespace-uri02
      Purpose: This test demonstrates the namespace-uri() function
-->

  <tdml:parserTestCase name="namespace_uri_04" root="namespace-uri02"
    model="XPathFunctions" description="Section 23 - Functions - fn:namespace-uri() - DFDL-23-126R">

    <tdml:document>
      <tdml:documentPart type="text">123</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <namespace-uri02>
          <inty>123</inty>
          <local>http://example.com</local>
        </namespace-uri02>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: namespace_uri_05
       Schema: home_schema.dfdl.xsd
         Root: e3
      Purpose: This test demonstrates the namespace-uri() function
-->

  <tdml:parserTestCase name="namespace_uri_05" root="e3"
    model="home_schema.dfdl.xsd" description="Section 23 - Functions - fn:namespace-uri() - DFDL-23-126R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e3>http://home.com</e3>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
    Test Name: namespace_uri_06
       Schema: home_schema.dfdl.xsd
         Root: e4
      Purpose: This test demonstrates the namespace-uri() function
-->

  <tdml:parserTestCase name="namespace_uri_06" root="e4"
    model="home_schema.dfdl.xsd" description="Section 23 - Functions - fn:namespace-uri() - DFDL-23-126R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e4>
          <e2>http://first.com</e2>
        </e4>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
<!--
    Test Name: nilled_01
       Schema: booleanFunctions
         Root: nilled01
      Purpose: This test demonstrates that the fn:nilled function returns true if arg is a node with xsi:nil = true
-->

  <tdml:parserTestCase name="nilled_01" root="nilled01"
    model="booleanFunctions" description="Section 23 - Functions - fn:nilled - DFDL-23-129R">

    <tdml:document>
      <tdml:documentPart type="text">nil</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <nilled01>
          <a xsi:nil="true"/>
          <nilled>true</nilled>
        </nilled01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
<!--
    Test Name: nilled_02
       Schema: booleanFunctions
         Root: nilled01
      Purpose: This test demonstrates that the fn:nilled function returns false if arg is a node with xsi:nil = false
-->

  <tdml:parserTestCase name="nilled_02" root="nilled01"
    model="booleanFunctions" description="Section 23 - Functions - fn:nilled - DFDL-23-129R">

    <tdml:document>
      <tdml:documentPart type="text">test</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <nilled01>
          <a>test</a>
          <nilled>false</nilled>
        </nilled01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
<!--
    Test Name: nilled_03
       Schema: booleanFunctions
         Root: nilled03
      Purpose: This test demonstrates that the fn:nilled function causes and SDE if arg does not exist
-->

  <tdml:parserTestCase name="nilled_03" root="nilled03"
    model="booleanFunctions" description="Section 23 - Functions - fn:nilled - DFDL-23-129R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>item</tdml:error>
      <tdml:error>does not exist</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: date_constructor_02a
       Schema: constructorSchema
         Root: date01
      Purpose: This test demonstrates the use of the xs:date constructor function and its ability to
               construct a date from a string.
  -->

  <tdml:parserTestCase name="date_constructor_02a" root="date01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:date()  - DFDL-23-076R">

    <tdml:document>
      <tdml:documentPart type="text">1991-03-04</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <date01>
          <string>1991-03-04</string>
          <date>1991-03-04+00:00</date>
        </date01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: date_constructor_03a
       Schema: constructorSchema
         Root: date01
      Purpose: This test demonstrates the use of the xs:date constructor function and its ability to
               construct a date from a string.
  -->

  <tdml:parserTestCase name="date_constructor_03a" root="date01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:date()  - DFDL-23-076R">

    <tdml:document>
      <tdml:documentPart type="text">1991-03-045</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <!-- <tdml:error>Parse Error</tdml:error>
      <tdml:error>Invalid date "1991-03-045" (Day must be two digits)</tdml:error> -->
      <tdml:error>XSDate failed to convert "1991-03-045" to xs:date.</tdml:error>
      <tdml:error>DAY_OF_MONTH=45, valid range=1..31</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: date_constructor_05
       Schema: constructorSchema
         Root: date02
      Purpose: This test demonstrates the use of the xs:date constructor function and its ability to
               construct a date from a string.
  -->

  <tdml:parserTestCase name="date_constructor_05" root="date02" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:date()  - DFDL-23-076R">

    <tdml:document>
      <tdml:documentPart type="text">2013-03-04</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <date02>
          <string>2013-03-04</string>
          <date>2013-03-04</date>
        </date02>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: date_constructor_06
       Schema: constructorSchema
         Root: date03
      Purpose: This test demonstrates the use of the xs:date constructor function and its inability to
               cast xs:time to xs:date.
  -->

  <tdml:parserTestCase name="date_constructor_06" root="date03" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:date()  - DFDL-23-076R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>Casting from xs:time to xs:date can never succeed</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: date_constructor_07
       Schema: constructorSchema
         Root: date04
      Purpose: This test demonstrates the use of the xs:date constructor function and its ability to
               cast xs:date to xs:date.
  -->

  <tdml:parserTestCase name="date_constructor_07" root="date04" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:date()  - DFDL-23-076R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
    	<tdml:dfdlInfoset>
    		<ex:date04>2014-10-23</ex:date04>
    	</tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: date_constructor_08
       Schema: constructorSchema
         Root: date05
      Purpose: This test demonstrates the use of the xs:date constructor function and its ability to
               cast xs:dateTime to xs:date.
  -->

  <tdml:parserTestCase name="date_constructor_08" root="date05" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:date()  - DFDL-23-076R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
    	<tdml:dfdlInfoset>
    		<ex:date05>2014-10-23-05:00</ex:date05>
    	</tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: hexBinary_constructor_03
       Schema: constructorSchema
         Root: hexBinary01
      Purpose: This test demonstrates the use of the xs:hexBinary constructor function and its ability to
      construct a hexBinary string from a string. 
  -->

  <tdml:parserTestCase name="hexBinary_constructor_03" root="hexBinary01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:hexBinary()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text">abcdef123456</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:hexBinary01>
          <string>abcdef123456</string>
          <hexBinary>ABCDEF123456</hexBinary>
        </ex:hexBinary01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlHexBinary_constructor_01
       Schema: constructorSchema
         Root: dfdlHexBinary01
      Purpose: This test demonstrates the use of the dfdl:hexBinary constructor function and its ability to
               construct a hexBinary string from a string.
  -->

  <tdml:parserTestCase name="dfdlHexBinary_constructor_01" root="dfdlHexBinary01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:hexBinary()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:dfdlHexBinary01>00D0</ex:dfdlHexBinary01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlHexBinary_constructor_02
       Schema: constructorSchema
         Root: dfdlHexBinary02
      Purpose: This test demonstrates the use of the dfdl:hexBinary constructor function and its ability to
               construct a hexBinary string from a string.
  -->

  <tdml:parserTestCase name="dfdlHexBinary_constructor_02" root="dfdlHexBinary02" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:hexBinary()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:dfdlHexBinary02>D0</ex:dfdlHexBinary02>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlHexBinary_constructor_03
       Schema: constructorSchema
         Root: dfdlHexBinary03
      Purpose: This test demonstrates the use of the dfdl:hexBinary constructor function and its ability to
               construct a hexBinary string from a string.
  -->

  <tdml:parserTestCase name="dfdlHexBinary_constructor_03" root="dfdlHexBinary03" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:hexBinary()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:dfdlHexBinary03>F7DC</ex:dfdlHexBinary03>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlHexBinary_constructor_04
       Schema: constructorSchema
         Root: dfdlHexBinary04
      Purpose: This test demonstrates the use of the dfdl:hexBinary constructor function and its ability to
               construct a hexBinary string from a string.
  -->

  <tdml:parserTestCase name="dfdlHexBinary_constructor_04" root="dfdlHexBinary04" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:hexBinary()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:dfdlHexBinary04>0AD78EBC5AC6200000</ex:dfdlHexBinary04>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

 <!--
    Test name: dfdlHexBinary_constructor_05
       Schema: constructorSchema
         Root: dfdlHexBinary05
      Purpose: This test demonstrates the use of the dfdl:hexBinary constructor function and its ability to
               construct a hexBinary string from an xs:integer.
  -->

  <tdml:parserTestCase name="dfdlHexBinary_constructor_05" root="dfdlHexBinary05" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:hexBinary()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:dfdlHexBinary05>00008000</ex:dfdlHexBinary05>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
    Test name: dfdlByte_constructor_01
       Schema: constructorSchema
         Root: dfdlByte01
      Purpose: This test demonstrates the use of the dfdl:byte constructor function and its ability to
               construct a hexBinary string from a literal number.
  -->

  <tdml:parserTestCase name="dfdlByte_constructor_01" root="dfdlByte01" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:byte()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:dfdlByte01>127</ex:dfdlByte01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlByte_constructor_02
       Schema: constructorSchema
         Root: dfdlByte02
      Purpose: This test demonstrates the use of the dfdl:byte constructor function and its ability to
               construct a hexBinary string from a literal number.
  -->

  <tdml:parserTestCase name="dfdlByte_constructor_02" root="dfdlByte02" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:byte()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>Value 208 out of range for Byte type</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlByte_constructor_03
       Schema: constructorSchema
         Root: dfdlByte01
      Purpose: This test demonstrates the use of the dfdl:byte constructor function and its ability to
               construct a hexBinary string from a string of decimal digits.
  -->

  <tdml:parserTestCase name="dfdlByte_constructor_03" root="dfdlByte03" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:byte()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:dfdlByte03>127</ex:dfdlByte03>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlByte_constructor_04
       Schema: constructorSchema
         Root: dfdlByte04
      Purpose: This test demonstrates the use of the dfdl:byte constructor function and its ability to
               construct a hexBinary string from a string of decimal digits.
  -->

  <tdml:parserTestCase name="dfdlByte_constructor_04" root="dfdlByte04" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:byte()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>Value 208 out of range for Byte type</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlByte_constructor_03
       Schema: constructorSchema
         Root: dfdlByte01
      Purpose: This test demonstrates the use of the dfdl:byte constructor function and its ability to
               construct a hexBinary string from a string of hex digits.
  -->

  <tdml:parserTestCase name="dfdlByte_constructor_05" root="dfdlByte05" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:byte()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:dfdlByte05>127</ex:dfdlByte05>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlByte_constructor_04
       Schema: constructorSchema
         Root: dfdlByte04
      Purpose: This test demonstrates the use of the dfdl:byte constructor function and its ability to
               construct a hexBinary string from a string of hex digits.
  -->

  <tdml:parserTestCase name="dfdlByte_constructor_06" root="dfdlByte06" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:byte()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>Value 208 out of range for Byte type</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlByte_constructor_07
       Schema: constructorSchema
         Root: dfdlByte07
      Purpose: This test demonstrates the use of the dfdl:byte constructor function and its ability to
               construct a hexBinary string from a string of hex digits.
  -->

  <tdml:parserTestCase name="dfdlByte_constructor_07" root="dfdlByte07" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:byte()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>Cannot convert to type long: For input string: "DG"</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlByte_constructor_08
       Schema: constructorSchema
         Root: dfdlByte08
      Purpose: This test demonstrates the use of the dfdl:byte constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlByte_constructor_08" root="dfdlByte08" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:byte()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:dfdlByte08>127</ex:dfdlByte08>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlByte_constructor_09
       Schema: constructorSchema
         Root: dfdlByte09
      Purpose: This test demonstrates the use of the dfdl:byte constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlByte_constructor_09" root="dfdlByte09" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:byte()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>Value 208 out of range for Byte type</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
    <!--
    Test name: dfdlByte_constructor_10
       Schema: constructorSchema
         Root: dfdlByte10
      Purpose: This test demonstrates the use of the dfdl:byte constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlByte_constructor_10" root="dfdlByte10" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:byte()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>received an unrecognized type!</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
     <!--
    Test name: dfdlUByte_constructor_01
       Schema: constructorSchema
         Root: dfdlUByte01
      Purpose: This test demonstrates the use of the dfdl:unsignedByte constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlUByte_constructor_01" root="dfdlUByte01" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:byte()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:dfdlUByte01>208</ex:dfdlUByte01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlUByte_constructor_02
       Schema: constructorSchema
         Root: dfdlUByte02
      Purpose: This test demonstrates the use of the dfdl:unsignedByte constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlUByte_constructor_02" root="dfdlUByte02" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:byte()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>Value 256 out of range for unsigned byte</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
       <!--
    Test name: dfdlUByte_constructor_03
       Schema: constructorSchema
         Root: dfdlUByte03
      Purpose: This test demonstrates the use of the dfdl:unsignedByte constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlUByte_constructor_03" root="dfdlUByte03" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:byte()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:dfdlUByte03>208</ex:dfdlUByte03>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlUByte_constructor_04
       Schema: constructorSchema
         Root: dfdlUByte04
      Purpose: This test demonstrates the use of the dfdl:unsignedByte constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlUByte_constructor_04" root="dfdlUByte04" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:byte()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>Value 256 out of range for unsigned byte</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
         <!--
    Test name: dfdlUByte_constructor_05
       Schema: constructorSchema
         Root: dfdlUByte05
      Purpose: This test demonstrates the use of the dfdl:unsignedByte constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlUByte_constructor_05" root="dfdlUByte05" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:byte()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:dfdlUByte05>208</ex:dfdlUByte05>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlUByte_constructor_06
       Schema: constructorSchema
         Root: dfdlUByte06
      Purpose: This test demonstrates the use of the dfdl:unsignedByte constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlUByte_constructor_06" root="dfdlUByte06" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:byte()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>violates maximum hex digits</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
           <!--
    Test name: dfdlUByte_constructor_07
       Schema: constructorSchema
         Root: dfdlUByte07
      Purpose: This test demonstrates the use of the dfdl:unsignedByte constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlUByte_constructor_07" root="dfdlUByte07" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:byte()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:dfdlUByte07>208</ex:dfdlUByte07>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlUByte_constructor_08
       Schema: constructorSchema
         Root: dfdlUByte08
      Purpose: This test demonstrates the use of the dfdl:unsignedByte constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlUByte_constructor_08" root="dfdlUByte08" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:byte()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>Value 256 out of range for unsigned byte</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlUByte_constructor_09
       Schema: constructorSchema
         Root: dfdlUByte09
      Purpose: This test demonstrates the use of the dfdl:unsignedByte constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlUByte_constructor_09" root="dfdlUByte09" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:byte()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>received an unrecognized type</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlUByte_constructor_11
       Schema: constructorSchema
         Root: dfdlUByte11
      Purpose: This test demonstrates the use of the dfdl:unsignedByte constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlUByte_constructor_11" root="dfdlUByte11" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:byte()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>Cannot convert to type long: For input string: "DG"</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
   <!--
    Test name: dfdlShort_constructor_01
       Schema: constructorSchema
         Root: dfdlShort01
      Purpose: This test demonstrates the use of the dfdl:short constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlShort_constructor_01" root="dfdlShort01" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:short()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:dfdlShort01>32767</ex:dfdlShort01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlShort_constructor_02
       Schema: constructorSchema
         Root: dfdlShort02
      Purpose: This test demonstrates the use of the dfdl:short constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlShort_constructor_02" root="dfdlShort02" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:short()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>Value 32768 out of range for Short type</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
       <!--
    Test name: dfdlShort_constructor_03
       Schema: constructorSchema
         Root: dfdlShort03
      Purpose: This test demonstrates the use of the dfdl:unsignedByte constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlShort_constructor_03" root="dfdlShort03" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:short()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:dfdlShort03>32767</ex:dfdlShort03>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlShort_constructor_04
       Schema: constructorSchema
         Root: dfdlShort04
      Purpose: This test demonstrates the use of the dfdl:short constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlShort_constructor_04" root="dfdlShort04" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:short()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>Value 32768 out of range for Short type</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
         <!--
    Test name: dfdlShort_constructor_05
       Schema: constructorSchema
         Root: dfdlShort05
      Purpose: This test demonstrates the use of the dfdl:short constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlShort_constructor_05" root="dfdlShort05" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:short()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:dfdlShort05>32767</ex:dfdlShort05>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlShort_constructor_06
       Schema: constructorSchema
         Root: dfdlShort06
      Purpose: This test demonstrates the use of the dfdl:short constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlShort_constructor_06" root="dfdlShort06" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:short()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>Value 32768 out of range for Short type</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
           <!--
    Test name: dfdlShort_constructor_07
       Schema: constructorSchema
         Root: dfdlShort07
      Purpose: This test demonstrates the use of the dfdl:short constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlShort_constructor_07" root="dfdlShort07" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:short()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:dfdlShort07>32767</ex:dfdlShort07>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlShort_constructor_08
       Schema: constructorSchema
         Root: dfdlShort08
      Purpose: This test demonstrates the use of the dfdl:unsignedByte constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlShort_constructor_08" root="dfdlShort08" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:short()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>Value 32768 out of range for Short type</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlShort_constructor_09
       Schema: constructorSchema
         Root: dfdlShort09
      Purpose: This test demonstrates the use of the dfdl:short constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlShort_constructor_09" root="dfdlShort09" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:short()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>dfdl:short received an unrecognized type</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlShort_constructor_11
       Schema: constructorSchema
         Root: dfdlShort11
      Purpose: This test demonstrates the use of the dfdl:short constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlShort_constructor_11" root="dfdlShort11" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:short()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>Cannot convert to type long: For input string: "7FFG"</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlUShort_constructor_01
       Schema: constructorSchema
         Root: dfdlUShort01
      Purpose: This test demonstrates the use of the dfdl:unsignedShort constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlUShort_constructor_01" root="dfdlUShort01" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:unsignedShort()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:dfdlUShort01>65535</ex:dfdlUShort01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlUShort_constructor_02
       Schema: constructorSchema
         Root: dfdlUShort02
      Purpose: This test demonstrates the use of the dfdl:unsignedShort constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlUShort_constructor_02" root="dfdlUShort02" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:unsignedShort()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>Value 65536 out of range for unsigned short</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
       <!--
    Test name: dfdlUShort_constructor_03
       Schema: constructorSchema
         Root: dfdlUShort03
      Purpose: This test demonstrates the use of the dfdl:unsignedByte constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlUShort_constructor_03" root="dfdlUShort03" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:unsignedShort()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:dfdlUShort03>65535</ex:dfdlUShort03>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlUShort_constructor_04
       Schema: constructorSchema
         Root: dfdlUShort04
      Purpose: This test demonstrates the use of the dfdl:unsignedShort constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlUShort_constructor_04" root="dfdlUShort04" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:unsignedShort()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>Value 65536 out of range for unsigned short</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
         <!--
    Test name: dfdlUShort_constructor_05
       Schema: constructorSchema
         Root: dfdlUShort05
      Purpose: This test demonstrates the use of the dfdl:unsignedShort constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlUShort_constructor_05" root="dfdlUShort05" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:unsignedShort()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:dfdlUShort05>65535</ex:dfdlUShort05>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlUShort_constructor_06
       Schema: constructorSchema
         Root: dfdlUShort06
      Purpose: This test demonstrates the use of the dfdl:unsignedShort constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlUShort_constructor_06" root="dfdlUShort06" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:unsignedShort()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>violates maximum hex digits</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
           <!--
    Test name: dfdlUShort_constructor_07
       Schema: constructorSchema
         Root: dfdlUShort07
      Purpose: This test demonstrates the use of the dfdl:unsignedShort constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlUShort_constructor_07" root="dfdlUShort07" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:unsignedShort()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:dfdlUShort07>65535</ex:dfdlUShort07>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlUShort_constructor_08
       Schema: constructorSchema
         Root: dfdlUShort08
      Purpose: This test demonstrates the use of the dfdl:unsignedByte constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlUShort_constructor_08" root="dfdlUShort08" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:unsignedShort()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>Value 65536 out of range for unsigned short</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlUShort_constructor_09
       Schema: constructorSchema
         Root: dfdlUShort09
      Purpose: This test demonstrates the use of the dfdl:unsignedShort constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlUShort_constructor_09" root="dfdlUShort09" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:unsignedShort()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>dfdl:unsignedShort received an unrecognized type</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlUShort_constructor_11
       Schema: constructorSchema
         Root: dfdlUShort11
      Purpose: This test demonstrates the use of the dfdl:unsignedShort constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlUShort_constructor_11" root="dfdlUShort11" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:unsignedShort()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>Cannot convert to type long: For input string: "FFFG"</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlInt_constructor_01
       Schema: constructorSchema
         Root: dfdlInt01
      Purpose: This test demonstrates the use of the dfdl:int constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlInt_constructor_01" root="dfdlInt01" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:int()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:dfdlInt01>2147483647</ex:dfdlInt01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlInt_constructor_02
       Schema: constructorSchema
         Root: dfdlInt02
      Purpose: This test demonstrates the use of the dfdl:int constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlInt_constructor_02" root="dfdlInt02" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:int()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>Value 2147483648 out of range for Int type</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
       <!--
    Test name: dfdlInt_constructor_03
       Schema: constructorSchema
         Root: dfdlInt03
      Purpose: This test demonstrates the use of the dfdl:unsignedByte constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlInt_constructor_03" root="dfdlInt03" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:int()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:dfdlInt03>2147483647</ex:dfdlInt03>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlInt_constructor_04
       Schema: constructorSchema
         Root: dfdlInt04
      Purpose: This test demonstrates the use of the dfdl:int constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlInt_constructor_04" root="dfdlInt04" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:int()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>Value 2147483648 out of range for Int type</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
         <!--
    Test name: dfdlInt_constructor_05
       Schema: constructorSchema
         Root: dfdlInt05
      Purpose: This test demonstrates the use of the dfdl:int constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlInt_constructor_05" root="dfdlInt05" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:int()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:dfdlInt05>2147483647</ex:dfdlInt05>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlInt_constructor_06
       Schema: constructorSchema
         Root: dfdlInt06
      Purpose: This test demonstrates the use of the dfdl:int constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlInt_constructor_06" root="dfdlInt06" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:int()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>Value 2147483648 out of range for Int type</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
           <!--
    Test name: dfdlInt_constructor_07
       Schema: constructorSchema
         Root: dfdlInt07
      Purpose: This test demonstrates the use of the dfdl:int constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlInt_constructor_07" root="dfdlInt07" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:int()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:dfdlInt07>2147483647</ex:dfdlInt07>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlInt_constructor_08
       Schema: constructorSchema
         Root: dfdlInt08
      Purpose: This test demonstrates the use of the dfdl:unsignedByte constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlInt_constructor_08" root="dfdlInt08" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:int()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>Value 2147483648 out of range for Int type</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlInt_constructor_09
       Schema: constructorSchema
         Root: dfdlInt09
      Purpose: This test demonstrates the use of the dfdl:int constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlInt_constructor_09" root="dfdlInt09" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:int()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>dfdl:int received an unrecognized type</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlInt_constructor_11
       Schema: constructorSchema
         Root: dfdlInt11
      Purpose: This test demonstrates the use of the dfdl:int constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlInt_constructor_11" root="dfdlInt11" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:int()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>Cannot convert to type long: For input string: "7FFFFFFG"</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlInt_constructor_12
       Schema: constructorSchema
         Root: dfdlInt12
      Purpose: This test demonstrates the use of the dfdl:int constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlInt_constructor_12" root="dfdlInt12" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:int()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:dfdlInt12>-2147483648</ex:dfdlInt12>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlInt_constructor_13
       Schema: constructorSchema
         Root: dfdlInt13
      Purpose: This test demonstrates the use of the dfdl:int constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlInt_constructor_13" root="dfdlInt13" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:int()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>0x7F cannot be cast to dfdl:int</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlInt_constructor_14
       Schema: constructorSchema
         Root: dfdlInt14
      Purpose: This test demonstrates the use of the dfdl:int constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlInt_constructor_14" root="dfdlInt14" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:int()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
    	<tdml:dfdlInfoset>
    		<ex:dfdlInt14>125</ex:dfdlInt14>
    	</tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlUInt_constructor_01
       Schema: constructorSchema
         Root: dfdlUInt01
      Purpose: This test demonstrates the use of the dfdl:unsignedInt constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlUInt_constructor_01" root="dfdlUInt01" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:unsignedInt()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:dfdlUInt01>4294967295</ex:dfdlUInt01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlUInt_constructor_02
       Schema: constructorSchema
         Root: dfdlUInt02
      Purpose: This test demonstrates the use of the dfdl:unsignedInt constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlUInt_constructor_02" root="dfdlUInt02" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:unsignedInt()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>Value 4294967296 out of range for unsigned int</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
       <!--
    Test name: dfdlUInt_constructor_03
       Schema: constructorSchema
         Root: dfdlUInt03
      Purpose: This test demonstrates the use of the dfdl:unsignedByte constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlUInt_constructor_03" root="dfdlUInt03" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:unsignedInt()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:dfdlUInt03>4294967295</ex:dfdlUInt03>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlUInt_constructor_04
       Schema: constructorSchema
         Root: dfdlUInt04
      Purpose: This test demonstrates the use of the dfdl:unsignedInt constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlUInt_constructor_04" root="dfdlUInt04" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:unsignedInt()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>Value 4294967296 out of range for unsigned int</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
         <!--
    Test name: dfdlUInt_constructor_05
       Schema: constructorSchema
         Root: dfdlUInt05
      Purpose: This test demonstrates the use of the dfdl:unsignedInt constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlUInt_constructor_05" root="dfdlUInt05" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:unsignedInt()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:dfdlUInt05>4294967295</ex:dfdlUInt05>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlUInt_constructor_06
       Schema: constructorSchema
         Root: dfdlUInt06
      Purpose: This test demonstrates the use of the dfdl:unsignedInt constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlUInt_constructor_06" root="dfdlUInt06" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:unsignedInt()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>dfdl:unsignedInt</tdml:error>
    	<tdml:error>violates maximum hex digits</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
           <!--
    Test name: dfdlUInt_constructor_07
       Schema: constructorSchema
         Root: dfdlUInt07
      Purpose: This test demonstrates the use of the dfdl:unsignedInt constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlUInt_constructor_07" root="dfdlUInt07" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:unsignedInt()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:dfdlUInt07>4294967295</ex:dfdlUInt07>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlUInt_constructor_08
       Schema: constructorSchema
         Root: dfdlUInt08
      Purpose: This test demonstrates the use of the dfdl:unsignedByte constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlUInt_constructor_08" root="dfdlUInt08" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:unsignedInt()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>Value 4294967296 out of range for unsigned int</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlUInt_constructor_09
       Schema: constructorSchema
         Root: dfdlUInt09
      Purpose: This test demonstrates the use of the dfdl:unsignedInt constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlUInt_constructor_09" root="dfdlUInt09" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:unsignedInt()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>received an unrecognized type</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlUInt_constructor_11
       Schema: constructorSchema
         Root: dfdlUInt11
      Purpose: This test demonstrates the use of the dfdl:unsignedInt constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlUInt_constructor_11" root="dfdlUInt11" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:unsignedInt()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>Cannot convert to type long: For input string: "FFFFFFFG"</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlUInt_constructor_12
       Schema: constructorSchema
         Root: dfdlUInt12
      Purpose: This test demonstrates the use of the dfdl:unsignedInt constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlUInt_constructor_12" root="dfdlUInt12" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:unsignedInt()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>Negative value -1 cannot be converted to an unsigned int</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  
  <!--
    Test name: dfdlLong_constructor_01
       Schema: constructorSchema
         Root: dfdlLong01
      Purpose: This test demonstrates the use of the dfdl:long constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlLong_constructor_01" root="dfdlLong01" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:long()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:dfdlLong01>9223372036854775807</ex:dfdlLong01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlLong_constructor_02
       Schema: constructorSchema
         Root: dfdlLong02
      Purpose: This test demonstrates the use of the dfdl:long constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlLong_constructor_02" root="dfdlLong02" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:long()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>Value 9223372036854775808 out of range for Long type</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
       <!--
    Test name: dfdlLong_constructor_03
       Schema: constructorSchema
         Root: dfdlLong03
      Purpose: This test demonstrates the use of the dfdl:unsignedByte constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlLong_constructor_03" root="dfdlLong03" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:long()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:dfdlLong03>9223372036854775807</ex:dfdlLong03>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlLong_constructor_04
       Schema: constructorSchema
         Root: dfdlLong04
      Purpose: This test demonstrates the use of the dfdl:long constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlLong_constructor_04" root="dfdlLong04" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:long()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>Cannot convert to type long: For input string: "9223372036854775808"</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
         <!--
    Test name: dfdlLong_constructor_05
       Schema: constructorSchema
         Root: dfdlLong05
      Purpose: This test demonstrates the use of the dfdl:long constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlLong_constructor_05" root="dfdlLong05" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:long()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:dfdlLong05>9223372036854775807</ex:dfdlLong05>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlLong_constructor_06
       Schema: constructorSchema
         Root: dfdlLong06
      Purpose: This test demonstrates the use of the dfdl:long constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlLong_constructor_06" root="dfdlLong06" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:long()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>Cannot convert to type long: For input string: "8000000000000000"</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
           <!--
    Test name: dfdlLong_constructor_07
       Schema: constructorSchema
         Root: dfdlLong07
      Purpose: This test demonstrates the use of the dfdl:long constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlLong_constructor_07" root="dfdlLong07" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:long()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:dfdlLong07>9223372036854775807</ex:dfdlLong07>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlLong_constructor_08
       Schema: constructorSchema
         Root: dfdlLong08
      Purpose: This test demonstrates the use of the dfdl:unsignedByte constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlLong_constructor_08" root="dfdlLong08" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:long()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>Value 9223372036854775808 out of range for Long type</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlLong_constructor_09
       Schema: constructorSchema
         Root: dfdlLong09
      Purpose: This test demonstrates the use of the dfdl:long constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlLong_constructor_09" root="dfdlLong09" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:long()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>dfdl:long received an unrecognized type</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlLong_constructor_11
       Schema: constructorSchema
         Root: dfdlLong11
      Purpose: This test demonstrates the use of the dfdl:long constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlLong_constructor_11" root="dfdlLong11" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:long()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>Cannot convert to type long: For input string: "7FFFFFFFFFFFFFFG"</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlLong_constructor_12
       Schema: constructorSchema
         Root: dfdlLong12
      Purpose: This test demonstrates the use of the dfdl:long constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlLong_constructor_12" root="dfdlLong12" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:long()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
    	<tdml:dfdlInfoset>
    		<ex:dfdlLong12>-9223372036854775808</ex:dfdlLong12>
    	</tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  
  <!--
    Test name: dfdlULong_constructor_01
       Schema: constructorSchema
         Root: dfdlULong01
      Purpose: This test demonstrates the use of the dfdl:unsignedLong constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlULong_constructor_01" root="dfdlULong01" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:unsignedLong()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:dfdlULong01>18446744073709551615</ex:dfdlULong01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlULong_constructor_02
       Schema: constructorSchema
         Root: dfdlULong02
      Purpose: This test demonstrates the use of the dfdl:unsignedLong constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlULong_constructor_02" root="dfdlULong02" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:unsignedLong()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>Value 18446744073709551616 out of range for UnsignedLong type</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
       <!--
    Test name: dfdlULong_constructor_03
       Schema: constructorSchema
         Root: dfdlULong03
      Purpose: This test demonstrates the use of the dfdl:unsignedByte constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlULong_constructor_03" root="dfdlULong03" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:unsignedLong()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:dfdlULong03>18446744073709551615</ex:dfdlULong03>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlULong_constructor_04
       Schema: constructorSchema
         Root: dfdlULong04
      Purpose: This test demonstrates the use of the dfdl:unsignedLong constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlULong_constructor_04" root="dfdlULong04" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:unsignedLong()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>Value 18446744073709551616 out of range for UnsignedLong type</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
         <!--
    Test name: dfdlULong_constructor_05
       Schema: constructorSchema
         Root: dfdlULong05
      Purpose: This test demonstrates the use of the dfdl:unsignedLong constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlULong_constructor_05" root="dfdlULong05" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:unsignedLong()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:dfdlULong05>18446744073709551615</ex:dfdlULong05>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlULong_constructor_06
       Schema: constructorSchema
         Root: dfdlULong06
      Purpose: This test demonstrates the use of the dfdl:unsignedLong constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlULong_constructor_06" root="dfdlULong06" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:unsignedLong()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>violates maximum hex digits</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
           <!--
    Test name: dfdlULong_constructor_07
       Schema: constructorSchema
         Root: dfdlULong07
      Purpose: This test demonstrates the use of the dfdl:unsignedLong constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlULong_constructor_07" root="dfdlULong07" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:unsignedLong()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:dfdlULong07>18446744073709551615</ex:dfdlULong07>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlULong_constructor_08
       Schema: constructorSchema
         Root: dfdlULong08
      Purpose: This test demonstrates the use of the dfdl:unsignedByte constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlULong_constructor_08" root="dfdlULong08" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:unsignedLong()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>Value 18446744073709551616 out of range for UnsignedLong type</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlULong_constructor_09
       Schema: constructorSchema
         Root: dfdlULong09
      Purpose: This test demonstrates the use of the dfdl:unsignedLong constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlULong_constructor_09" root="dfdlULong09" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:unsignedLong()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>dfdl:unsignedLong received an unrecognized type</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlULong_constructor_11
       Schema: constructorSchema
         Root: dfdlULong11
      Purpose: This test demonstrates the use of the dfdl:unsignedLong constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlULong_constructor_11" root="dfdlULong11" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:unsignedLong()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>Cannot convert to type unsignedLong: For input string: "FFFFFFG"</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: dfdlULong_constructor_12
       Schema: constructorSchema
         Root: dfdlULong12
      Purpose: This test demonstrates the use of the dfdl:unsignedLong constructor function and its ability to
               construct a hexBinary string from a short.
  -->

  <tdml:parserTestCase name="dfdlULong_constructor_12" root="dfdlULong12" model="constructorSchema"
    description="Section 23 - Constructor Functions - dfdl:unsignedLong()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
    	<tdml:error>Schema Definition Error</tdml:error>
    	<tdml:error>Negative value -1 cannot be converted to an unsigned long</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: nonNeg_constructor_02a
       Schema: constructorSchema
         Root: nonNeg01
      Purpose: This test demonstrates the use of the xs:nonNegativeInteger constructor function and its ability to
      construct a nonNegativeInteger from a numeric string.
  -->

  <tdml:parserTestCase name="nonNeg_constructor_02a" root="nonNeg01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:nonNegativeInteger()  - DFDL-23-083R">

    <tdml:document>
      <tdml:documentPart type="text">-50,60</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>-50</tdml:error>
      <tdml:error>convert</tdml:error>
      <tdml:error>nonNegativeInteger</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test Name: timezonefromdatetime_01
       Schema: Functions.dfdl.xsd
         Root: e_timezonefromdatetime1
      Purpose: This test demonstrates the use of the timeZoneFromDateTime function to return the time zone as a xs:string from an xs:dateTime.
-->

  <tdml:parserTestCase name="timezonefromdatetime_01" root="e_timezonefromdatetime1"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - dfdl:timeZoneFromDateTime - DFDL-23-109R">

    <tdml:document/>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e_timezonefromdatetime1>-05:00</ex:e_timezonefromdatetime1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test Name: timezonefromdatetime_02
       Schema: Functions.dfdl.xsd
         Root: e_timezonefromdatetime1
      Purpose: This test demonstrates the use of the timeZoneFromDateTime function to return the time zone as a xs:string from an xs:dateTime.
-->

  <tdml:parserTestCase name="timezonefromdatetime_02" root="e_timezonefromdatetime2"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - dfdl:timeZoneFromDateTime - DFDL-23-109R">

    <tdml:document/>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e_timezonefromdatetime2></ex:e_timezonefromdatetime2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test Name: timezonefromdate_01
       Schema: Functions.dfdl.xsd
         Root: e_timezonefromdate1
      Purpose: This test demonstrates the use of the timeZoneFromDate function to return the time zone as a xs:string from an xs:date.
-->

  <tdml:parserTestCase name="timezonefromdate_01" root="e_timezonefromdate1"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - dfdl:timeZoneFromDate - DFDL-23-109R">

    <tdml:document/>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e_timezonefromdate1>-05:00</ex:e_timezonefromdate1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test Name: timezonefromdate_02
       Schema: Functions.dfdl.xsd
         Root: e_timezonefromdate2
      Purpose: This test demonstrates the use of the timeZoneFromDate function to return the time zone as a xs:string from an xs:date.
-->

  <tdml:parserTestCase name="timezonefromdate_02" root="e_timezonefromdate2"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - dfdl:timeZoneFromDate - DFDL-23-109R">

    <tdml:document/>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e_timezonefromdate2/>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test Name: timezonefromtime_01
       Schema: Functions.dfdl.xsd
         Root: e_timezonefromtime1
      Purpose: This test demonstrates the use of the timeZoneFromTime function to return the time zone as a xs:string from an xs:time.
-->

  <tdml:parserTestCase name="timezonefromtime_01" root="e_timezonefromtime1"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - dfdl:timeZoneFromTime - DFDL-23-109R">

    <tdml:document/>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e_timezonefromtime1>-05:00</ex:e_timezonefromtime1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
    Test Name: timezonefromtime_02
       Schema: Functions.dfdl.xsd
         Root: e_timezonefromtime2
      Purpose: This test demonstrates the use of the timeZoneFromTime function to return the time zone as a xs:string from an xs:time.
-->

  <tdml:parserTestCase name="timezonefromtime_02" root="e_timezonefromtime2"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - dfdl:timeZoneFromTime - DFDL-23-109R">

    <tdml:document/>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e_timezonefromtime2/>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
    Test Name: timezonefromtime_03
       Schema: Functions.dfdl.xsd
         Root: e_timezonefromtime3
      Purpose: This test demonstrates the use of the timeZoneFromTime function to return the time zone as a xs:string from an xs:time.
-->

  <tdml:parserTestCase name="timezonefromtime_03" root="e_timezonefromtime3"
    model="Functions.dfdl.xsd" description="Section 23 - Functions - dfdl:timeZoneFromTime - DFDL-23-109R"
    roundTrip="twoPass">

    <tdml:document>04:17:09+07:00</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e_timezonefromtime3>
          <time>04:17:09+07:00</time>
          <timeZone>+07:00</timeZone>
        </ex:e_timezonefromtime3>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <tdml:defineSchema name="XPathMathFunctions">
    <xs:include schemaLocation="org/apache/daffodil/xsd/DFDLGeneralFormat.dfdl.xsd"/>
    <dfdl:format ref="ex:GeneralFormat"/>

    <!-- These pow test were taken from the math:pow examples at https://www.w3.org/TR/xpath-functions-31/#func-math-pow -->
    <xs:element name="pow01" type="xs:double" dfdl:inputValueCalc="{ math:pow(2, 3) }" />
    <xs:element name="pow02" type="xs:double" dfdl:inputValueCalc="{ math:pow(-2, 3) }" />
    <xs:element name="pow03" type="xs:double" dfdl:inputValueCalc="{ math:pow(2, -3) }" />
    <xs:element name="pow04" type="xs:double" dfdl:inputValueCalc="{ math:pow(-2, -3) }" />
    <xs:element name="pow05" type="xs:double" dfdl:inputValueCalc="{ math:pow(2, 0) }" />
    <xs:element name="pow06" type="xs:double" dfdl:inputValueCalc="{ math:pow(0, 0) }" />
    <xs:element name="pow07" type="xs:double" dfdl:inputValueCalc="{ math:pow(xs:double('INF'), 0) }" />
    <xs:element name="pow08" type="xs:double" dfdl:inputValueCalc="{ math:pow(xs:double('NaN'), 0) }" />
    <xs:element name="pow09" type="xs:double" dfdl:inputValueCalc="{ math:pow(-3.14159, 0) }" />
    <xs:element name="pow10" type="xs:double" dfdl:inputValueCalc="{ math:pow(0e0, 3) }" />
    <xs:element name="pow11" type="xs:double" dfdl:inputValueCalc="{ math:pow(0e0, 4) }" />
    <xs:element name="pow12" type="xs:double" dfdl:inputValueCalc="{ math:pow(-0e0, 3) }" />
    <xs:element name="pow13" type="xs:double" dfdl:inputValueCalc="{ math:pow(0, 4) }" />
    <xs:element name="pow14" type="xs:double" dfdl:inputValueCalc="{ math:pow(0e0, -3) }" />
    <xs:element name="pow15" type="xs:double" dfdl:inputValueCalc="{ math:pow(0e0, -4) }" />
    <xs:element name="pow16" type="xs:double" dfdl:inputValueCalc="{ math:pow(-0e0, -3) }" />
    <xs:element name="pow17" type="xs:double" dfdl:inputValueCalc="{ math:pow(0, -4) }" />
    <xs:element name="pow18" type="xs:double" dfdl:inputValueCalc="{ math:pow(16, 0.5e0) }" />
    <xs:element name="pow19" type="xs:double" dfdl:inputValueCalc="{ math:pow(16, 0.25e0) }" />
    <xs:element name="pow20" type="xs:double" dfdl:inputValueCalc="{ math:pow(0e0, -3.0e0) }" />
    <xs:element name="pow21" type="xs:double" dfdl:inputValueCalc="{ math:pow(-0e0, -3.0e0) }" />
    <xs:element name="pow22" type="xs:double" dfdl:inputValueCalc="{ math:pow(0e0, -3.1e0) }" />
    <xs:element name="pow23" type="xs:double" dfdl:inputValueCalc="{ math:pow(-0e0, -3.1e0) }" />
    <xs:element name="pow24" type="xs:double" dfdl:inputValueCalc="{ math:pow(0e0, 3.0e0) }" />
    <xs:element name="pow25" type="xs:double" dfdl:inputValueCalc="{ math:pow(-0e0, 3.0e0) }" />
    <xs:element name="pow26" type="xs:double" dfdl:inputValueCalc="{ math:pow(0e0, 3.1e0) }" />
    <xs:element name="pow27" type="xs:double" dfdl:inputValueCalc="{ math:pow(-0e0, 3.1e0) }" />
    <xs:element name="pow28" type="xs:double" dfdl:inputValueCalc="{ math:pow(-1, xs:double('INF')) }" />
    <xs:element name="pow29" type="xs:double" dfdl:inputValueCalc="{ math:pow(-1, xs:double('-INF')) }" />
    <xs:element name="pow30" type="xs:double" dfdl:inputValueCalc="{ math:pow(1, xs:double('INF')) }" />
    <xs:element name="pow31" type="xs:double" dfdl:inputValueCalc="{ math:pow(1, xs:double('-INF')) }" />
    <xs:element name="pow32" type="xs:double" dfdl:inputValueCalc="{ math:pow(1, xs:double('NaN')) }" />
    <xs:element name="pow33" type="xs:double" dfdl:inputValueCalc="{ math:pow(-2.5e0, 2.0e0) }" />
    <xs:element name="pow34" type="xs:double" dfdl:inputValueCalc="{ math:pow(-2.5e0, 2.00000001e0) }" />
  </tdml:defineSchema>

  <tdml:parserTestCase name="mathPow01" root="pow01" model="XPathMathFunctions" description="Section 23 - Functions - math:pow - DFDL-23-109R">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><pow01>8.0</pow01></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="mathPow02" root="pow02" model="XPathMathFunctions" description="Section 23 - Functions - math:pow - DFDL-23-109R">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><pow02>-8.0</pow02></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="mathPow03" root="pow03" model="XPathMathFunctions" description="Section 23 - Functions - math:pow - DFDL-23-109R">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><pow03>0.125</pow03></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="mathPow04" root="pow04" model="XPathMathFunctions" description="Section 23 - Functions - math:pow - DFDL-23-109R">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><pow04>-0.125</pow04></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="mathPow05" root="pow05" model="XPathMathFunctions" description="Section 23 - Functions - math:pow - DFDL-23-109R">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><pow05>1.0</pow05></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="mathPow06" root="pow06" model="XPathMathFunctions" description="Section 23 - Functions - math:pow - DFDL-23-109R">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><pow06>1.0</pow06></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="mathPow07" root="pow07" model="XPathMathFunctions" description="Section 23 - Functions - math:pow - DFDL-23-109R">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><pow07>1.0</pow07></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="mathPow08" root="pow08" model="XPathMathFunctions" description="Section 23 - Functions - math:pow - DFDL-23-109R">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><pow08>1.0</pow08></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

<!--
  Requires math:pi()  -->
  <tdml:parserTestCase name="mathPow09" root="pow09" model="XPathMathFunctions" description="Section 23 - Functions - math:pow - DFDL-23-109R">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><pow09>1.0</pow09></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>
<!-- -->

  <tdml:parserTestCase name="mathPow10" root="pow10" model="XPathMathFunctions" description="Section 23 - Functions - math:pow - DFDL-23-109R">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><pow10>0.0</pow10></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="mathPow11" root="pow11" model="XPathMathFunctions" description="Section 23 - Functions - math:pow - DFDL-23-109R">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><pow11>0.0</pow11></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="mathPow12" root="pow12" model="XPathMathFunctions" description="Section 23 - Functions - math:pow - DFDL-23-109R">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><pow12>-0.0</pow12></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="mathPow13" root="pow13" model="XPathMathFunctions" description="Section 23 - Functions - math:pow - DFDL-23-109R">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><pow13>0.0</pow13></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="mathPow14" root="pow14" model="XPathMathFunctions" description="Section 23 - Functions - math:pow - DFDL-23-109R">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><pow14>INF</pow14></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="mathPow15" root="pow15" model="XPathMathFunctions" description="Section 23 - Functions - math:pow - DFDL-23-109R">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><pow15>INF</pow15></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="mathPow16" root="pow16" model="XPathMathFunctions" description="Section 23 - Functions - math:pow - DFDL-23-109R">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><pow16>-INF</pow16></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="mathPow17" root="pow17" model="XPathMathFunctions" description="Section 23 - Functions - math:pow - DFDL-23-109R">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><pow17>INF</pow17></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="mathPow18" root="pow18" model="XPathMathFunctions" description="Section 23 - Functions - math:pow - DFDL-23-109R">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><pow18>4.0</pow18></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="mathPow19" root="pow19" model="XPathMathFunctions" description="Section 23 - Functions - math:pow - DFDL-23-109R">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><pow19>2.0</pow19></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="mathPow20" root="pow20" model="XPathMathFunctions" description="Section 23 - Functions - math:pow - DFDL-23-109R">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><pow20>INF</pow20></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="mathPow21" root="pow21" model="XPathMathFunctions" description="Section 23 - Functions - math:pow - DFDL-23-109R">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><pow21>-INF</pow21></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="mathPow22" root="pow22" model="XPathMathFunctions" description="Section 23 - Functions - math:pow - DFDL-23-109R">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><pow22>INF</pow22></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="mathPow23" root="pow23" model="XPathMathFunctions" description="Section 23 - Functions - math:pow - DFDL-23-109R">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><pow23>INF</pow23></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="mathPow24" root="pow24" model="XPathMathFunctions" description="Section 23 - Functions - math:pow - DFDL-23-109R">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><pow24>0.0</pow24></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="mathPow25" root="pow25" model="XPathMathFunctions" description="Section 23 - Functions - math:pow - DFDL-23-109R">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><pow25>-0.0</pow25></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="mathPow26" root="pow26" model="XPathMathFunctions" description="Section 23 - Functions - math:pow - DFDL-23-109R">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><pow26>0.0</pow26></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="mathPow27" root="pow27" model="XPathMathFunctions" description="Section 23 - Functions - math:pow - DFDL-23-109R">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><pow27>0.0</pow27></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="mathPow28" root="pow28" model="XPathMathFunctions" description="Section 23 - Functions - math:pow - DFDL-23-109R">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><pow28>1.0</pow28></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="mathPow29" root="pow29" model="XPathMathFunctions" description="Section 23 - Functions - math:pow - DFDL-23-109R">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><pow29>1.0</pow29></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="mathPow30" root="pow30" model="XPathMathFunctions" description="Section 23 - Functions - math:pow - DFDL-23-109R">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><pow30>1.0</pow30></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="mathPow31" root="pow31" model="XPathMathFunctions" description="Section 23 - Functions - math:pow - DFDL-23-109R">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><pow31>1.0</pow31></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="mathPow32" root="pow32" model="XPathMathFunctions" description="Section 23 - Functions - math:pow - DFDL-23-109R">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><pow32>1.0</pow32></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="mathPow33" root="pow33" model="XPathMathFunctions" description="Section 23 - Functions - math:pow - DFDL-23-109R">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><pow33>6.25</pow33></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="mathPow34" root="pow34" model="XPathMathFunctions" description="Section 23 - Functions - math:pow - DFDL-23-109R">
    <tdml:document></tdml:document>
    <tdml:infoset><tdml:dfdlInfoset><pow34>NaN</pow34></tdml:dfdlInfoset></tdml:infoset>
  </tdml:parserTestCase>

</tdml:testSuite>
